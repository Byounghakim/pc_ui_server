
// 고유 클라이언트 ID 생성 함수
const generateClientId = () => {
  if (typeof window === 'undefined') return 'server';
  return `client_${Math.random().toString(36).substring(2, 15)}`;
};

// 시간 형식 포맷팅 함수 추가
const formatTimeStr = (): string => {
  const now = new Date();
  const hours = now.getHours().toString().padStart(2, '0');
  const minutes = now.getMinutes().toString().padStart(2, '0');
  const seconds = now.getSeconds().toString().padStart(2, '0');
  return `${hours}:${minutes}:${seconds}`;
};

// 시스템 상태 저장 및 불러오기 함수 개선
const saveState = async (stateToSave: any) => {
  try {
    // 로컬 스토리지에 상태 저장
    if (typeof window !== 'undefined') {
      localStorage.setItem('tankSystemState', JSON.stringify(stateToSave));
      
      // API 호출 비활성화 - 서버 API 대신 로컬 스토리지만 사용
      console.log('서버 API 호출 대신 로컬 스토리지에만 저장합니다.');
      
      // IndexedDB에도 저장
      if (typeof saveToIndexedDB === 'function') {
        saveToIndexedDB(stateToSave);
      }
      
      // 다른 탭/창에 상태 변경 알림
      localStorage.setItem('tankSystemStateUpdate', Date.now().toString());
    }
  } catch (error) {
    console.error('상태 저장 실패:', error);
  }
};

// IndexedDB에 상태 저장
const saveToIndexedDB = (state: any) => {
  if (typeof window === 'undefined' || !window.indexedDB) {
    console.warn('IndexedDB를 사용할 수 없습니다.');
    return;
  }
  
  try {
    const request = window.indexedDB.open('TankSystemDB', 1);
    
    request.onupgradeneeded = function(event) {
      try {
        const db = request.result;
        if (!db.objectStoreNames.contains('systemState')) {
          db.createObjectStore('systemState', { keyPath: 'id' });
        }
      } catch (error) {
        console.error('IndexedDB 스키마 업그레이드 중 오류:', error);
        // 오류가 발생해도 계속 진행
      }
    };
    
    request.onsuccess = function(event) {
      try {
        const db = request.result;
        const transaction = db.transaction(['systemState'], 'readwrite');
        const store = transaction.objectStore('systemState');
        
        // 항상 같은 키로 저장하여 최신 상태만 유지
        const putRequest = store.put({
          id: 'currentState',
          data: state,
          timestamp: Date.now()
        });
        
        putRequest.onsuccess = function() {
          console.log('IndexedDB에 상태 저장 성공');
        };
        
        putRequest.onerror = function(event) {
          console.warn('IndexedDB 데이터 저장 중 오류:', event);
        };
        
        transaction.oncomplete = function() {
          db.close();
        };
        
        transaction.onerror = function(event) {
          console.warn('IndexedDB 트랜잭션 오류:', event);
        };
      } catch (error) {
        console.error('IndexedDB 트랜잭션 생성 중 오류:', error);
      }
    };
    
    request.onerror = function(event) {
      console.warn('IndexedDB 열기 오류:', event);
    };
  } catch (error) {
    console.error('IndexedDB 접근 중 예상치 못한 오류:', error);
  }
};

// 상태 불러오기 함수 개선
const loadState = () => {
  if (typeof window !== 'undefined') {
    try {
      const storedState = localStorage.getItem('tankSystemState');
      
      if (storedState) {
        return JSON.parse(storedState);
      }
      
      return null;
    } catch (error) {
      console.error('상태 불러오기 실패:', error);
      return null;
    }
  }
  
  return null;
};

// 서버에서 초기 상태 불러오기
const loadInitialState = async (): Promise<any> => {
  if (typeof window !== 'undefined') {
    try {
      // 서버 API에서 상태 가져오기
      if (window.navigator.onLine) {
        try {
          console.log('서버에서 최신 상태 불러오기 시도...');
          console.log('API 호출 대신 로컬 스토리지만 사용합니다.');
        } catch (serverError) {
          console.error('서버에서 상태 불러오기 실패:', serverError);
          // 서버 오류 시 계속 진행 - 로컬 저장소 사용
        }
      }
      
      // 서버에서 불러오기 실패 시 로컬 스토리지에서 불러오기 시도
      try {
        const localState = loadState();
        if (localState) {
          console.log('로컬 스토리지에서 상태를 불러왔습니다.');
          return localState;
        }
      } catch (localError) {
        console.error('로컬 스토리지에서 상태 불러오기 실패:', localError);
        // 로컬 스토리지 오류 시 계속 진행 - IndexedDB 사용
      }
      
      // IndexedDB에서 불러오기 시도
      try {
        const idbState = await loadFromIndexedDB();
        if (idbState) {
          console.log('IndexedDB에서 상태를 불러왔습니다.');
          return idbState;
        }
      } catch (idbError) {
        console.error('IndexedDB에서 상태 불러오기 실패:', idbError);
        // IndexedDB 오류 시 기본값 사용
      }
    } catch (error) {
      console.error('초기 상태 불러오기 전체 프로세스 실패:', error);
      // 모든 오류 시 기본값 사용
    }
  }
  
  console.log('사용 가능한 저장된 상태가 없습니다. 기본값 사용.');
  return null;
};

// IndexedDB에서 상태 불러오기 (Promise 반환)
const loadFromIndexedDB = (): Promise<any> => {
  return new Promise((resolve, reject) => {
    if (typeof window === 'undefined' || !window.indexedDB) {
      console.warn('IndexedDB를 사용할 수 없습니다.');
      resolve(null);
      return;
    }
    
    try {
      const request = window.indexedDB.open('TankSystemDB', 1);
      
      request.onupgradeneeded = function(event) {
        try {
          const db = request.result;
          if (!db.objectStoreNames.contains('systemState')) {
            db.createObjectStore('systemState', { keyPath: 'id' });
          }
        } catch (error) {
          console.error('IndexedDB 스키마 업그레이드 중 오류:', error);
          // 업그레이드 오류가 발생해도 계속 진행 가능하도록 함
        }
      };
      
      request.onsuccess = function(event) {
        try {
          const db = request.result;
          const transaction = db.transaction(['systemState'], 'readonly');
          const store = transaction.objectStore('systemState');
          const getRequest = store.get('currentState');
          
          getRequest.onsuccess = function() {
            if (getRequest.result) {
              resolve(getRequest.result.data);
            } else {
              console.log('IndexedDB에 저장된 상태가 없습니다.');
              resolve(null);
            }
          };
          
          getRequest.onerror = function(event) {
            console.warn('IndexedDB 읽기 오류:', event);
            resolve(null); // 오류 발생 시에도 null을 반환하여 앱이 계속 실행되도록 함
          };
          
          transaction.oncomplete = function() {
            db.close();
          };
        } catch (error) {
          console.error('IndexedDB 트랜잭션 중 오류:', error);
          resolve(null);
        }
      };
      
      request.onerror = function(event) {
        console.warn('IndexedDB 접근 오류:', event);
        resolve(null); // reject 대신 resolve(null)을 사용하여 앱이 계속 실행되도록 함
      };
    } catch (error) {
      console.error('IndexedDB 사용 중 예상치 못한 오류:', error);
      resolve(null); // 모든 예외 상황에서도 앱이 계속 실행되도록 함
    }
  });
};

interface TankSystemProps {
  tankData: {
    mainTank: {
      level: number
      status: string
    }
    tanks: Tank[]
    valveState: string
    valveStatusMessage?: string
    valveADesc?: string  // 밸브 A 설명 추가
    valveBDesc?: string  // 밸브 B 설명 추가
    tankMessages?: Record<number, string>
    mainTankMessage?: string
    progressInfo?: {
      step: string
      elapsedTime: string
      remainingTime: string
      totalRemainingTime: string
    }
  }
  onValveChange: (newState: string) => void
  onPumpToggle?: (pumpId: number) => void  // 펌프 토글 함수
  onPumpReset?: (pumpId: number) => void   // 펌프 리셋 함수
  onPumpKCommand?: (pumpId: number) => void // 펌프 K 명령 함수
  // onExtractionCommand 속성 제거됨
  pumpStateMessages?: Record<number, string> // 펌프 상태 메시지
  mqttClient?: MqttClient // MQTT 클라이언트 추가
  kButtonActive?: boolean // K 버튼 활성화 여부
  pumpMessages?: Record<number, string> // 펌프 메시지
  progressMessages?: Array<{timestamp: number, message: string, rawJson?: string | null}> // 진행 메시지 추가
  setProgressMessages?: (messages: Array<{timestamp: number, message: string, rawJson?: string | null}> | ((prev: Array<{timestamp: number, message: string, rawJson?: string | null}>) => Array<{timestamp: number, message: string, rawJson?: string | null}>)) => void // 진행 메시지 업데이트 함수 추가
}

// 추출 진행 메시지를 위한 인터페이스
interface ExtractionProgress {
  timestamp: number
  message: string
}

// 연결 상태를 위한 인터페이스
interface ConnectionStatus {
  connected: boolean
  lastConnected: Date | null
  reconnecting: boolean
}

// 펄스 애니메이션을 위한 스타일 추가
const pulseCss = `
  @keyframes pulse {
    0% {
      opacity: 0.6;
    }
    50% {
      opacity: 0.8;
    }
    100% {
      opacity: 0.6;
    }
  }
`;

export default function TankSystem({ 
  tankData, 
  onValveChange, 
  progressMessages = [], 
  onPumpToggle, 
  onPumpReset,
  onPumpKCommand,
  pumpStateMessages = {},
  mqttClient,
  // onExtractionCommand 속성 제거됨
  kButtonActive,
  pumpMessages,
  setProgressMessages
}: TankSystemProps) {
  // 고유 클라이언트 ID 생성 함수
  const generateClientId = () => {
    if (typeof window === 'undefined') return 'server';
    return `client_${Math.random().toString(36).substring(2, 15)}`;
  };

  // MQTT 토픽에서 진행 정보 파싱을 위한 인터페이스 추가
  interface ProcessProgress {
    mode: string;             // 작동 모드 (동시모드, 순차모드, 오버랩모드)
    elapsed_time: number;     // 경과 시간 (초)
    remaining_time: number;   // 남은 시간 (초)
    total_repeats: number;    // 총 반복 횟수 
    current_repeat: number;   // 현재 반복 횟수
    pump_id?: string;         // 펌프 ID (순차모드, 오버랩모드에서 사용)
  }

  // 진행 상태 정보 저장 (펌프 ID별)
  const [pumpProgressInfo, setPumpProgressInfo] = useState<Record<number, ProcessProgress>>({});
  const [isResetDragging, setIsResetDragging] = useState<Record<number, boolean>>({});
  const [dragStartPos, setDragStartPos] = useState<{x: number, y: number}>({x: 0, y: 0});
  const [isPumpDragging, setIsPumpDragging] = useState<Record<number, boolean>>({});
  const [pumpClickStatus, setPumpClickStatus] = useState<Record<number, boolean>>({});
  const [isPumpHolding, setIsPumpHolding] = useState<number | null>(null);
  const pumpHoldTimer = useRef<number | null>(null);
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [lastProcessedMessage, setLastProcessedMessage] = useState<string>('');
  const [extractionStarted, setExtractionStarted] = useState<boolean>(false);
  const [extractionCompleteMessage, setExtractionCompleteMessage] = useState<string>("");
  const [automationStatus, setAutomationStatus] = useState<string>("");
  const [automationProgress, setAutomationProgress] = useState<string>("");
  const [automationWaitTime, setAutomationWaitTime] = useState<{value: number, endTime?: number} | null>(null);
  const [lastProgressPercent, setLastProgressPercent] = useState<number>(0); // 진행률 상태 추가

  // 파이프 활성화 상태 관리
  const [pipeActiveStatus, setPipeActiveStatus] = useState<Record<number, boolean>>({});

  // 진행 정보 메시지 파싱 함수 - extwork/extraction/progress 토픽용
  const parseProgressMessage = (messageStr: string): ProcessProgress | null => {
    try {
      // JSON 파싱 시도
      if (messageStr.startsWith('{') && messageStr.endsWith('}')) {
        const progressData = JSON.parse(messageStr);
        
        // 기본 필드 확인
        if (progressData.elapsed_time && progressData.remaining_time) {
          // 경과 시간과 남은 시간을 초 단위로 파싱
          const elapsedStr = progressData.elapsed_time.replace('s', '');
          const remainingStr = progressData.remaining_time.replace('s', '');
          const elapsed = parseInt(elapsedStr, 10);
          const remaining = parseInt(remainingStr, 10);
          
          // 기본 프로그레스 정보 객체
          const progress: ProcessProgress = {
            mode: '',
            elapsed_time: elapsed,
            remaining_time: remaining,
            total_repeats: 1,
            current_repeat: 0,
            pump_id: undefined
          };
          
          // 모드 정보 파싱
          if (progressData.mode) {
            progress.mode = progressData.mode;
          } else if (messageStr.includes('동시모드')) {
            progress.mode = '동시모드';
          } else if (messageStr.includes('순차모드')) {
            progress.mode = '순차모드';
          } else if (messageStr.includes('오버랩모드')) {
            progress.mode = '오버랩모드';
          }
          
          // 반복 횟수 정보 파싱 - 동시모드
          if (progress.mode === '동시모드' && progressData.process_info) {
            const processMatch = progressData.process_info.match(/S\((\d+)\/(\d+)\)/);
            if (processMatch) {
              progress.current_repeat = parseInt(processMatch[1], 10);
              progress.total_repeats = parseInt(processMatch[2], 10) || 1; // 0이면 1로 처리
            }
          }
          
          // 펌프 ID 및 반복 횟수 파싱 - 순차모드 & 오버랩모드
          if ((progress.mode === '순차모드' || progress.mode === '오버랩모드') && progressData.pump_id) {
            // 정확한 패턴 매칭: "1(0/9)" 형식
            const pumpMatch = progressData.pump_id.match(/(\d+)\((\d+)\/(\d+)\)/);
            if (pumpMatch) {
              progress.pump_id = pumpMatch[1]; // 펌프 ID (예: "1")
              
              // 순차 모드 개선: 정확한 현재 반복 횟수와 총 반복 횟수 계산
              progress.current_repeat = parseInt(pumpMatch[2], 10); // 현재 반복 횟수 (예: 0)
              
              // 총 반복 횟수 처리 - 0부터 시작하므로 +1
              const totalRepeats = parseInt(pumpMatch[3], 10) + 1; // 0부터 시작하므로 +1
              progress.total_repeats = totalRepeats || 1; // 총 반복 횟수가 0이면 1로 설정
              
              console.log(`펌프 ${progress.pump_id} 진행 정보 파싱: 현재 ${progress.current_repeat+1}/${progress.total_repeats} 회 (${((progress.current_repeat/progress.total_repeats)*100).toFixed(1)}% 진행)`);
            }
          }
          
          return progress;
        }
      }
      
      // 텍스트 형식으로 된 메시지 파싱 시도 (비 JSON 형식)
      const elapsedMatch = messageStr.match(/경과:\s*(\d+)s/) || messageStr.match(/elapsed_time":\s*"(\d+)s/);
      const remainingMatch = messageStr.match(/남은:\s*(\d+)s/) || messageStr.match(/remaining_time":\s*"(\d+)s/);
      
      if (elapsedMatch && remainingMatch) {
        const elapsed = parseInt(elapsedMatch[1], 10);
        const remaining = parseInt(remainingMatch[1], 10);
        
        // 기본 프로그레스 정보 객체
        const progress: ProcessProgress = {
          mode: '',
          elapsed_time: elapsed,
          remaining_time: remaining,
          total_repeats: 1,
          current_repeat: 0,
          pump_id: undefined
        };
        
        // 모드 정보 파싱
        if (messageStr.includes('동시모드')) {
          progress.mode = '동시모드';
          // 동시모드 반복 횟수 정보 파싱
          const processMatch = messageStr.match(/S\((\d+)\/(\d+)\)/);
          if (processMatch) {
            progress.current_repeat = parseInt(processMatch[1], 10);
            progress.total_repeats = parseInt(processMatch[2], 10) || 1; // 0이면 1로 처리
          }
        } else if (messageStr.includes('순차모드')) {
          progress.mode = '순차모드';
          
          // 순차모드 펌프 ID 및 반복 횟수 파싱 - 개선된 정규식
          const pumpMatch = messageStr.match(/펌프\s*(\d+)\s*\((\d+)\/(\d+)\)/) || 
                            messageStr.match(/(\d+)\((\d+)\/(\d+)\)/);
          
          if (pumpMatch) {
            progress.pump_id = pumpMatch[1]; // 펌프 ID
            progress.current_repeat = parseInt(pumpMatch[2], 10); // 현재 반복 횟수
            
            // 총 반복 횟수 처리 - 0이면 1로 설정 (100% 채워짐)
            const totalRepeats = parseInt(pumpMatch[3], 10) + 1; // 0부터 시작하므로 +1
            progress.total_repeats = totalRepeats || 1;
            
            console.log(`[텍스트] 펌프 ${progress.pump_id} 순차모드 진행 정보: ${progress.current_repeat+1}/${progress.total_repeats} 회`);
          }
        } else if (messageStr.includes('오버랩모드')) {
          progress.mode = '오버랩모드';
          
          // 오버랩모드 펌프 ID 및 반복 횟수 파싱 - 개선된 정규식
          const pumpMatch = messageStr.match(/펌프\s*(\d+)\s*\((\d+)\/(\d+)\)/) || 
                            messageStr.match(/(\d+)\((\d+)\/(\d+)\)/);
                          
          if (pumpMatch) {
            progress.pump_id = pumpMatch[1]; // 펌프 ID
            progress.current_repeat = parseInt(pumpMatch[2], 10); // 현재 반복 횟수
            
            // 총 반복 횟수 처리 - 0이면 1로 설정 (100% 채워짐)
            const totalRepeats = parseInt(pumpMatch[3], 10) + 1; // 0부터 시작하므로 +1
            progress.total_repeats = totalRepeats || 1;
            
            console.log(`[텍스트] 펌프 ${progress.pump_id} 오버랩모드 진행 정보: ${progress.current_repeat+1}/${progress.total_repeats} 회`);
          }
        }
        
        return progress;
      }
      
      return null;
    } catch (error) {
      console.error('진행 정보 파싱 오류:', error);
      return null;
    }
  };

  // 애니메이션을 위한 상태 추가
  const [fillPercentage, setFillPercentage] = useState(0);
  
  // 길게 누르기 감지를 위한 타이머 상태 추가
  const [longPressTimer, setLongPressTimer] = useState<NodeJS.Timeout | null>(null);
  const [currentPressedPump, setCurrentPressedPump] = useState<number | null>(null);
  
  // 클라이언트 ID 상태 추가
  const clientId = useRef(generateClientId());
  
  // 마지막 상태 업데이트 시간
  const [lastStateUpdate, setLastStateUpdate] = useState<Date | null>(null);
  
  // 연결 상태 추가
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>({
    connected: false,
    lastConnected: null,
    reconnecting: false
  });
  
  // 상태 변경 알림을 위한 상태 업데이트 - SystemNotification 타입 사용
  const [notifications, setNotifications] = useState<SystemNotification[]>([]);

  // 알림 추가 함수 
  const addNotification = (message: string, type: 'info' | 'warning' | 'error' = 'info', pumpId?: number) => {
