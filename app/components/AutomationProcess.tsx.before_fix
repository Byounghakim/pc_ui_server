import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import MqttClient from '@/lib/mqtt-client';
import { 
  EXTRACTION_INPUT_TOPIC, 
  EXTRACTION_OUTPUT_TOPIC, 
  PROCESS_PROGRESS_TOPIC,
  AUTOMATION_CONTROL_TOPIC,
  AUTOMATION_STATUS_TOPIC,
  ERROR_TOPIC,
  QUEUE_STATUS_TOPIC
} from '@/lib/mqtt-topics';
import { Checkbox } from "@/app/components/ui/checkbox";
import { X, Play, Square, RotateCcw, ArrowUp, ArrowDown, PlusCircle, Trash2 } from 'lucide-react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { PumpSequence } from '../types/index';
import workLogService from '../services/work-log-service';
import { ScrollArea } from "@/app/components/ui/scroll-area";
import { Separator } from "@/app/components/ui/separator";
import { Input } from '@/components/ui/input';
import { v4 as uuidv4 } from 'uuid';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogClose } from "@/app/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { AlertDialog, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogCancel, AlertDialogAction } from "@/app/components/ui/alert-dialog";
import { toast } from "@/app/components/ui/use-toast";

// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ í‚¤
const AUTOMATION_STATE_KEY = 'automation-process-state';
const AUTOMATION_SEQUENCES_KEY = 'automation-process-sequences';

type AutomationStatus = 'waiting' | 'running' | 'paused' | 'stopped' | 'completed' | 'error';
type SequenceStatus = 'waiting' | 'running' | 'completed' | 'error';

// í ì•„ì´í…œ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
interface QueueItem {
  id: string;
  name: string;
  timestamp: number;
  data: any;
}

// í ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
interface QueueStatus {
  isProcessing: boolean;
  count: number;
  items?: QueueItem[];
}

interface SequenceWithStatus {
  id: string;
  sequence: PumpSequence;
  status: SequenceStatus;
  waitTime: number;
  customRepeats: number;
  startTime?: number;
  endTime?: number;
  errorDetails?: string;
}

interface SavedProcess {
  id: string;
  name: string;
  description?: string;
  sequences: SequenceWithStatus[];
  createdAt: string;
  updatedAt: string;
}

interface AutomationProcessProps {
  mqttClient: MqttClient | null;
  savedSequences: PumpSequence[];
  onLockChange?: (locked: boolean) => void; // ìë™í™” ê³µì • ì ê¸ˆ ìƒíƒœ ë³€ê²½ ì½œë°±
}

// ëŒ€ê¸° ì¤‘ì¸ ì—…ë°ì´íŠ¸ íƒ€ì… ì •ì˜
interface PendingUpdate {
  type: string;
  data: any;
}

// ì‹œí€€ìŠ¤ JSON í˜•ì‹ í‘œì¤€í™” í•¨ìˆ˜
const standardizeSequenceJson = (sequence: any): any => {
  // operation_mode ìœ íš¨ì„± ê²€ì‚¬ ë° í‘œì¤€í™”
  let operationMode = sequence.operation_mode;
  const firstDigit = Math.floor(operationMode / 10);
  
  // ì²« ë²ˆì§¸ ìë¦¬ê°€ 1ì¸ ê²½ìš° (ë™ì‹œ ëª¨ë“œ) -> 12ë¡œ í‘œì¤€í™”
  if (firstDigit === 1) {
    operationMode = 12;
  } 
  // ì²« ë²ˆì§¸ ìë¦¬ê°€ 2ì¸ ê²½ìš° (ìˆœì°¨ ëª¨ë“œ) -> 22ë¡œ í‘œì¤€í™”
  else if (firstDigit === 2) {
    operationMode = 22;
  }
  // ê·¸ ì™¸ì˜ ê²½ìš° ê¸°ë³¸ê°’ 30 (í˜¼í•© ëª¨ë“œ)ë¡œ ì„¤ì •
  else if (firstDigit !== 3) {
    operationMode = 30;
  }
  
  // í”„ë¡œì„¸ìŠ¤ ë°°ì—´ í‘œì¤€í™”
  let processArray = [...sequence.process];
  
  // í”„ë¡œì„¸ìŠ¤ ë°°ì—´ì— ìœ íš¨í•˜ì§€ ì•Šì€ ê°’(7, 8, 9)ì´ ìˆìœ¼ë©´ ìœ íš¨í•œ ê°’(0, 5, 6, 10)ìœ¼ë¡œ ë³€í™˜
  processArray = processArray.map((value: number) => {
    if (value === 7 || value === 8 || value === 9) {
      return 6; // ìœ íš¨í•œ ê°’ìœ¼ë¡œ ëŒ€ì²´
    }
    return value;
  });
  
  // ëª¨ë“œë³„ë¡œ ì ì ˆí•œ process ë°°ì—´ ê¸¸ì´ì™€ íŒ¨í„´ í™•ë³´
  if (operationMode === 12) { // ë™ì‹œ ëª¨ë“œ
    // í”„ë¡œì„¸ìŠ¤ ê¸¸ì´ê°€ 6ì˜ ë°°ìˆ˜ê°€ ë˜ë„ë¡ ì¡°ì •
    while (processArray.length % 6 !== 0) {
      processArray.push(0);
    }
  } else if (operationMode === 22) { // ìˆœì°¨ ëª¨ë“œ
    // í”„ë¡œì„¸ìŠ¤ ê¸¸ì´ê°€ 3ì˜ ë°°ìˆ˜ê°€ ë˜ë„ë¡ ì¡°ì •
    while (processArray.length % 3 !== 0) {
      processArray.push(0);
    }
    
    // ê° ê·¸ë£¹ì´ [6, 5, 0] íŒ¨í„´ìœ¼ë¡œ í‘œì¤€í™”
    const standardizedProcess = [];
    for (let i = 0; i < processArray.length; i += 3) {
      standardizedProcess.push(6);
      standardizedProcess.push(5);
      standardizedProcess.push(0);
    }
    processArray = standardizedProcess;
  } else if (operationMode === 30) { // í˜¼í•© ëª¨ë“œ
    // í”„ë¡œì„¸ìŠ¤ ê¸¸ì´ê°€ ì§ìˆ˜ê°€ ë˜ë„ë¡ ì¡°ì •
    if (processArray.length % 2 !== 0) {
      processArray.push(0);
    }
    
    // êµì°¨ íŒ¨í„´(10, 5, ...)ìœ¼ë¡œ í‘œì¤€í™”
    const standardizedProcess = [];
    for (let i = 0; i < processArray.length; i += 2) {
      standardizedProcess.push(10);
      standardizedProcess.push(5);
    }
    processArray = standardizedProcess;
  }
  
  // í‘œì¤€í™”ëœ ì‹œí€€ìŠ¤ ê°ì²´ ìƒì„±
  const standardizedSeq: any = {
    ...sequence,
    operation_mode: operationMode,
    process: processArray
  };
  
  // wait_timeì€ operation_modeê°€ 22(ìˆœì°¨ ëª¨ë“œ)ê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì¶”ê°€
  if (operationMode === 22) {
    delete standardizedSeq.wait_time;
  }
  
  return standardizedSeq;
};

// debounce í•¨ìˆ˜ë¥¼ ê°œì„ í•˜ì—¬ cancel ë©”ì„œë“œ ì¶”ê°€
const debounce = (func: Function, wait: number) => {
  let timeout: NodeJS.Timeout | null = null;
  
  const debounced = (...args: any[]) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
  
  // cancel ë©”ì„œë“œ ì¶”ê°€
  (debounced as any).cancel = () => {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  
  return debounced;
};

const AutomationProcess: React.FC<AutomationProcessProps> = ({ 
  mqttClient, 
  savedSequences,
  onLockChange 
}) => {
  // ì¤‘ìš” ìƒíƒœ Ref
  const processingAction = useRef<boolean>(false);
  const pendingUpdates = useRef<PendingUpdate[]>([]);
  const prevStatus = useRef<AutomationStatus>('waiting');
  const initialStateLoaded = useRef<boolean>(false);

  // ì‹œê°„ ê´€ë ¨ ìƒíƒœ
  const [tempHours, setTempHours] = useState(0);
  const [tempMinutes, setTempMinutes] = useState(0);
  const [tempSeconds, setTempSeconds] = useState(0);

  const [status, setStatus] = useState<AutomationStatus>('waiting');
  const [selectedSequences, setSelectedSequences] = useState<SequenceWithStatus[]>([]);
  const [availableSequences, setAvailableSequences] = useState<string[]>([]);
  const [selectedSequenceName, setSelectedSequenceName] = useState<string>('');
  const [currentSequenceIndex, setCurrentSequenceIndex] = useState<number>(-1);
  const [logs, setLogs] = useState<{id: string; message: string; timestamp: number; type: string}[]>([]);
  const [logMessages, setLogMessages] = useState<string[]>([]);
  const [progress, setProgress] = useState<string>('ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.');
  const [queueItems, setQueueItems] = useState<QueueItem[]>([]);
  const [queueStatus, setQueueStatus] = useState<QueueStatus>({ 
    isProcessing: false, 
    count: 0 
  });
  const [waitingCountdowns, setWaitingCountdowns] = useState<{[key: number]: number}>({});
  const [showTimePopup, setShowTimePopup] = useState<number | null>(null);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [showLoadDialog, setShowLoadDialog] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [processName, setProcessName] = useState('');
  const [processDescription, setProcessDescription] = useState('');
  const [savedProcesses, setSavedProcesses] = useState<SavedProcess[]>([]);
  const [selectedProcessId, setSelectedProcessId] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const [alertOpen, setAlertOpen] = useState(false);
  const [manualCommand, setManualCommand] = useState('');
  const [showManualCommandDialog, setShowManualCommandDialog] = useState(false);
  const [countdownIntervals, setCountdownIntervals] = useState<{[key: string]: NodeJS.Timeout}>({});
  
  // ì¶”ê°€ ë³€ìˆ˜ ì •ì˜
  const [currentSequenceId, setCurrentSequenceId] = useState('');
  const [serverBusy, setServerBusy] = useState(false);
  const processingRef = useRef<boolean>(false);
  const countdownTimersRef = useRef<{[key: string]: NodeJS.Timeout}>({});
  
  // ìƒíƒœ ë³€ê²½ ìµœì í™” í•¨ìˆ˜
  const safeUpdateState = <T extends unknown>(
    stateSetter: React.Dispatch<React.SetStateAction<T>>,
    value: T | ((prev: T) => T),
    stateType: string
  ) => {
    if (processingAction.current) {
      // ì²˜ë¦¬ ì¤‘ì¼ ë•ŒëŠ” ì—…ë°ì´íŠ¸ë¥¼ ëŒ€ê¸°ì—´ì— ë„£ìŒ
      pendingUpdates.current.push({ type: stateType, data: value });
      return;
    }
    
    stateSetter(value);
  };
  
  // ëŒ€ê¸° ì¤‘ì¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
  const processPendingUpdates = useCallback(() => {
    if (pendingUpdates.current.length === 0) return;
    
    processingAction.current = true;
    
    // ê° ì—…ë°ì´íŠ¸ ìœ í˜•ë³„ë¡œ ë§ˆì§€ë§‰ í•­ëª©ë§Œ ì ìš©
    const uniqueUpdates = pendingUpdates.current.reduce((acc, update) => {
      acc[update.type] = update.data;
      return acc;
    }, {} as Record<string, any>);
    
    // ì—…ë°ì´íŠ¸ ì ìš©
    Object.entries(uniqueUpdates).forEach(([type, data]) => {
      switch (type) {
        case 'status':
          setStatus(typeof data === 'function' ? data(status) : data);
          break;
        case 'selectedSequences':
          setSelectedSequences(typeof data === 'function' ? data(selectedSequences) : data);
          break;
        case 'currentSequenceIndex':
          setCurrentSequenceIndex(typeof data === 'function' ? data(currentSequenceIndex) : data);
          break;
        case 'logs':
          setLogs(typeof data === 'function' ? data(logs) : data);
          break;
        case 'queueItems':
          setQueueItems(typeof data === 'function' ? data(queueItems) : data);
          break;
        case 'queueStatus':
          setQueueStatus(typeof data === 'function' ? data(queueStatus) : data);
          break;
        default:
          break;
      }
    });
    
    pendingUpdates.current = [];
    processingAction.current = false;
  }, [status, selectedSequences, currentSequenceIndex, logs, queueItems, queueStatus]);
  
  // ì£¼ê¸°ì ìœ¼ë¡œ ëŒ€ê¸° ì¤‘ì¸ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
  useEffect(() => {
    const interval = setInterval(() => {
      if (!processingAction.current && pendingUpdates.current.length > 0) {
        processPendingUpdates();
      }
    }, 50); // 50ms ê°„ê²©ìœ¼ë¡œ í™•ì¸
    
    return () => clearInterval(interval);
  }, [processPendingUpdates]);

  // ìƒíƒœ ë³€ê²½ ì‹œ ì²˜ë¦¬ ìµœì í™”
  useEffect(() => {
    if (prevStatus.current !== status) {
      prevStatus.current = status;
      
      // ìƒíƒœ ë³€ê²½ ì‹œ ìë™í™” ê³µì • ì ê¸ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
      if (onLockChange) {
        onLockChange(status === 'running' || status === 'paused');
      }
      
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìƒíƒœ ì €ì¥
      if (typeof window !== 'undefined') {
        try {
          localStorage.setItem(AUTOMATION_STATE_KEY, JSON.stringify({
            status,
            currentSequenceIndex,
            selectedSequences
          }));
        } catch (error) {
          console.error('ìƒíƒœ ì €ì¥ ì¤‘ ì˜¤ë¥˜:', error);
        }
      }
    }
  }, [status, currentSequenceIndex, selectedSequences, onLockChange]);

  // MQTT ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ìµœì í™” - ë””ë°”ìš´ìŠ¤ ì ìš©
  const debouncedHandleMessage = useCallback(
    debounce((topic: string, message: Buffer) => {
      try {
        // ê¸°ì¡´ handleMessage ì½”ë“œ ë‚´ìš© ìœ ì§€
        // ...
      } catch (error) {
        console.error('MQTT ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
      }
    }, 50), // 50ms ë””ë°”ìš´ìŠ¤
    []
  );

  // updateSequenceStatus ìµœì í™”
  const updateSequenceStatus = (index: number, newStatus: SequenceStatus) => {
    if (index < 0 || index >= selectedSequences.length) return;
    
    processingAction.current = true;
    setSelectedSequences(prev => {
      const updated = [...prev];
      updated[index] = {
        ...updated[index],
        status: newStatus,
        ...(newStatus === 'running' && { startTime: Date.now() }),
        ...(newStatus === 'completed' && { endTime: Date.now() })
      };
      return updated;
    });
    processingAction.current = false;
  };

  // addSequence ìµœì í™”
  const addSequence = (sequenceName: string) => {
    const sequence = savedSequences.find(seq => seq.name === sequenceName);
    if (!sequence) return;
    
    processingAction.current = true;
    setSelectedSequences(prev => [
      ...prev,
      {
        id: uuidv4(),
        sequence,
        status: 'waiting',
        waitTime: 0,
        customRepeats: sequence.repeats || 1
      }
    ]);
    processingAction.current = false;
  };

  // fullReset í•¨ìˆ˜ ìµœì í™”
  const fullResetOptimized = () => {
    // ì—¬ëŸ¬ ìƒíƒœ ë³€ê²½ ì‘ì—… ì „ì— ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ ì„¤ì •
    processingAction.current = true;
    
    // ì‹¤í–‰ ì¤‘ì¸ ì¹´ìš´íŠ¸ë‹¤ìš´ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ëª¨ë‘ ì •ë¦¬
    Object.values(countdownIntervals).forEach(interval => {
      clearInterval(interval);
    });
    
    // ìƒíƒœ ì´ˆê¸°í™”
    setStatus('waiting');
    setSelectedSequences([]);
    setCurrentSequenceIndex(-1);
    setLogs([]);
    setWaitingCountdowns({});
    setShowTimePopup(null);
    setTempHours(0);
    setTempMinutes(0);
    setTempSeconds(0);
    setCountdownIntervals({});
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°ì´í„° ì‚­ì œ
    if (typeof window !== 'undefined') {
      try {
        localStorage.removeItem(AUTOMATION_STATE_KEY);
        localStorage.removeItem(AUTOMATION_SEQUENCES_KEY);
      } catch (error) {
        console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°ì´í„° ì‚­ì œ ì¤‘ ì˜¤ë¥˜:', error);
      }
    }
    
    // í ìƒíƒœ ì´ˆê¸°í™”
    if (mqttClient) {
      try {
        // í ì´ˆê¸°í™” ë©”ì‹œì§€ ë°œí–‰
        mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
          action: 'clear_all'
        }));
      } catch (error) {
        console.error('MQTT ë©”ì‹œì§€ ë°œí–‰ ì¤‘ ì˜¤ë¥˜:', error);
      }
    }
    
    // ì²˜ë¦¬ ì™„ë£Œ
    processingAction.current = false;
    
    // ì´ˆê¸°í™” ì™„ë£Œ ì•Œë¦¼
    toast({
      title: "ì´ˆê¸°í™” ì™„ë£Œ",
      description: "ëª¨ë“  ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.",
    });
  };
  
  // ì‹œí€€ìŠ¤ ì¶”ê°€/ì‚­ì œ ìµœì í™” - ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì €ì¥ ë””ë°”ìš´ìŠ¤
  const debouncedSaveSequences = useCallback(
    debounce((sequences: SequenceWithStatus[]) => {
      if (typeof window !== 'undefined') {
        try {
          localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify(sequences));
        } catch (error) {
          console.error('ì‹œí€€ìŠ¤ ì €ì¥ ì¤‘ ì˜¤ë¥˜:', error);
        }
      }
    }, 300), // 300ms ë””ë°”ìš´ìŠ¤
    []
  );
  
  // ì„ íƒëœ ì‹œí€€ìŠ¤ ë³€ê²½ ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì—…ë°ì´íŠ¸
  useEffect(() => {
    debouncedSaveSequences(selectedSequences);
  }, [selectedSequences, debouncedSaveSequences]);
  
  useEffect(() => {
    if (!mqttClient) return;
    
    const handleMessage = (topic: string, message: Buffer) => {
      try {
        const messageStr = message.toString();
        
        // í•„ìˆ˜ í† í”½ë§Œ ë¡œê·¸ì— ì¶œë ¥
        if (topic === EXTRACTION_INPUT_TOPIC) {
          console.log(`ğŸ“¤ [INPUT] ${messageStr.substring(0, 100)}...`);
        } 
        else if (topic === EXTRACTION_OUTPUT_TOPIC) {
          console.log(`ğŸ“¥ [OUTPUT] ${messageStr}`);
          // ë¡œê·¸ ê°ì²´ ì¶”ê°€
          const newLog = {
            id: `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
            message: `OUTPUT: ${messageStr}`,
            timestamp: Date.now(),
            type: 'info' as const
          };
          setLogs(prevLogs => [...prevLogs, newLog].slice(-100));
          
          // í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ì²˜ë¦¬
          addLog(`ìƒíƒœ ë©”ì‹œì§€ ìˆ˜ì‹ : ${messageStr}`, true);
            
          // ê³µì • ì¢…ë£Œ ë©”ì‹œì§€ ê°ì§€
          const isCompletionMessage = messageStr.toLowerCase().includes('ê³µì • ì¢…ë£Œ') || 
                                    messageStr.toLowerCase().includes('ê³µì •ì¢…ë£Œ') ||
                                    messageStr.includes('ë””ë°”ì´ìŠ¤ ì¬ë¶€íŒ… ì‹œì‘');
          
          if (isCompletionMessage) {
            console.log(`ğŸš¨ ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€! [${messageStr}]`);
            
            // í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ì—ë§Œ ì™„ë£Œ ì²˜ë¦¬ ì ìš©
            if (status === 'running' && currentSequenceIndex >= 0) {
              // í˜„ì¬ ì‹œí€€ìŠ¤ì˜ ìƒíƒœê°€ 'running'ì¸ ê²½ìš°ì—ë§Œ ì™„ë£Œ ì²˜ë¦¬ ìˆ˜í–‰
              const currentSeq = selectedSequences[currentSequenceIndex];
              if (currentSeq && currentSeq.status === 'running') {
                addLog(`ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1} ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€: ${currentSeq.sequence.name}`, true);
                // ì‹œí€€ìŠ¤ ì™„ë£Œ ì²˜ë¦¬
                handleSequenceCompletion(currentSequenceIndex, 'completed', 'ê³µì • ì¢…ë£Œ ë©”ì‹œì§€ ê°ì§€');
              } else {
                // ì´ë¯¸ ì™„ë£Œë˜ì—ˆê±°ë‚˜ ì—ëŸ¬ ìƒíƒœì¸ ê²½ìš° ë¡œê·¸ë§Œ ë‚¨ê¹€
                if (currentSeq) {
                  addLog(`ì™„ë£Œ ë©”ì‹œì§€ê°€ ê°ì§€ë˜ì—ˆìœ¼ë‚˜ ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1}ëŠ” ì´ë¯¸ ${currentSeq.status} ìƒíƒœì…ë‹ˆë‹¤.`, true);
                }
              }
            } else {
              addLog(`ì™„ë£Œ ë©”ì‹œì§€ê°€ ê°ì§€ë˜ì—ˆìœ¼ë‚˜ ì‹¤í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.`, false);
            }
          }
        }
        else if (topic === PROCESS_PROGRESS_TOPIC) {
          console.log(`ğŸ“Š [PROGRESS] ${messageStr}`);
          
          // ë©”ì‹œì§€ í¬ê¸° ì œí•œ ì²˜ë¦¬ (10000ì ì´ìƒì¸ ê²½ìš° ì¶•ì•½)
          let displayMessage = messageStr;
          if (displayMessage && displayMessage.length > 10000) {
            console.warn(`ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤: ${displayMessage.length} ë°”ì´íŠ¸. ì˜ë¼ëƒ…ë‹ˆë‹¤.`);
            displayMessage = displayMessage.substring(0, 10000) + "... (ë©”ì‹œì§€ í¬ê¸° ì´ˆê³¼ë¡œ ì˜ë¦¼)`);
          }
          
          // ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ ì €ì¥
          setProgress(displayMessage);
          
          // ë¡œê·¸ ê°ì²´ ì¶”ê°€
          const newLog = {
            id: `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
            message: `PROGRESS: ${displayMessage.substring(0, 100)}${displayMessage.length > 100 ? '...' : ''}`,
            timestamp: Date.now(),
            type: 'info' as const
          };
          setLogs(prevLogs => [...prevLogs, newLog].slice(-100));
          
          // ë¡œê·¸ ë©”ì‹œì§€ ì¶”ê°€ (ë¬¸ìì—´ ë°°ì—´)
          const logMsg = `[${new Date().toLocaleTimeString()}] ì§„í–‰ ìƒíƒœ: ${displayMessage.substring(0, 50)}${displayMessage.length > 50 ? '...' : ''}`;
          setLogMessages(prev => [logMsg, ...prev].slice(0, 100));
          
          // ì§„í–‰ ìƒíƒœ ë°ì´í„° íŒŒì‹± ë° ì²˜ë¦¬ ì‹œë„
          try {
            const data = JSON.parse(messageStr);
            
            // ì§„í–‰ ìƒíƒœ ì •ë³´ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ì—¬ progress ìƒíƒœì— ì €ì¥
              setProgress(JSON.stringify(data, null, 2));
              
              // ì§„í–‰ ìƒíƒœê°€ í¬í•¨ëœ ë©”ì‹œì§€ì¸ ê²½ìš° ì²˜ë¦¬
              if (data && status === 'running' && currentSequenceIndex >= 0) {
                const currentSeq = selectedSequences[currentSequenceIndex];
                
                // ì™„ë£Œ ìƒíƒœ ê°ì§€
                if (data.status === 'completed' && currentSeq && currentSeq.status === 'running') {
                  handleSequenceCompletion(currentSequenceIndex, 'completed', 'ì§„í–‰ ìƒíƒœ ì™„ë£Œ ê°ì§€');
                }
                // ì˜¤ë¥˜ ìƒíƒœ ê°ì§€
                else if (data.status === 'error' && currentSeq && currentSeq.status === 'running') {
                  handleSequenceCompletion(currentSequenceIndex, 'error', `ì˜¤ë¥˜: ${data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
                }
                // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
                else if (data.progress && currentSeq) {
                  // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë¡œê·¸ë¶ì— ì§„í–‰ ìƒíƒœë§Œ ê¸°ë¡)
                  try {
                    workLogService.saveWorkLog({
                      id: `progress-${uuidv4()}`,
                      sequenceName: `[ìë™í™” ì§„í–‰] ${currentSeq.sequence.name}`,
                      startTime: new Date().toISOString(),
                      endTime: new Date().toISOString(),
                      status: 'running' as 'running' | 'completed' | 'error' | 'aborted' | 'warning',
                      details: JSON.stringify({
                        progress: data.progress,
                        currentStep: data.currentStep,
                        totalSteps: data.totalSteps,
                        sequenceName: currentSeq.sequence.name,
                        sequenceIndex: currentSequenceIndex
                      })
                    });
                  addLog(`ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸: ${data.progress}% (${data.currentStep || '?'}/${data.totalSteps || '?'})`, false);
                  } catch (logError) {
                    console.error('ì§„í–‰ ìƒíƒœ ë¡œê·¸ë¶ ê¸°ë¡ ì‹¤íŒ¨:', logError);
                }
              }
            }
          } catch (parseError) {
            console.error('ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:', parseError);
            setProgress(`ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜: ${messageStr}`);
          }
        }
        else if (topic === QUEUE_STATUS_TOPIC) {
          try {
            const data = JSON.parse(messageStr);
            
            // ë°ì´í„° êµ¬ì¡° ìœ íš¨ì„± ê²€ì‚¬ ì¶”ê°€
            if (data) {
              const count = data.count !== undefined ? data.count : (data.items ? data.items.length : 0);
              setQueueStatus({
                isProcessing: data.isProcessing !== undefined ? data.isProcessing : false,
                count: count,
                items: Array.isArray(data.items) ? data.items : []
              });
              addLog(`í ìƒíƒœ ì—…ë°ì´íŠ¸: ${count}ê°œ í•­ëª©`);
            } else {
              addLog(`í ìƒíƒœ ë°ì´í„° ì—†ìŒ`, true);
            }
          } catch (error) {
            console.error('í ìƒíƒœ ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
            addLog(`í ìƒíƒœ íŒŒì‹± ì˜¤ë¥˜: ${error}`, true);
          }
        }
      } catch (error) {
        console.error('ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
      }
    };
    
    // ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ë“±ë¡
    mqttClient.on('message', handleMessage);
    
    // ì£¼ìš” í† í”½ êµ¬ë…
    mqttClient.subscribe(PROCESS_PROGRESS_TOPIC);
    mqttClient.subscribe(EXTRACTION_OUTPUT_TOPIC);
    mqttClient.subscribe(QUEUE_STATUS_TOPIC);
    
    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ í•¸ë“¤ëŸ¬ ì œê±°
    return () => {
      mqttClient.off('message', handleMessage);
      mqttClient.unsubscribe(PROCESS_PROGRESS_TOPIC);
      mqttClient.unsubscribe(EXTRACTION_OUTPUT_TOPIC);
      mqttClient.unsubscribe(QUEUE_STATUS_TOPIC);
      
      // ëª¨ë“  íƒ€ì„ì•„ì›ƒ ì •ë¦¬
      Object.values(countdownIntervals).forEach(timeoutId => {
        clearTimeout(timeoutId);
      });
    };
  }, [mqttClient, currentSequenceIndex, status, selectedSequences, countdownIntervals]);
  
  // ì‹œí€€ìŠ¤ ì œê±°
  const removeSequence = (index: number) => {
    setSelectedSequences(prev => {
      const updated = [...prev];
      updated.splice(index, 1);
      return updated;
    });
  };
  
  // ì‹œí€€ìŠ¤ ìœ„ë¡œ ì´ë™
  const moveSequenceUp = (index: number) => {
    if (index <= 0) return;
    
    setSelectedSequences(prev => {
      const updated = [...prev];
      const temp = updated[index];
      updated[index] = updated[index - 1];
      updated[index - 1] = temp;
      return updated;
    });
  };
  
  // ì‹œí€€ìŠ¤ ì•„ë˜ë¡œ ì´ë™
  const moveSequenceDown = (index: number) => {
    if (index >= selectedSequences.length - 1) return;
    
    setSelectedSequences(prev => {
      const updated = [...prev];
      const temp = updated[index];
      updated[index] = updated[index + 1];
      updated[index + 1] = temp;
      return updated;
    });
  };
  
  // ëŒ€ê¸° ì‹œê°„ ë³€ê²½
  const handleWaitTimeChange = (index: number, waitTime: number) => {
    setSelectedSequences(prev => {
      const updated = [...prev];
      updated[index] = {...updated[index], waitTime};
      return updated;
    });
  };
  
  // ë°˜ë³µ íšŸìˆ˜ ë³€ê²½
  const handleRepeatsChange = (index: number, repeats: number) => {
    setSelectedSequences(prev => {
      const updated = [...prev];
      updated[index] = {...updated[index], customRepeats: repeats};
      return updated;
    });
  };
  
  // ì‹œí€€ìŠ¤ ë³µì œ ê¸°ëŠ¥ ì¶”ê°€
  const duplicateSequence = (index: number) => {
    const sequenceToDuplicate = selectedSequences[index];
    setSelectedSequences(prev => [
      ...prev, 
      {
        id: uuidv4(),
        sequence: {...sequenceToDuplicate.sequence},
        status: 'waiting' as SequenceStatus,
        waitTime: sequenceToDuplicate.waitTime,
        customRepeats: sequenceToDuplicate.customRepeats
      }
    ]);
    addLog(`ì‹œí€€ìŠ¤ ë³µì œë¨: ${sequenceToDuplicate.sequence.name}`);
  };
  
  // ì‹œí€€ìŠ¤ ì™„ë£Œ ì²˜ë¦¬ í•¨ìˆ˜
  const handleSequenceCompletion = (index: number, newStatus: SequenceStatus, details?: string) => {
    // ì‹œí€€ìŠ¤ê°€ ìœ íš¨í•œì§€ í™•ì¸
    if (index < 0 || index >= selectedSequences.length) {
      console.error(`ìœ íš¨í•˜ì§€ ì•Šì€ ì‹œí€€ìŠ¤ ì¸ë±ìŠ¤: ${index}`);
      return;
    }
    
    try {
      // ì´ë¯¸ ì™„ë£Œëœ ì‹œí€€ìŠ¤ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
      const currentSeq = selectedSequences[index];
      if (currentSeq.status === 'completed' || currentSeq.status === 'error') {
        console.log(`ì‹œí€€ìŠ¤ ${index}(${currentSeq.sequence.name})ëŠ” ì´ë¯¸ ${currentSeq.status} ìƒíƒœì…ë‹ˆë‹¤.`);
        return;
      }
      
      // ì‹œí€€ìŠ¤ ì¢…ë£Œ ì‹œê°„ ì—…ë°ì´íŠ¸
      const endTime = new Date();
      setSelectedSequences(prev => {
        const updated = [...prev];
        updated[index] = {
          ...updated[index], 
          status: newStatus, 
          endTime: endTime.getTime(),
          errorDetails: newStatus === 'error' ? details : undefined
        };
        return updated;
      });
      
      // ë¡œê·¸ ì¶”ê°€
      const statusText = newStatus === 'completed' ? 'ì™„ë£Œ' : newStatus === 'error' ? 'ì˜¤ë¥˜' : 'ìƒíƒœ ë³€ê²½';
      addLog(`ì‹œí€€ìŠ¤ ${index + 1} ${statusText}: ${currentSeq.sequence.name}${details ? ` (${details})` : ''}`, true);
      
      // ì‘ì—… ë¡œê·¸ë¶ì— ìƒíƒœ ì—…ë°ì´íŠ¸
      try {
        const sequenceId = currentSeq.id;
        let logStatus: 'running' | 'completed' | 'error' | 'aborted' | 'warning' = 'completed';
        
        // ìƒíƒœì— ë”°ë¥¸ ì‘ì—… ë¡œê·¸ ìƒíƒœ ì„¤ì •
        if (newStatus === 'error') {
          logStatus = 'error';
        } else if (newStatus === 'completed') {
          logStatus = 'completed';
        }
        
        // ì‹œì‘ ì‹œê°„ì´ ì—†ëŠ” ê²½ìš°ì—ëŠ” í˜„ì¬ ì‹œê°„ ê¸°ì¤€ 30ì´ˆ ì „ìœ¼ë¡œ ì„¤ì • (ê¸°ë³¸ê°’)
        const startTimeMs = currentSeq.startTime || (endTime.getTime() - 30000);
        const durationSeconds = Math.round((endTime.getTime() - startTimeMs) / 1000);
        
        // ì‘ì—… ë¡œê·¸ë¶ì— ì™„ë£Œ ê¸°ë¡
        workLogService.saveWorkLog({
          id: sequenceId, // ì‹œí€€ìŠ¤ IDë¥¼ ì‘ì—… ë¡œê·¸ IDë¡œ ì‚¬ìš©
          sequenceName: `[ìë™í™”] ${currentSeq.sequence.name}`,
          startTime: new Date(startTimeMs).toISOString(),
          endTime: endTime.toISOString(),
          status: logStatus,
          details: JSON.stringify({
            mode: currentSeq.sequence.operation_mode,
            repeats: currentSeq.customRepeats,
            process: currentSeq.sequence.process,
            waitTime: currentSeq.waitTime,
            sequenceIndex: index,
            totalSequences: selectedSequences.length,
            completionDetails: details || 'ì •ìƒ ì™„ë£Œ',
            duration: durationSeconds
          })
        });
        
        console.log(`ì‹œí€€ìŠ¤ ${statusText} ì‘ì—… ë¡œê·¸ë¶ ê¸°ë¡ ì™„ë£Œ: ${currentSeq.sequence.name}, ì†Œìš”ì‹œê°„: ${durationSeconds}ì´ˆ`);
      } catch (logError) {
        console.error('ì‘ì—… ë¡œê·¸ë¶ ê¸°ë¡ ì‹¤íŒ¨:', logError);
      }
      
      // ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰ ì—¬ë¶€ ê²°ì •
      if (newStatus === 'completed' && index === currentSequenceIndex) {
        const nextIndex = index + 1;
        
        // ë‹¤ìŒ ì‹œí€€ìŠ¤ê°€ ìˆëŠ”ì§€ í™•ì¸
        if (nextIndex < selectedSequences.length) {
          console.log(`ë‹¤ìŒ ì‹œí€€ìŠ¤ ${nextIndex} ì‹¤í–‰ ì¤€ë¹„`);
          const nextSeq = selectedSequences[nextIndex];
          
          // ëŒ€ê¸° ì‹œê°„ì´ ìˆìœ¼ë©´ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
          if (nextSeq.waitTime > 0) {
            addLog(`ë‹¤ìŒ ì‹œí€€ìŠ¤ ${nextSeq.waitTime}ì´ˆ í›„ ì‹œì‘: ${nextSeq.sequence.name}`);
            startCountdown(nextIndex, nextSeq.waitTime);
            
            const timeoutId = setTimeout(() => {
              clearCountdown(nextIndex);
              executeSequence(nextIndex);
            }, nextSeq.waitTime * 1000);
            
            // íƒ€ì„ì•„ì›ƒ ID ì €ì¥
            setCountdownIntervals(prev => ({
              ...prev,
              [nextIndex]: timeoutId
            }));
          } else {
            // ëŒ€ê¸° ì‹œê°„ì´ ì—†ìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰
            executeSequence(nextIndex);
          }
        } else {
          // ëª¨ë“  ì‹œí€€ìŠ¤ ì™„ë£Œ
          setStatus('completed');
          setCurrentSequenceIndex(-1);
          addLog("ëª¨ë“  ì‹œí€€ìŠ¤ ì²˜ë¦¬ ì™„ë£Œ", true);
          
          // ì „ì²´ ìë™í™” ê³µì • ì™„ë£Œ ì‹œê°„ ê³„ì‚°
          const automationEndTime = new Date();
          const firstSeq = selectedSequences[0];
          const automationStartTime = firstSeq.startTime ? new Date(firstSeq.startTime) : new Date(automationEndTime.getTime() - 60000);
          const totalDurationSeconds = Math.round((automationEndTime.getTime() - automationStartTime.getTime()) / 1000);
          
          // ì‘ì—… ë¡œê·¸ë¶ì— ì™„ë£Œ ê¸°ë¡
          try {
            workLogService.saveWorkLog({
              id: uuidv4(),
              sequenceName: `[ìë™í™”] ëª¨ë“  ì‹œí€€ìŠ¤ ì²˜ë¦¬ ì™„ë£Œ`,
              startTime: automationStartTime.toISOString(),
              endTime: automationEndTime.toISOString(),
              status: 'completed' as 'running' | 'completed' | 'error' | 'aborted' | 'warning',
              details: JSON.stringify({
                totalSequences: selectedSequences.length,
                totalDuration: totalDurationSeconds,
                sequences: selectedSequences.map(seq => ({
                  name: seq.sequence.name,
                  status: seq.status,
                  duration: seq.startTime && seq.endTime ? Math.round((seq.endTime - seq.startTime) / 1000) : undefined
                }))
              })
            });
            
            console.log(`ìë™í™” ê³µì • ì™„ë£Œ ê¸°ë¡ ì €ì¥ ì™„ë£Œ. ì´ ì†Œìš”ì‹œê°„: ${totalDurationSeconds}ì´ˆ`);
          } catch (logError) {
            console.error('ìë™í™” ê³µì • ì™„ë£Œ ë¡œê·¸ ê¸°ë¡ ì‹¤íŒ¨:', logError);
          }
          
          toast({
            title: "ìë™í™” ê³µì • ì™„ë£Œ",
            description: `ëª¨ë“  ì‹œí€€ìŠ¤(${selectedSequences.length}ê°œ)ê°€ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.`,
          });
          
          // ê³µì • ì™„ë£Œ 3ì´ˆ í›„ ìë™ ì´ˆê¸°í™”
          setTimeout(() => {
            enhancedResetAutomation();
            addLog("ìë™í™” ê³µì •ì´ ì™„ë£Œë˜ì–´ ìë™ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ê³µì •ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
          }, 3000);
        }
      } else if (newStatus === 'error' && index === currentSequenceIndex) {
        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ìë™í™” ê³µì • ì¤‘ë‹¨ ì—¬ë¶€ ê²°ì • (í˜„ì¬ëŠ” ê³„ì† ì§„í–‰)
        const nextIndex = index + 1;
        
        // ë‹¤ìŒ ì‹œí€€ìŠ¤ê°€ ìˆìœ¼ë©´ ê³„ì† ì§„í–‰
        if (nextIndex < selectedSequences.length) {
          console.log(`ì˜¤ë¥˜ ë°œìƒ í›„ ë‹¤ìŒ ì‹œí€€ìŠ¤ ${nextIndex} ì‹¤í–‰ ì¤€ë¹„`);
          
          // ì˜¤ë¥˜ ì•Œë¦¼
          toast({
            title: "ì‹œí€€ìŠ¤ ì˜¤ë¥˜",
            description: `ì‹œí€€ìŠ¤ ${index + 1}(${currentSeq.sequence.name})ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì‹œí€€ìŠ¤ë¡œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.`,
            variant: "destructive"
          });
          
          // ì‘ì—… ë¡œê·¸ë¶ì— ì˜¤ë¥˜ ë°œìƒ í›„ ê³„ì† ì§„í–‰ ê¸°ë¡
          try {
            workLogService.saveWorkLog({
              id: uuidv4(),
              sequenceName: `[ìë™í™”] ì˜¤ë¥˜ ë°œìƒ í›„ ê³„ì† ì§„í–‰`,
              startTime: new Date().toISOString(),
              endTime: new Date().toISOString(),
              status: 'warning' as 'running' | 'completed' | 'error' | 'aborted' | 'warning',
              details: JSON.stringify({
                errorSequence: currentSeq.sequence.name,
                errorSequenceIndex: index,
                errorDetails: details || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜',
                nextSequence: selectedSequences[nextIndex].sequence.name,
                nextSequenceIndex: nextIndex,
                totalSequences: selectedSequences.length
              })
            });
          } catch (logError) {
            console.error('ì˜¤ë¥˜ í›„ ê³„ì† ì§„í–‰ ë¡œê·¸ ê¸°ë¡ ì‹¤íŒ¨:', logError);
          }
          
          // ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰
          executeSequence(nextIndex);
        } else {
          // ë§ˆì§€ë§‰ ì‹œí€€ìŠ¤ì—ì„œ ì˜¤ë¥˜ ë°œìƒ ì‹œ ìë™í™” ê³µì • ì™„ë£Œ ì²˜ë¦¬
          setStatus('error');
          setCurrentSequenceIndex(-1);
          addLog("ìë™í™” ê³µì • ì˜¤ë¥˜ë¡œ ì¸í•´ ì¤‘ë‹¨ë¨", true);
          
          // ì „ì²´ ìë™í™” ê³µì • ì‹œê°„ ê³„ì‚°
          const automationEndTime = new Date();
          const firstSeq = selectedSequences[0];
          const automationStartTime = firstSeq.startTime ? new Date(firstSeq.startTime) : new Date(automationEndTime.getTime() - 60000);
          const totalDurationSeconds = Math.round((automationEndTime.getTime() - automationStartTime.getTime()) / 1000);
          
          // ì‘ì—… ë¡œê·¸ë¶ì— ì˜¤ë¥˜ë¡œ ì¸í•œ ì¤‘ë‹¨ ê¸°ë¡
          try {
            workLogService.saveWorkLog({
              id: uuidv4(),
              sequenceName: `[ìë™í™”] ì˜¤ë¥˜ë¡œ ì¸í•œ ì¤‘ë‹¨`,
              startTime: automationStartTime.toISOString(),
              endTime: automationEndTime.toISOString(),
              status: 'error' as 'running' | 'completed' | 'error' | 'aborted' | 'warning',
              details: JSON.stringify({
                totalSequences: selectedSequences.length,
                totalDuration: totalDurationSeconds,
                errorSequence: currentSeq.sequence.name,
                errorSequenceIndex: index,
                errorDetails: details || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜',
                sequences: selectedSequences.map(seq => ({
                  name: seq.sequence.name,
                  status: seq.status,
                  duration: seq.startTime && seq.endTime ? Math.round((seq.endTime - seq.startTime) / 1000) : undefined
                }))
              })
            });
          } catch (logError) {
            console.error('ìë™í™” ê³µì • ì˜¤ë¥˜ ì¤‘ë‹¨ ë¡œê·¸ ê¸°ë¡ ì‹¤íŒ¨:', logError);
          }
          
          toast({
            title: "ìë™í™” ê³µì • ì˜¤ë¥˜",
            description: `ì‹œí€€ìŠ¤ ${index + 1}(${currentSeq.sequence.name})ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì—¬ ìë™í™” ê³µì •ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.`,
            variant: "destructive"
          });
        }
      }
    } catch (error) {
      console.error("handleSequenceCompletion í•¨ìˆ˜ ì˜¤ë¥˜:", error);
      addLog(`ì‹œí€€ìŠ¤ ì™„ë£Œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ${error}`);
    }
  };
  
  // ì‹œí€€ìŠ¤ ì‹¤í–‰ í•¨ìˆ˜ ê°œì„ 
  const executeSequence = (index: number) => {
    try {
      console.log(`ì‹œí€€ìŠ¤ ${index + 1} ì‹¤í–‰ ì‹œì‘`);
      
      // ì‹œí€€ìŠ¤ê°€ ìœ íš¨í•œì§€ í™•ì¸
      if (index < 0 || index >= selectedSequences.length) {
        console.error("ìœ íš¨í•˜ì§€ ì•Šì€ ì‹œí€€ìŠ¤ ì¸ë±ìŠ¤:", index);
        return;
      }
    
    // í˜„ì¬ ì‹œí€€ìŠ¤ ì •ë³´
    const currentSeq = selectedSequences[index];
    const sequenceId = currentSeq.id;
    
    // ìƒíƒœ ì—…ë°ì´íŠ¸
    setCurrentSequenceIndex(index);
    
    // í˜„ì¬ ì‹œí€€ìŠ¤ë§Œ ì‹¤í–‰ ì¤‘ ìƒíƒœë¡œ ë³€ê²½ (ë‹¤ë¥¸ ì‹œí€€ìŠ¤ì˜ ìƒíƒœëŠ” ë³€ê²½í•˜ì§€ ì•ŠìŒ)
    setSelectedSequences(prev => {
        const updated = [...prev];
        updated[index] = {
          ...updated[index],
          status: 'running',
        startTime: Date.now()
      };
        return updated;
      });
      
      // ë¡œê·¸ ì¶”ê°€
      addLog(`ì‹œí€€ìŠ¤ ${index + 1} ì‹¤í–‰ ì¤‘: ${currentSeq.sequence.name}`, true);
      
      if (!mqttClient) {
        throw new Error("MQTT í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
      }
      
      try {
        // ì‹œí€€ìŠ¤ë¥¼ MQTT ë©”ì‹œì§€ë¡œ ë³€í™˜
        const standardizedSequence = standardizeSequenceJson(currentSeq.sequence);
        standardizedSequence.repeats = currentSeq.customRepeats; // ì‚¬ìš©ì ì§€ì • ë°˜ë³µ íšŸìˆ˜ ì ìš©
        
        // MQTT ë©”ì‹œì§€ ë°œí–‰
        const topic = EXTRACTION_INPUT_TOPIC;
        const message = JSON.stringify({
          sequences: [standardizedSequence]
        }, null, 2);
        
        console.log(`ì‹œí€€ìŠ¤ ë°œí–‰: ${topic}`, message);
        mqttClient.publish(topic, message);
        
        // ìµœëŒ€ ì‹¤í–‰ ì‹œê°„ ê³„ì‚° (ê¸°ë³¸ê°’: 5ë¶„)
        const estimatedDuration = calculateExpectedDuration(currentSeq.sequence);
        const maxExecutionTime = Math.max(estimatedDuration * 2, 300) * 1000; // ì˜ˆìƒ ì‹œê°„ì˜ 2ë°° ë˜ëŠ” ìµœì†Œ 5ë¶„
        
        // ì‹œí€€ìŠ¤ ì‹¤í–‰ ëª¨ë‹ˆí„°ë§ (íƒ€ì„ì•„ì›ƒ)
        const timeoutId = setTimeout(() => {
        // ì—¬ì „íˆ ì‹¤í–‰ ì¤‘ì¸ ìƒíƒœì¸ì§€ í™•ì¸
        const currentSeqState = selectedSequences.find(s => s.id === sequenceId);
        if (currentSeqState && currentSeqState.status === 'running') {
            // ì•„ì§ ì™„ë£Œë˜ì§€ ì•Šì•˜ë‹¤ë©´ íƒ€ì„ì•„ì›ƒìœ¼ë¡œ ê°„ì£¼í•˜ê³  ì—ëŸ¬ ì²˜ë¦¬
            const errorMsg = `ì‹œí€€ìŠ¤ ${index + 1} (${currentSeq.sequence.name}) ì‹¤í–‰ ì‹œê°„ ì´ˆê³¼: ${maxExecutionTime/1000}ì´ˆ`;
            console.error(errorMsg);
            addLog(errorMsg, true);
            
            // í•´ë‹¹ ì‹œí€€ìŠ¤ë¥¼ ì—ëŸ¬ ìƒíƒœë¡œ ë³€ê²½í•˜ê³  ë‹¤ìŒ ì‹œí€€ìŠ¤ ì§„í–‰
            updateSequenceStatus(index, 'error');
            
            // ë‹¤ìŒ ì‹œí€€ìŠ¤ ì§„í–‰ ë˜ëŠ” ì™„ë£Œ ì²˜ë¦¬
            const nextIndex = index + 1;
            if (nextIndex < selectedSequences.length) {
              // ë‹¤ìŒ ì‹œí€€ìŠ¤ê°€ ìˆìœ¼ë©´ ì‹¤í–‰
              executeNextSequence(nextIndex);
            } else {
              // ë§ˆì§€ë§‰ ì‹œí€€ìŠ¤ì˜€ìœ¼ë©´ ì™„ë£Œ ì²˜ë¦¬
              setStatus('completed');
              setCurrentSequenceIndex(-1);
              addLog("ëª¨ë“  ì‹œí€€ìŠ¤ ì²˜ë¦¬ ì™„ë£Œ (ì¼ë¶€ ì˜¤ë¥˜ ë°œìƒ)", true);
            }
          }
        }, maxExecutionTime);
        
        // íƒ€ì„ì•„ì›ƒ ID ì €ì¥
        setCountdownIntervals(prev => ({
          ...prev,
          [`timeout_${sequenceId}`]: timeoutId
        }));
        
        return true;
    } catch (e) {
        console.error("ì‹œí€€ìŠ¤ ì‹¤í–‰ ì˜¤ë¥˜:", e);
      addLog(`ì‹œí€€ìŠ¤ ì‹¤í–‰ ì˜¤ë¥˜: ${e}`, true);
        updateSequenceStatus(index, 'error');
        
        // ë‹¤ìŒ ì‹œí€€ìŠ¤ ì§„í–‰ ì‹œë„
        const nextIndex = index + 1;
        if (nextIndex < selectedSequences.length) {
          executeNextSequence(nextIndex);
        } else {
          setStatus('error');
          setCurrentSequenceIndex(-1);
        }
        
        return false;
      }
    } catch (error) {
      console.error("executeSequence í•¨ìˆ˜ ì˜¤ë¥˜:", error);
      toast({
        title: "ì˜¤ë¥˜ ë°œìƒ",
        description: `ì‹œí€€ìŠ¤ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`,
        variant: "destructive"
      });
      return false;
    }
  };

  // ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰ í•¨ìˆ˜ ì¶”ê°€
  const executeNextSequence = (nextIndex: number) => {
    if (nextIndex >= selectedSequences.length) {
      // ë” ì´ìƒ ì‹¤í–‰í•  ì‹œí€€ìŠ¤ê°€ ì—†ìœ¼ë©´ ì™„ë£Œ ì²˜ë¦¬
      setStatus('completed');
      setCurrentSequenceIndex(-1);
      addLog("ëª¨ë“  ì‹œí€€ìŠ¤ ì²˜ë¦¬ ì™„ë£Œ", true);
      return;
    }
    
    const nextSequence = selectedSequences[nextIndex];
    
    // ëŒ€ê¸° ì‹œê°„ì´ ìˆìœ¼ë©´ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
    if (nextSequence.waitTime > 0) {
      addLog(`ë‹¤ìŒ ì‹œí€€ìŠ¤ ${nextSequence.waitTime}ì´ˆ í›„ ì‹œì‘: ${nextSequence.sequence.name}`, true);
      
      // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
      startCountdown(nextIndex, nextSequence.waitTime);
      
      // ëŒ€ê¸° ì‹œê°„ í›„ ì‹œí€€ìŠ¤ ì‹¤í–‰
      const timeoutId = setTimeout(() => {
        // ì¹´ìš´íŠ¸ë‹¤ìš´ ì •ë¦¬
        clearCountdown(nextIndex);
        // ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰
        executeSequence(nextIndex);
      }, nextSequence.waitTime * 1000);
      
      // íƒ€ì„ì•„ì›ƒ ID ì €ì¥
      setCountdownIntervals(prev => ({
        ...prev,
        [nextIndex]: timeoutId
      }));
    } else {
      // ëŒ€ê¸° ì‹œê°„ì´ ì—†ìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰
      executeSequence(nextIndex);
    }
  };
  
  // ìë™í™” ê³µì • ë¦¬ì…‹ í•¨ìˆ˜ ìˆ˜ì •
  
  // ë¡œê·¸ ì¶”ê°€ í•¨ìˆ˜ ìˆ˜ì •
  const addLog = (message: string, includeSequenceInfo: boolean = false) => {
    let logMessage = message;
    
    // ì‹œí€€ìŠ¤ ì •ë³´ í¬í•¨ ì˜µì…˜ì´ ì¼œì ¸ ìˆê³  í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ê°€ ìˆëŠ” ê²½ìš°
    if (includeSequenceInfo && currentSequenceIndex >= 0 && currentSequenceIndex < selectedSequences.length) {
      const currentSeq = selectedSequences[currentSequenceIndex];
      logMessage = `[ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1}/${selectedSequences.length} - ${currentSeq.sequence.name}] ${message}`;
    }
    
    setLogMessages(prev => {
      const newLogs = [logMessage, ...prev].slice(0, 15);
      return newLogs;
    });
    
    // ë¡œê·¸ ì¶”ê°€ í›„ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìë™ ì €ì¥
    if (status === 'running' || status === 'paused') {
      setTimeout(saveStateToLocalStorage, 100);
    }
  };
  
  // ì»´í¬ë„ŒíŠ¸ì— ì„ íƒëœ ì‹œí€€ìŠ¤ ì´ë¦„ ìƒíƒœ ì¶”ê°€ (useState ì„ ì–¸ë¶€ ê·¼ì²˜ì— ì¶”ê°€)
  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ì €ì¥ëœ, ìë™í™” ê³µì • ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
  useEffect(() => {
    const fetchSavedProcesses = async () => {
      try {
        setIsLoading(true);
        
        // ì„œë²„ì—ì„œ ì €ì¥ëœ ìë™í™” ê³µì • ëª©ë¡ ì¡°íšŒ
        const processResponse = await fetch('/api/automation/processes');
        
        if (processResponse.ok) {
          const processData = await processResponse.json();
          console.log('ìë™í™” ê³µì • ë°ì´í„° ì‘ë‹µ:', processData);
          
          // ì‹œí€€ìŠ¤ ë°ì´í„°ë„ í•¨ê»˜ ì¡°íšŒ
          const sequenceResponse = await fetch('/api/sequences');
          let sequenceData = { sequences: [] };
          
          if (sequenceResponse.ok) {
            sequenceData = await sequenceResponse.json();
            console.log('ì‹œí€€ìŠ¤ ë°ì´í„° ì‘ë‹µ:', sequenceData);
          } else {
            console.error('ì‹œí€€ìŠ¤ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', await sequenceResponse.text());
          }
          
          // processesê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©, ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ì‚¬ìš©
          let processesWithIds = [];
          if (processData.processes && Array.isArray(processData.processes)) {
            // ê° í”„ë¡œì„¸ìŠ¤ì˜ ì‹œí€€ìŠ¤ ë°°ì—´ì— IDê°€ ì—†ëŠ” ê²½ìš° ì¶”ê°€
            processesWithIds = processData.processes.map(process => {
              // ì‹œí€€ìŠ¤ì— ID ì¶”ê°€
              if (process.sequences && Array.isArray(process.sequences)) {
                const sequencesWithIds = process.sequences.map(sequence => {
                  return sequence.id ? sequence : { ...sequence, id: uuidv4() };
                });
                return { ...process, sequences: sequencesWithIds };
              }
              return process;
            });
          }
          
          // ì‹œí€€ìŠ¤ ë°ì´í„°ê°€ ìˆê³  í”„ë¡œì„¸ìŠ¤ ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš° ì‹œí€€ìŠ¤ë¡œ ì„ì‹œ í”„ë¡œì„¸ìŠ¤ ìƒì„±
          if (processesWithIds.length === 0 && sequenceData.sequences && sequenceData.sequences.length > 0) {
            console.log('ì‹œí€€ìŠ¤ ë°ì´í„°ì—ì„œ í”„ë¡œì„¸ìŠ¤ ìƒì„±');
            
            // IDê°€ ì—†ëŠ” ì‹œí€€ìŠ¤ì— ID ì¶”ê°€
            const sequencesWithIds = sequenceData.sequences.map(seq => {
              return seq.id ? seq : { ...seq, id: uuidv4() };
            });
            
            // ì‹œí€€ìŠ¤ë¥¼ SequenceWithStatus í˜•ì‹ìœ¼ë¡œ ë³€í™˜
            const sequencesWithStatus = sequencesWithIds.map(seq => ({
              id: seq.id,
              sequence: seq,
              status: 'waiting' as SequenceStatus,
              waitTime: 0,
              customRepeats: seq.repeats || 1
            }));
            
            // ì„ì‹œ í”„ë¡œì„¸ìŠ¤ ìƒì„±
            processesWithIds = [{
              id: uuidv4(),
              name: "ë¶ˆëŸ¬ì˜¨ ì‘ì—… ëª©ë¡",
              sequences: sequencesWithStatus,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString()
            }];
          }
          
          setSavedProcesses(processesWithIds);
        } else {
          console.error('ìë™í™” ê³µì • ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', await processResponse.text());
        }
      } catch (error) {
        console.error('ìë™í™” ê³µì • ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchSavedProcesses();
  }, []);
  
  // ìë™í™” ê³µì • ì €ì¥ í•¨ìˆ˜ ìˆ˜ì • - ê°™ì€ ì´ë¦„ ì‘ì—…ì€ ë³‘í•© ëŒ€ì‹  ë®ì–´ì“°ê¸°
  const saveProcess = async () => {
    if (!processName.trim()) {
      addLog('ê³µì • ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }
    
    if (selectedSequences.length === 0) {
      addLog('ì €ì¥í•  ì‹œí€€ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    
    try {
      setIsLoading(true);
      addLog(`ìë™í™” ê³µì • '${processName.trim()}' ì €ì¥ ì‹œì‘...`);
      
      // ì„ íƒëœ ì‹œí€€ìŠ¤ì—ì„œ PumpSequence ê°ì²´ë§Œ ì¶”ì¶œ
      const extractedSequences = selectedSequences.map(seq => seq.sequence);
      
      // ì €ì¥í•  ìë™í™” ê³µì • ë°ì´í„° ìƒì„± - íƒ€ì… ìºìŠ¤íŒ… ìˆ˜ì •
      const processData: Omit<SavedProcess, 'id' | 'createdAt' | 'updatedAt'> = {
        name: processName.trim(),
        description: processDescription.trim() || undefined,
        sequences: selectedSequences.map(seq => ({
          ...seq,
          status: 'waiting' as SequenceStatus,
          startTime: undefined,
          endTime: undefined,
          errorDetails: undefined
        }))
      };
      
      // ì‹œí€€ìŠ¤ ë°ì´í„°ë„ ë³„ë„ë¡œ ì €ì¥ (sequence API ì‚¬ìš©)
      try {
        console.log('ì‹œí€€ìŠ¤ ë°ì´í„° ì €ì¥ ì‹œì‘');
        const sequenceResponse = await fetch('/api/sequences', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ sequences: extractedSequences })
        });
        
        if (sequenceResponse.ok) {
          const sequenceData = await sequenceResponse.json();
          console.log('ì‹œí€€ìŠ¤ ì €ì¥ ì„±ê³µ:', sequenceData);
        } else {
          console.error('ì‹œí€€ìŠ¤ ì €ì¥ ì‹¤íŒ¨:', await sequenceResponse.text());
          addLog('ì‹œí€€ìŠ¤ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨');
        }
      } catch (seqError) {
        console.error('ì‹œí€€ìŠ¤ ì €ì¥ ì¤‘ ì˜¤ë¥˜:', seqError);
        addLog(`ì‹œí€€ìŠ¤ ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${seqError.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
      }

      // ê¸°ì¡´ ì €ì¥ëœ í”„ë¡œì„¸ìŠ¤ ë¶ˆëŸ¬ì˜¤ê¸°
      const processesResponse = await fetch('/api/automation/processes');
      let existingProcesses = [];
      
      if (processesResponse.ok) {
        const data = await processesResponse.json();
        if (data.processes && Array.isArray(data.processes)) {
          existingProcesses = data.processes;
        }
      }
      
      // ê°™ì€ ì´ë¦„ì˜ ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ID í™•ì¸ (ë®ì–´ì“°ê¸° ìœ„í•¨)
      const existingProcess = existingProcesses.find(p => p.name === processName.trim());
      const processId = existingProcess?.id || uuidv4();
      
      // ì €ì¥í•  ìµœì¢… í”„ë¡œì„¸ìŠ¤ ë°ì´í„°
      const finalProcessData = {
        ...processData,
        id: processId,
        updatedAt: new Date().toISOString(),
        createdAt: existingProcess?.createdAt || new Date().toISOString()
      };
      
      // ê°™ì€ ì´ë¦„ì˜ í”„ë¡œì„¸ìŠ¤ëŠ” ë®ì–´ì“°ê¸° ìœ„í•´ ë‚˜ë¨¸ì§€ í”„ë¡œì„¸ìŠ¤ë§Œ í•„í„°ë§
      const filteredProcesses = existingProcesses.filter(p => p.name !== processName.trim());
      
      // ìƒˆ ë°ì´í„° ì¶”ê°€í•˜ì—¬ ì €ì¥
      const dataToSave = {
        processes: [...filteredProcesses, finalProcessData]
      };
      
      console.log('ìë™í™” ê³µì • ì €ì¥ ì¤‘ - ë®ì–´ì“°ê¸° ëª¨ë“œ:', finalProcessData);
      
      // Redisì— ì €ì¥ ìš”ì²­
      const response = await fetch('/api/automation/processes', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(dataToSave)
      });
      
      if (response.ok) {
        const responseData = await response.json();
        console.log('ì €ì¥ ì„±ê³µ:', responseData);
        
        // ìƒˆë¡œìš´ ë°ì´í„°ë¡œ ì „ì²´ ëª©ë¡ ê°±ì‹ 
        setSavedProcesses(responseData.processes || []);
        addLog(`ìë™í™” ê³µì • '${processData.name}'ì´(ê°€) ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        
        // ì €ì¥ ì„±ê³µ UI ì—…ë°ì´íŠ¸
        setShowSaveDialog(false);
        setProcessName('');
        setProcessDescription('');
        
        // ì„±ê³µ ì•Œë¦¼
        toast({
          title: "ì €ì¥ ì„±ê³µ",
          description: `ìë™í™” ê³µì • '${processData.name}'ì´(ê°€) ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`,
        });
      } else {
        throw new Error(await response.text() || 'ì„œë²„ì— ìë™í™” ê³µì •ì„ ì €ì¥í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('ìë™í™” ê³µì • ì €ì¥ ì˜¤ë¥˜:', error);
      addLog(`ìë™í™” ê³µì • ì €ì¥ ì˜¤ë¥˜: ${error.message || error}`);
      
      // ì˜¤ë¥˜ ì•Œë¦¼ í‘œì‹œ
      toast({
        variant: "destructive",
        title: "ì €ì¥ ì‹¤íŒ¨",
        description: `ìë™í™” ê³µì •ì„ ì €ì¥í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ${error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`,
      });
    } finally {
      setIsLoading(false);
    }
  };

  // ìë™í™” ê³µì • ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜
  const loadProcess = async () => {
    if (!selectedProcessId) {
      addLog('ë¶ˆëŸ¬ì˜¬ ê³µì •ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
      return;
    }
    
    try {
      setIsLoading(true);
      
      // í˜„ì¬ ì„ íƒëœ ê³µì • ì°¾ê¸°
      const process = savedProcesses.find(p => p.id === selectedProcessId);
      if (!process) {
        throw new Error('ì„ íƒí•œ ê³µì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      // í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ê³µì •ì´ ìˆë‹¤ë©´ í™•ì¸
      if (status === 'running') {
        addLog('ì‹¤í–‰ ì¤‘ì¸ ê³µì •ì´ ìˆìŠµë‹ˆë‹¤. ë¨¼ì € ë¦¬ì…‹í•´ì£¼ì„¸ìš”.');
        setShowLoadDialog(false);
        return;
      }
      
      // í˜„ì¬ ìƒíƒœ ì´ˆê¸°í™” í›„ ê³µì • ë¶ˆëŸ¬ì˜¤ê¸°
      fullResetPriority();
      
      // IDê°€ ì—†ëŠ” ì‹œí€€ìŠ¤ì— ID ì¶”ê°€
      const processedSequences = process.sequences.map(seq => ({
        ...seq,
        id: seq.id || uuidv4(),
        status: 'waiting' as SequenceStatus,
        startTime: undefined,
        endTime: undefined,
        errorDetails: undefined
      }));
      
      setSelectedSequences(processedSequences);
      setShowLoadDialog(false);
      addLog(`ìë™í™” ê³µì • '${process.name}'ì„(ë¥¼) ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
    } catch (error) {
      console.error('ìë™í™” ê³µì • ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
      addLog(`ìë™í™” ê³µì • ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜: ${error}`);
    } finally {
      setIsLoading(false);
    }
  };

  // ìë™í™” ê³µì • ì‚­ì œ í•¨ìˆ˜ ìˆ˜ì •
  const deleteProcess = async () => {
    if (!selectedProcessId) {
      toast({
        variant: "destructive",
        title: "ì‚­ì œ ì‹¤íŒ¨",
        description: "ì‚­ì œí•  í”„ë¡œì„¸ìŠ¤ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
      });
      return;
    }
    
    try {
      setIsLoading(true);
      
      // ëª¨ë“  ì €ì¥ëœ í”„ë¡œì„¸ìŠ¤ ë¶ˆëŸ¬ì˜¤ê¸°
      const processesResponse = await fetch('/api/automation/processes');
      let existingProcesses = [];
      
      if (processesResponse.ok) {
        const data = await processesResponse.json();
        if (data.processes && Array.isArray(data.processes)) {
          existingProcesses = data.processes;
        }
      }
      
      // ì‚­ì œí•  í”„ë¡œì„¸ìŠ¤ í™•ì¸
      const processToDelete = existingProcesses.find(p => p.id === selectedProcessId);
      
      if (!processToDelete) {
        toast({
          variant: "destructive",
          title: "ì‚­ì œ ì‹¤íŒ¨",
          description: "ì„ íƒí•œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        });
        return;
      }
      
      console.log(`[ìë™í™” ê³µì • ì‚­ì œ] ì‹œë„ ì¤‘, í”„ë¡œì„¸ìŠ¤ ID: ${selectedProcessId}, ì´ë¦„: ${processToDelete.name}`);
      
      // í”„ë¡œì„¸ìŠ¤ ì‚­ì œ ìš”ì²­ URL
      const url = `/api/automation/processes?id=${selectedProcessId}`;
      
      // ì‚­ì œ ìš”ì²­
      const response = await fetch(url, {
        method: 'DELETE'
      });
      
      if (response.ok) {
        const responseData = await response.json();
        
        if (responseData.success) {
          console.log('[ìë™í™” ê³µì • ì‚­ì œ] ì„±ê³µ ì‘ë‹µ:', responseData);
          
          // ëª©ë¡ì—ì„œ ì‚­ì œëœ í”„ë¡œì„¸ìŠ¤ ì œê±°
          setSavedProcesses(prev => prev.filter(p => p.id !== selectedProcessId));
          setSelectedProcessId('');
          setShowDeleteConfirm(false);
          
          // ì„±ê³µ ì•Œë¦¼
          toast({
            title: "ì‚­ì œ ì„±ê³µ",
            description: `ìë™í™” ê³µì • '${processToDelete.name}'ì´(ê°€) ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`
          });
          
          // ë‹¤ì‹œ ê³µì • ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (í•­ìƒ ìµœì‹  ëª©ë¡ ìœ ì§€)
          try {
            const refreshResponse = await fetch('/api/automation/processes');
            if (refreshResponse.ok) {
              const refreshData = await refreshResponse.json();
              if (refreshData.processes) {
                setSavedProcesses(refreshData.processes);
              }
            }
          } catch (refreshError) {
            console.error('[ìë™í™” ê³µì • ì‚­ì œ] ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨:', refreshError);
          }
        } else {
          throw new Error(responseData.error || 'ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
      } else {
        // ì˜¤ë¥˜ ì‘ë‹µ í™•ì¸
        let errorMsg = '';
        try {
          const errorData = await response.json();
          errorMsg = errorData.error || response.statusText;
        } catch (e) {
          errorMsg = await response.text() || `HTTP ì˜¤ë¥˜: ${response.status}`;
        }
        
        throw new Error(errorMsg);
      }
    } catch (error) {
      console.error('[ìë™í™” ê³µì • ì‚­ì œ] ì˜¤ë¥˜:', error);
      
      toast({
        variant: "destructive", 
        title: "ì‚­ì œ ì‹¤íŒ¨",
        description: `ìë™í™” ê³µì • ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`
      });
    } finally {
      setIsLoading(false);
      setShowDeleteConfirm(false);
    }
  };
  
  // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìë™í™” ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°
  const loadStateFromLocalStorage = useCallback(() => {
    try {
      const automationStateJson = localStorage.getItem(AUTOMATION_STATE_KEY);
      const selectedSequencesJson = localStorage.getItem(AUTOMATION_SEQUENCES_KEY);
      
      if (automationStateJson && selectedSequencesJson) {
        const automationState = JSON.parse(automationStateJson);
        const storedSequences = JSON.parse(selectedSequencesJson);
        
        // ì™„ë£Œ ë˜ëŠ” ì˜¤ë¥˜ ìƒíƒœì¸ ê²½ìš° waiting ìƒíƒœë¡œ ë³€ê²½í•˜ì—¬ UI í™œì„±í™”
        if (automationState.status === 'completed' || automationState.status === 'error') {
          setStatus('waiting');
          addLog('ì´ì „ ìë™í™” ê³µì • ìƒíƒœê°€ ìˆìŠµë‹ˆë‹¤. ì‹œí€€ìŠ¤ë¥¼ í¸ì§‘í•˜ê±°ë‚˜ ë‹¤ì‹œ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
        } else {
          // ì‹œê°„ ì œí•œ ì—†ì´ ì´ì „ ìƒíƒœ ë³µì› (ëª¨ë“  ìƒíƒœ ìœ ì§€)
          setStatus(automationState.status);
          
          // ìƒíƒœì— ë”°ë¥¸ ë¡œê·¸ ì¶”ê°€
          if (automationState.status === 'running') {
            addLog('ìë™í™” ê³µì •ì´ ê³„ì† ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ì„¤ì •ëœ ì‹œí€€ìŠ¤ì— ë”°ë¼ ì§„í–‰ë©ë‹ˆë‹¤.');
          } else if (automationState.status === 'paused') {
            addLog('ìë™í™” ê³µì •ì´ ì¼ì‹œ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ê³„ì† ì§„í–‰í•˜ë ¤ë©´ ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.');
          }
        }
        
        setCurrentSequenceIndex(automationState.currentSequenceIndex || -1);
        setLogs(automationState.logs || []);
        setSelectedSequences(storedSequences || []);
        
        // ì‹¤í–‰ ì¤‘ì¸ ìƒíƒœì—ì„œë„ í˜ì´ì§€ ì´ë™ ê°€ëŠ¥í•˜ë„ë¡ ì ê¸ˆ ë¹„í™œì„±í™”
        // if (automationState.status === 'running' && onLockChange) {
        //   onLockChange(true);
        // }
        
        return true;
      }
    } catch (error) {
      console.error('ìë™í™” ê³µì • ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
    }
    
    return false;
  }, [onLockChange]);
  
  // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìë™í™” ìƒíƒœ ì €ì¥
  const saveStateToLocalStorage = useCallback(() => {
    try {
      const automationState = {
        status,
        currentSequenceIndex,
        logs,
        lastUpdated: Date.now()
      };
      
      localStorage.setItem(AUTOMATION_STATE_KEY, JSON.stringify(automationState));
      localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify(selectedSequences));
      
      console.log('ìë™í™” ê³µì • ìƒíƒœ ì €ì¥ë¨', automationState);
    } catch (error) {
      console.error('ìë™í™” ê³µì • ìƒíƒœ ì €ì¥ ì‹¤íŒ¨:', error);
    }
  }, [status, currentSequenceIndex, logs, selectedSequences]);
  
  // ìƒíƒœ ë³€ê²½ ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
  useEffect(() => {
    // ì´ˆê¸° ë¡œë“œ ì „ì´ë©´ ì €ì¥í•˜ì§€ ì•ŠìŒ
    if (!initialStateLoaded?.current) return;
    
    // ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ê°€ ì„¤ì •ëœ ê²½ìš° ì €ì¥í•˜ì§€ ì•ŠìŒ
    if (processingAction.current) return;
    
    // ìƒíƒœ ì €ì¥ ì§€ì—° ì²˜ë¦¬ (ë§ì€ ì—…ë°ì´íŠ¸ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´)
    const saveTimer = setTimeout(() => {
      try {
        const automationState = {
          status,
          currentSequenceIndex,
          logs: logs.slice(0, 50), // ë¡œê·¸ í¬ê¸° ì œí•œ
          lastUpdated: Date.now()
        };
        
        localStorage.setItem(AUTOMATION_STATE_KEY, JSON.stringify(automationState));
        
        // ì‹œí€€ìŠ¤ ë°°ì—´ ê²€ì¦
        if (Array.isArray(selectedSequences)) {
          localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify(selectedSequences));
        }
        
        console.log('ìë™í™” ê³µì • ìƒíƒœ ì €ì¥ë¨');
      } catch (error) {
        console.error('ìë™í™” ê³µì • ìƒíƒœ ì €ì¥ ì‹¤íŒ¨:', error);
      }
    }, 300); // 300ms ì§€ì—°
    
    // ì»´í¬ë„ŒíŠ¸ê°€ ì–¸ë§ˆìš´íŠ¸ë˜ê±°ë‚˜ depsê°€ ë³€ê²½ë˜ë©´ íƒ€ì´ë¨¸ ì·¨ì†Œ
    return () => clearTimeout(saveTimer);
  }, [status, currentSequenceIndex, selectedSequences, logs]);
  
  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° (í•œ ë²ˆë§Œ ì‹¤í–‰)
  useEffect(() => {
    // ìƒíƒœê°€ ì´ë¯¸ ë¡œë“œëœ ê²½ìš° ì¤‘ë³µ ë¡œë“œ ë°©ì§€
    if (initialStateLoaded.current) return;
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë¡œë“œ (ì´ˆê¸° ë§ˆìš´íŠ¸ ì‹œì—ë§Œ)
    try {
      const automationStateJson = localStorage.getItem(AUTOMATION_STATE_KEY);
      const selectedSequencesJson = localStorage.getItem(AUTOMATION_SEQUENCES_KEY);
      
      if (automationStateJson && selectedSequencesJson) {
        // ë¡œë”© í”Œë˜ê·¸ ì„¤ì •
        processingAction.current = true;
        
        const automationState = JSON.parse(automationStateJson);
        const storedSequences = JSON.parse(selectedSequencesJson);
        
        // ì™„ë£Œ ë˜ëŠ” ì˜¤ë¥˜ ìƒíƒœì¸ ê²½ìš° waiting ìƒíƒœë¡œ ë³€ê²½
        const newStatus = ['completed', 'error'].includes(automationState.status) 
          ? 'waiting' 
          : automationState.status || 'waiting';
        
        setStatus(newStatus);
        setCurrentSequenceIndex(automationState.currentSequenceIndex || -1);
        setLogs(automationState.logs || []);
        
        // ì‹œí€€ìŠ¤ ì„¤ì • ì „ì— ê²€ì¦
        if (Array.isArray(storedSequences)) {
          setSelectedSequences(storedSequences);
        } else {
          console.warn('ì €ì¥ëœ ì‹œí€€ìŠ¤ê°€ ë°°ì—´ì´ ì•„ë‹™ë‹ˆë‹¤:', storedSequences);
          setSelectedSequences([]);
        }
        
        initialStateLoaded.current = true;
        console.log('ì´ì „ ìƒíƒœë¥¼ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¡œë“œí–ˆìŠµë‹ˆë‹¤:', newStatus);
        
        // ë¡œë”© í”Œë˜ê·¸ í•´ì œ
        processingAction.current = false;
      }
    } catch (error) {
      console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨:', error);
      processingAction.current = false;
    }
  }, []);
  
  // ìƒíƒœ ë³€ê²½ ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ (ë””ë°”ìš´ìŠ¤ ì ìš©)
  const debouncedSaveStateRef = useRef<any>();
  
  // ë””ë°”ìš´ìŠ¤ëœ ì €ì¥ í•¨ìˆ˜ ìƒì„±
  useEffect(() => {
    // ë””ë°”ìš´ìŠ¤ëœ ì €ì¥ í•¨ìˆ˜ ìƒì„±
    const saveState = () => {
      // ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ê°€ ì„¤ì •ëœ ê²½ìš° ì €ì¥í•˜ì§€ ì•ŠìŒ
      if (processingAction.current) return;
      
      try {
        const automationState = {
          status,
          currentSequenceIndex,
          logs: logs.slice(0, 50), // ë¡œê·¸ í¬ê¸° ì œí•œ
          lastUpdated: Date.now()
        };
        
        localStorage.setItem(AUTOMATION_STATE_KEY, JSON.stringify(automationState));
        
        // ì‹œí€€ìŠ¤ ë°°ì—´ ê²€ì¦
        if (Array.isArray(selectedSequences)) {
          localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify(selectedSequences));
        }
        
        console.log('ìë™í™” ê³µì • ìƒíƒœ ì €ì¥ë¨ (ë””ë°”ìš´ìŠ¤)');
      } catch (error) {
        console.error('ìë™í™” ê³µì • ìƒíƒœ ì €ì¥ ì‹¤íŒ¨:', error);
      }
    };
    
    // ë””ë°”ìš´ìŠ¤ í•¨ìˆ˜ ìƒì„±
    debouncedSaveStateRef.current = debounce(saveState, 300);
    
    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ë””ë°”ìš´ìŠ¤ ì·¨ì†Œ
    return () => {
      if (debouncedSaveStateRef.current) {
        debouncedSaveStateRef.current.cancel();
      }
    };
  }, [status, currentSequenceIndex, logs, selectedSequences]);
  
  // ìƒíƒœ ë³€ê²½ ì‹œ ë””ë°”ìš´ìŠ¤ëœ ì €ì¥ í•¨ìˆ˜ í˜¸ì¶œ
  useEffect(() => {
    // ì´ˆê¸° ë¡œë“œ ì „ì´ë©´ ì €ì¥í•˜ì§€ ì•ŠìŒ
    if (!initialStateLoaded.current) return;
    
    // ì´ˆê¸° ë¡œë“œ ì´í›„ì—ë§Œ ìƒíƒœ ì €ì¥ ì‹¤í–‰
    if (debouncedSaveStateRef.current && Array.isArray(selectedSequences)) {
      debouncedSaveStateRef.current();
    }
  }, [status, currentSequenceIndex, selectedSequences, logs]);
  
  // savedSequencesê°€ ë³€ê²½ë  ë•Œ availableSequences ì—…ë°ì´íŠ¸ (ë¬´í•œ ë£¨í”„ ë°©ì§€ ë¡œì§ ì¶”ê°€)
  useEffect(() => {
    // ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì´ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    if (processingAction.current) return;
    
    // ì‹œí€€ìŠ¤ ëª©ë¡ì„ ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œí€€ìŠ¤ë¡œ ì„¤ì •
    if (savedSequences && Array.isArray(savedSequences) && savedSequences.length > 0) {
      // í˜„ì¬ ê°’ê³¼ ë¹„êµí•˜ì—¬ ë³€ê²½ì´ ìˆì„ ë•Œë§Œ ì—…ë°ì´íŠ¸
      const uniqueSequenceNames = savedSequences
        .map(seq => seq.name)
        .filter((value, index, self) => self.indexOf(value) === index);
      
      // ì´ì „ ê°’ê³¼ í˜„ì¬ ê°’ì„ ë¹„êµ
      const prevNamesJson = JSON.stringify(availableSequences);
      const currentNamesJson = JSON.stringify(uniqueSequenceNames);
      
      if (prevNamesJson !== currentNamesJson) {
        setAvailableSequences(uniqueSequenceNames);
        console.log('ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œí€€ìŠ¤ ëª©ë¡ ì—…ë°ì´íŠ¸ë¨:', uniqueSequenceNames.length);
      }
    } else if (availableSequences.length > 0) {
      // ì‹œí€€ìŠ¤ê°€ ì—†ëŠ”ë° availableSequencesê°€ ìˆìœ¼ë©´ ì´ˆê¸°í™”
      setAvailableSequences([]);
    }
  }, [savedSequences, availableSequences]);
  
  // ì‹œí€€ìŠ¤ ì˜ˆìƒ ì‹¤í–‰ ì‹œê°„ ê³„ì‚° í•¨ìˆ˜ ì¶”ê°€
  const calculateExpectedDuration = (sequence: PumpSequence): number => {
    const baseTime = 10; // ê¸°ë³¸ ì‹œê°„ (ì´ˆ)
    const modeMultiplier = Math.floor(sequence.operation_mode / 10) === 1 ? 2 : 
                          Math.floor(sequence.operation_mode / 10) === 2 ? 3 : 4;
    const repeatMultiplier = sequence.repeats || 1;
    
    // ìµœì†Œ 30ì´ˆ, ìµœëŒ€ 5ë¶„ìœ¼ë¡œ ì œí•œ
    return Math.min(300, Math.max(30, baseTime * modeMultiplier * repeatMultiplier));
  };
  
  // ìƒíƒœì— ë”°ë¥¸ ë°°ê²½ìƒ‰ ë°˜í™˜
  const getStatusBgColor = () => {
    switch (status) {
      case 'waiting': return 'bg-gray-100';
      case 'running': return 'bg-blue-100';
      case 'completed': return 'bg-green-100';
      case 'stopped': return 'bg-red-100';
      default: return 'bg-gray-100';
    }
  };
  
  // ìƒíƒœì— ë”°ë¥¸ í…ìŠ¤íŠ¸ ë°˜í™˜
  const getStatusText = () => {
    switch (status) {
      case 'waiting': return 'ëŒ€ê¸°ì¤‘';
      case 'running': return 'ì‹¤í–‰ì¤‘';
      case 'completed': return 'ì™„ë£Œ';
      case 'stopped': return 'ë©ˆì¶¤';
      default: return 'ì•Œ ìˆ˜ ì—†ìŒ';
    }
  };
  
  // ì‹œí€€ìŠ¤ ìƒíƒœ ë°°ì§€ ì»´í¬ë„ŒíŠ¸
  const StatusBadge = ({ status }: { status: SequenceStatus }) => {
    switch (status) {
      case 'waiting':
        return <Badge variant="outline" className="bg-gray-100 text-gray-800 border-gray-300 px-3">ëŒ€ê¸°</Badge>;
      case 'running':
        return <Badge variant="outline" className="bg-blue-100 text-blue-800 border-blue-300 px-3 animate-pulse">ì‹¤í–‰ì¤‘</Badge>;
      case 'completed':
        return <Badge variant="outline" className="bg-green-100 text-green-800 border-green-300 px-3">ì™„ë£Œ</Badge>;
      case 'error':
        return <Badge variant="outline" className="bg-red-100 text-red-800 border-red-300 px-3">ì˜¤ë¥˜</Badge>;
      default:
        return <Badge variant="outline">ì•Œ ìˆ˜ ì—†ìŒ</Badge>;
    }
  };
  
  // ì‹œê°„ í˜•ì‹ ë³€í™˜ í•¨ìˆ˜
  const formatTime = (seconds: number): string => {
    if (seconds < 60) return `${seconds}ì´ˆ`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}ë¶„`;
    if (seconds < 86400) return `${Math.floor(seconds / 3600)}ì‹œê°„`;
    return `${Math.floor(seconds / 86400)}ì¼`;
  };
  
  // ëŒ€ê¸° ì‹œê°„ íŒì—… ì—´ê¸°
  const openTimePopup = (index: number, currentTime: number) => {
    // í˜„ì¬ ì„¤ì •ëœ ì‹œê°„ì„ ì‹œ/ë¶„/ì´ˆë¡œ ë³€í™˜
    const hours = Math.floor(currentTime / 3600);
    const minutes = Math.floor((currentTime % 3600) / 60);
    const seconds = currentTime % 60;
    
    setTempHours(hours);
    setTempMinutes(minutes);
    setTempSeconds(seconds);
    setShowTimePopup(index);
  };
  
  // ëŒ€ê¸° ì‹œê°„ íŒì—… ì €ì¥
  const saveTimePopup = (index: number) => {
    const totalSeconds = (tempHours * 3600) + (tempMinutes * 60) + tempSeconds;
    handleWaitTimeChange(index, totalSeconds);
    setShowTimePopup(null);
  };
  
  // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ í•¨ìˆ˜ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤
  const startCountdown = (index: number, seconds: number) => {
    console.log(`ì‹œí€€ìŠ¤ ${index}ì˜ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘: ${seconds}ì´ˆ`);
    
    // ì´ˆê¸° ì¹´ìš´íŠ¸ë‹¤ìš´ ê°’ ì„¤ì •
    setWaitingCountdowns(prev => ({
      ...prev,
      [index]: seconds
    }));
    
    // 1ì´ˆë§ˆë‹¤ ì¹´ìš´íŠ¸ë‹¤ìš´ ê°ì†Œ
    const intervalId = setInterval(() => {
      setWaitingCountdowns(prev => {
        const currentCount = prev[index];
        if (currentCount <= 1) {
          // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¢…ë£Œ
          clearInterval(intervalId);
          return {
            ...prev,
            [index]: 0
          };
        }
        return {
          ...prev,
          [index]: currentCount - 1
        };
      });
    }, 1000);
    
    // ì¸í„°ë²Œ ID ì €ì¥
    setCountdownIntervals(prev => ({
      ...prev,
      [`interval_${index}`]: intervalId
    }));
  };

  // ì¹´ìš´íŠ¸ë‹¤ìš´ ì œê±° í•¨ìˆ˜ë„ ìˆ˜ì •í•©ë‹ˆë‹¤
  const clearCountdown = (index: number) => {
    const intervalId = countdownIntervals[`interval_${index}`];
    if (intervalId) {
      clearInterval(intervalId);
    }
    
    // ì¹´ìš´íŠ¸ë‹¤ìš´ ìƒíƒœì—ì„œ ì œê±°
    setWaitingCountdowns(prev => {
      const updated = { ...prev };
      delete updated[index];
      return updated;
    });
    
    // ì¸í„°ë²Œ ID ëª©ë¡ì—ì„œ ì œê±°
    setCountdownIntervals(prev => {
      const updated = { ...prev };
      delete updated[`interval_${index}`];
      return updated;
    });
  };
  
  // í ë¹„ìš°ê¸° ëª…ë ¹
  const clearQueue = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "clear_q");
      addLog('Queue clear command sent');
    } catch (e) {
      addLog(`Queue clear command error: ${e}`);
    }
  };
  
  // íì—ì„œ í•­ëª© ì œê±°
  const removeQueueItem = (itemId: string) => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "remove_q");
      addLog(`Queue item remove command sent: ${itemId}`);
    } catch (e) {
      addLog(`Queue item remove command error: ${e}`);
    }
  };
  
  // í ì²˜ë¦¬ ì¼ì‹œì •ì§€
  const pauseQueueProcessing = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "pause");
      addLog(`Queue processing pause command sent`);
    } catch (e) {
      addLog(`Queue pause command error: ${e}`);
    }
  };

  // í ì²˜ë¦¬ ì¬ê°œ
  const resumeQueueProcessing = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "resume");
      addLog(`Queue processing resume command sent`);
    } catch (e) {
      addLog(`Queue resume command error: ${e}`);
    }
  };

  // í ëª©ë¡ ì¡°íšŒ
  const listQueue = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "list_q");
      addLog(`Queue list command sent`);
    } catch (e) {
      addLog(`Queue list command error: ${e}`);
    }
  };
  
  // ìˆ˜ë™ ì…ë ¥ ëª…ë ¹ ë°œí–‰
  const publishManualCommand = () => {
    if (!mqttClient || !manualCommand.trim()) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, manualCommand);
      addLog(`Manual command sent: ${manualCommand}`);
      setManualCommand(""); // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
    } catch (e) {
      addLog(`Manual command error: ${e}`);
    }
  };
  
  // í í•­ëª© ì „ì²´ ì œê±° ëª…ë ¹
  const removeAllQueueItems = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "remove_q");
      addLog(`Remove all queue items command sent`);
    } catch (e) {
      addLog(`Remove queue command error: ${e}`);
    }
  };
  
  // í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  const getCurrentSequenceInfo = () => {
    if (currentSequenceIndex >= 0 && currentSequenceIndex < selectedSequences.length) {
      const seq = selectedSequences[currentSequenceIndex];
      return `${currentSequenceIndex + 1}/${selectedSequences.length}: ${seq.sequence.name}`;
    }
    return '';
  };
  
  // ìƒˆë¡œê³ ì¹¨ ê°ì§€ ë° ìë™ ì´ˆê¸°í™” ì²˜ë¦¬
  useEffect(() => {
    // í˜ì´ì§€ ë¡œë“œ ì‹œ íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë¡
    const pageLoadTime = Date.now();
    
    // ë§ˆì§€ë§‰ í™œì„± ì‹œê°„ ê°€ì ¸ì˜¤ê¸°
    const lastActiveTime = parseInt(localStorage.getItem('automation-last-active-time') || '0');
    
    // í˜„ì¬ ì‹œê°„ ì €ì¥
    localStorage.setItem('automation-last-active-time', pageLoadTime.toString());
    
    // ìƒˆë¡œê³ ì¹¨ ê°ì§€ (3ì´ˆ ì´ë‚´ì˜ ê°„ê²©ì€ ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ê°„ì£¼)
    const isRefresh = pageLoadTime - lastActiveTime < 3000;
    
    // ìƒˆë¡œê³ ì¹¨ì´ê³  ìƒíƒœê°€ ì™„ë£Œë‚˜ ì˜¤ë¥˜ë©´ ì´ˆê¸°í™”
    if (isRefresh) {
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ í˜„ì¬ ìƒíƒœ í™•ì¸
      try {
        const automationStateJson = localStorage.getItem(AUTOMATION_STATE_KEY);
        if (automationStateJson) {
          const automationState = JSON.parse(automationStateJson);
          
          // ì™„ë£Œ ë˜ëŠ” ì˜¤ë¥˜ ìƒíƒœë©´ waiting ìƒíƒœë¡œ ë³€ê²½
          if (automationState.status === 'completed' || automationState.status === 'error') {
            setStatus('waiting');
            addLog('ìƒˆë¡œê³ ì¹¨ ê°ì§€: ìë™í™” ê³µì • ìƒíƒœë¥¼ ì´ˆê¸°í™”í–ˆìŠµë‹ˆë‹¤. ì‹œí€€ìŠ¤ë¥¼ í¸ì§‘í•˜ê±°ë‚˜ ë‹¤ì‹œ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
          }
        }
      } catch (error) {
        console.error('ìë™í™” ê³µì • ìƒíƒœ í™•ì¸ ì‹¤íŒ¨:', error);
      }
    }
    
    // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ í˜„ì¬ ì‹œê°„ ì €ì¥
    const handleBeforeUnload = () => {
      localStorage.setItem('automation-last-active-time', Date.now().toString());
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, []);
  
  // resetAutomation í•¨ìˆ˜ ë³µì›
  const enhancedResetAutomation = () => {
    console.log('ìë™í™” ê³µì • ë¦¬ì…‹ ì‹œì‘');
    
    try {
      // ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ ì„¤ì •ìœ¼ë¡œ ë‹¤ë¥¸ ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ì°¨ë‹¨
      processingAction.current = true;
      
      // ì‹¤í–‰ ì¤‘ì¸ ì¹´ìš´íŠ¸ë‹¤ìš´ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ëª¨ë‘ ì •ë¦¬
      Object.values(countdownIntervals).forEach(interval => {
        clearInterval(interval);
        clearTimeout(interval);
      });
      
      // ìƒíƒœ ì´ˆê¸°í™” (ì„ íƒí•œ ì‹œí€€ìŠ¤ëŠ” ìœ ì§€)
      setStatus('waiting');
      setCurrentSequenceIndex(-1);
      setWaitingCountdowns({});
      setCountdownIntervals({});
      
      // ëª¨ë“  ì‹œí€€ìŠ¤ì˜ ìƒíƒœë¥¼ 'waiting'ìœ¼ë¡œ ì´ˆê¸°í™”
      setSelectedSequences(prev => prev.map(seq => ({
        ...seq,
        status: 'waiting',
        startTime: undefined,
        endTime: undefined,
        errorDetails: undefined
      })));
      
      // í ì´ˆê¸°í™”
      if (mqttClient) {
        try {
          // ê°•ì œ ì¤‘ì§€ ë©”ì‹œì§€ ë°œí–‰
          mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
            action: 'force_stop',
            priority: 'high'
          }));
          
          // ì•½ê°„ì˜ ì§€ì—° í›„ í ì´ˆê¸°í™”
          setTimeout(() => {
            mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
              action: 'clear_all',
              priority: 'high'
            }));
            
            // ì²˜ë¦¬ ì™„ë£Œ í”Œë˜ê·¸ í•´ì œ
            processingAction.current = false;
            
            toast({
              title: "ë¦¬ì…‹ ì™„ë£Œ",
              description: "ê³µì • ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.",
            });
          }, 500);
        } catch (error) {
          console.error('MQTT ë©”ì‹œì§€ ë°œí–‰ ì¤‘ ì˜¤ë¥˜:', error);
          processingAction.current = false;
        }
      } else {
      processingAction.current = false;
      
      toast({
        title: "ë¦¬ì…‹ ì™„ë£Œ",
        description: "ê³µì • ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.",
      });
      }
    } catch (error) {
      console.error('MQTT ë©”ì‹œì§€ ë°œí–‰ ì¤‘ ì˜¤ë¥˜:', error);
      processingAction.current = false;
    }
  };
  
  useEffect(() => {
    if (!mqttClient) return;
    
    console.log('MQTT í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì„¤ì • ì¤‘...');
    
    // í´ë¼ì´ì–¸íŠ¸ ID ìƒì„± ë° ì €ì¥ (ì²« ì ‘ì† ì‹œ)
    if (!localStorage.getItem('automation-client-id')) {
      localStorage.setItem('automation-client-id', `client_${Math.random().toString(36).substring(2, 9)}`);
    }
    
    // MQTT êµ¬ë… ì„¤ì •
    mqttClient.on('message', messageHandler);
    
    // í•„ìˆ˜ í† í”½ êµ¬ë…
    mqttClient.subscribe(EXTRACTION_OUTPUT_TOPIC);
    mqttClient.subscribe(PROCESS_PROGRESS_TOPIC);
    mqttClient.subscribe(QUEUE_STATUS_TOPIC);
    mqttClient.subscribe(AUTOMATION_STATUS_TOPIC); // ìë™í™” ìƒíƒœ ê³µìœ  í† í”½ ì¶”ê°€
    
    return () => {
      console.log('MQTT ë©”ì‹œì§€ êµ¬ë… í•´ì œ');
      mqttClient.off('message', messageHandler);
    };
  }, [mqttClient]); // mqttClientë§Œ ì˜ì¡´ì„±ìœ¼ë¡œ ì‚¬ìš©
  
  // ìƒíƒœ ë³€ê²½ ì‹œ MQTTë¥¼ í†µí•´ ìƒíƒœ ê³µìœ 
  useEffect(() => {
    if (!mqttClient || !status) return;
    
    // í´ë¼ì´ì–¸íŠ¸ ID í™•ì¸ ë° ìƒì„± - ì„¸ì…˜ ì§€ì†ì„± ìœ ì§€
    if (!localStorage.getItem('automation-client-id')) {
      localStorage.setItem('automation-client-id', `client_${Math.random().toString(36).substring(2, 9)}`);
    }
    
    // ì´ì „ ìƒíƒœì™€ ë¹„êµí•˜ì—¬ ë³€ê²½ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ ë©”ì‹œì§€ ë°œí–‰
    const prevStatus = prevStateRef.current.status;
    const prevIndex = prevStateRef.current.currentSequenceIndex;
    const prevSequencesJSON = JSON.stringify(prevStateRef.current.selectedSequences);
    const prevCountdownsJSON = JSON.stringify(prevStateRef.current.waitingCountdowns);
    
    const currentSequencesJSON = JSON.stringify(selectedSequences);
    const currentCountdownsJSON = JSON.stringify(waitingCountdowns);
    
    // ìƒíƒœ ë³€ê²½ì´ ì—†ìœ¼ë©´ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
    if (
      prevStatus === status &&
      prevIndex === currentSequenceIndex &&
      prevSequencesJSON === currentSequencesJSON &&
      prevCountdownsJSON === currentCountdownsJSON
    ) {
      return;
    }
    
    // ì´ì œ ìƒíƒœì— ë³€ê²½ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ ì²˜ë¦¬
    try {
      const automationState = {
        status,
        currentSequenceIndex,
        selectedSequences,
        waitingCountdowns,
        lastUpdated: Date.now(),
        clientId: localStorage.getItem('automation-client-id')
      };
      
      // ìƒíƒœ ê³µìœ  í† í”½ì— ë°œí–‰
      mqttClient.publish(AUTOMATION_STATUS_TOPIC, JSON.stringify(automationState));
      console.log('ìë™í™” ê³µì • ìƒíƒœ ê³µìœ ë¨:', status);
      
      // í˜„ì¬ ìƒíƒœë¥¼ ì´ì „ ìƒíƒœë¡œ ì €ì¥
      prevStateRef.current = {
        status,
        currentSequenceIndex,
        selectedSequences,
        waitingCountdowns
      };
    } catch (error) {
      console.error('ìë™í™” ê³µì • ìƒíƒœ ê³µìœ  ì‹¤íŒ¨:', error);
    }
  }, [mqttClient, status, currentSequenceIndex, selectedSequences, waitingCountdowns]);
  
  // resetAutomation í•¨ìˆ˜ - ì‹œí€€ìŠ¤ ì„¤ì •ì„ ìœ ì§€í•˜ë©° ìƒíƒœë§Œ ì´ˆê¸°í™”
  const enhancedPriorityReset = () => {
    console.log('ìë™í™” ê³µì • ë¦¬ì…‹ ì‹œì‘ - í˜„ì¬ ì„¤ì •ëœ ì‹œí€€ìŠ¤ ìœ ì§€í•˜ë©° ì´ˆê¸°í™”');
    
    // ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì¸ ê²½ìš° ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    if (processingAction.current) {
      console.log('ì´ë¯¸ ë‹¤ë¥¸ ì‘ì—…ì´ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤. ë¦¬ì…‹ ìš”ì²­ ë¬´ì‹œë¨.');
      return;
    }
    
    // ëª¨ë“  êµ¬ë… ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¼ì‹œ ì¤‘ì§€
    if (mqttClient) {
      mqttClient.off('message', messageHandler);
    }
    
    processingAction.current = true;
    
    // ì‹¤í–‰ ì¤‘ì¸ ì¹´ìš´íŠ¸ë‹¤ìš´ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ëª¨ë‘ ì •ë¦¬
    Object.values(countdownIntervals).forEach(interval => {
      clearInterval(interval);
      clearTimeout(interval);
    });
    
    // ìƒíƒœ ì´ˆê¸°í™” (ì„ íƒí•œ ì‹œí€€ìŠ¤ëŠ” ìœ ì§€)
    setStatus('waiting');
    setCurrentSequenceIndex(-1);
    setWaitingCountdowns({});
    setCountdownIntervals({});
    
    // ëª¨ë“  ì‹œí€€ìŠ¤ì˜ ìƒíƒœë¥¼ 'waiting'ìœ¼ë¡œ ì´ˆê¸°í™”
    setSelectedSequences(prev => prev.map(seq => ({
      ...seq,
      status: 'waiting',
      startTime: undefined,
      endTime: undefined,
      errorDetails: undefined
    })));
    
    // í ì´ˆê¸°í™”
    if (mqttClient) {
      try {
        // ê°•ì œ ì¤‘ì§€ ë° ì´ˆê¸°í™” ë©”ì‹œì§€
        mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
          action: 'force_stop',
          priority: 'high'
        }));
        
        // ì•½ê°„ì˜ ì§€ì—° í›„ í ì´ˆê¸°í™”
        setTimeout(() => {
          mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
            action: 'clear_all',
            priority: 'high'
          }));
          
          // ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì¬ë“±ë¡
          mqttClient.on('message', messageHandler);
          
          processingAction.current = false;
          
          toast({
            title: "ë¦¬ì…‹ ì™„ë£Œ",
            description: "ê³µì • ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹œí€€ìŠ¤ ì„¤ì •ì€ ìœ ì§€ë©ë‹ˆë‹¤.",
          });
          
          // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì‹œí€€ìŠ¤ ìƒíƒœ ì—…ë°ì´íŠ¸
          if (typeof window !== 'undefined') {
            try {
              localStorage.setItem(AUTOMATION_STATE_KEY, JSON.stringify({
                status: 'waiting',
                currentSequenceIndex: -1,
                waitingCountdowns: {}
              }));
            } catch (error) {
              console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì €ì¥ ì¤‘ ì˜¤ë¥˜:', error);
            }
          }
        }, 500);
      } catch (error) {
        console.error('MQTT ë©”ì‹œì§€ ë°œí–‰ ì¤‘ ì˜¤ë¥˜:', error);
        processingAction.current = false;
        
        // ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì¬ë“±ë¡
        mqttClient.on('message', messageHandler);
      }
    } else {
      processingAction.current = false;
      
      toast({
        title: "ë¦¬ì…‹ ì™„ë£Œ",
        description: "ê³µì • ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹œí€€ìŠ¤ ì„¤ì •ì€ ìœ ì§€ë©ë‹ˆë‹¤.",
      });
    }
  };
  
  // fullReset í•¨ìˆ˜ - ëª¨ë“  ìƒíƒœì™€ ì„¤ì •ì„ ì´ˆê¸°í™”
  const fullResetPriority = () => {
    console.log('ìë™í™” ê³µì • ì™„ì „ ì´ˆê¸°í™” ì‹œì‘ - ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”');
    
    // ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì¸ ê²½ìš° ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
    if (processingAction.current) {
      console.log('ì´ë¯¸ ë‹¤ë¥¸ ì‘ì—…ì´ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤. ì™„ì „ ì´ˆê¸°í™” ìš”ì²­ ë¬´ì‹œë¨.');
      return;
    }
    
    // ëª¨ë“  êµ¬ë… ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¼ì‹œ ì¤‘ì§€
    if (mqttClient) {
      mqttClient.off('message', messageHandler);
    }
    
    // ì—¬ëŸ¬ ìƒíƒœ ë³€ê²½ ì‘ì—… ì „ì— ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ ì„¤ì •
    processingAction.current = true;
    
    // ì‹¤í–‰ ì¤‘ì¸ ì¹´ìš´íŠ¸ë‹¤ìš´ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ëª¨ë‘ ì •ë¦¬
    Object.values(countdownIntervals).forEach(interval => {
      clearInterval(interval);
      clearTimeout(interval);
    });
    
    // ìƒíƒœ ì´ˆê¸°í™”
    setStatus('waiting');
    setSelectedSequences([]);
    setCurrentSequenceIndex(-1);
    setLogs([]);
    setLogMessages([]); // ë¡œê·¸ ë©”ì‹œì§€ë„ ì´ˆê¸°í™”
    setWaitingCountdowns({});
    setShowTimePopup(null);
    setTempHours(0);
    setTempMinutes(0);
    setTempSeconds(0);
    setCountdownIntervals({});
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°ì´í„° ì‚­ì œ
    if (typeof window !== 'undefined') {
      try {
        localStorage.removeItem(AUTOMATION_STATE_KEY);
        localStorage.removeItem(AUTOMATION_SEQUENCES_KEY);
      } catch (error) {
        console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°ì´í„° ì‚­ì œ ì¤‘ ì˜¤ë¥˜:', error);
      }
    }
    
    // í ìƒíƒœ ì´ˆê¸°í™”
    if (mqttClient) {
      try {
        // ê°•ì œ ì¤‘ì§€ ë©”ì‹œì§€ ë°œí–‰
        mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
          action: 'force_stop',
          priority: 'high'
        }));
        
        // ì•½ê°„ì˜ ì§€ì—° í›„ í ì´ˆê¸°í™”
        setTimeout(() => {
          // í ì´ˆê¸°í™” ë©”ì‹œì§€ ë°œí–‰
          mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
            action: 'clear_all',
            priority: 'high'
          }));
          
          // ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì¬ë“±ë¡
          mqttClient.on('message', messageHandler);
          
          processingAction.current = false;
          
          // ì´ˆê¸°í™” ì™„ë£Œ ì•Œë¦¼
          toast({
            title: "ì™„ì „ ì´ˆê¸°í™” ì™„ë£Œ",
            description: "ëª¨ë“  ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ ì„¤ì •ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
          });
        }, 500);
      } catch (error) {
        console.error('MQTT ë©”ì‹œì§€ ë°œí–‰ ì¤‘ ì˜¤ë¥˜:', error);
        processingAction.current = false;
        
        // ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì¬ë“±ë¡
        mqttClient.on('message', messageHandler);
      }
    } else {
      processingAction.current = false;
      
      // ì´ˆê¸°í™” ì™„ë£Œ ì•Œë¦¼
      toast({
        title: "ì™„ì „ ì´ˆê¸°í™” ì™„ë£Œ",
        description: "ëª¨ë“  ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ ì„¤ì •ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
      });
    }
  };
    
    // MQTT ë©”ì‹œì§€ ì²˜ë¦¬
    const messageHandler = (topic: string, message: Buffer) => {
    // ìƒíƒœê°€ ì§„í–‰ì¤‘ì¸ ì´ˆê¸°í™” ì‘ì—…ì´ ìˆìœ¼ë©´ ë©”ì‹œì§€ ì²˜ë¦¬ ë¬´ì‹œ
    if (processingAction.current) {
      console.log('ì´ˆê¸°í™” ì¤‘ì´ë¯€ë¡œ ë©”ì‹œì§€ ì²˜ë¦¬ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤:', topic);
      return;
    }
    
      try {
        const messageStr = message.toString();
        
        // í•„ìˆ˜ í† í”½ë§Œ ë¡œê·¸ì— ì¶œë ¥
        if (topic === EXTRACTION_INPUT_TOPIC) {
          console.log(`ğŸ“¤ [INPUT] ${messageStr.substring(0, 100)}...`);
        } 
        else if (topic === EXTRACTION_OUTPUT_TOPIC) {
          console.log(`ğŸ“¥ [OUTPUT] ${messageStr}`);
          // addLog ëŒ€ì‹  ì§ì ‘ ë¡œê·¸ ê°ì²´ ìƒì„±
          const newLog = {
            id: `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
            message: `OUTPUT: ${messageStr}`,
            timestamp: Date.now(),
            type: 'info' as const
          };
          setLogs(prevLogs => [...prevLogs, newLog].slice(-100));
        }
        else if (topic === PROCESS_PROGRESS_TOPIC) {
          console.log(`ğŸ“Š [PROGRESS] ${messageStr}`);
        
        // ë©”ì‹œì§€ í¬ê¸° ì œí•œ ì²˜ë¦¬ (10000ì ì´ìƒì¸ ê²½ìš° ì¶•ì•½)
        let displayMessage = messageStr;
        if (displayMessage && displayMessage.length > 10000) {
          console.warn(`ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤: ${displayMessage.length} ë°”ì´íŠ¸. ì˜ë¼ëƒ…ë‹ˆë‹¤.`);
          displayMessage = displayMessage.substring(0, 10000) + "... (ë©”ì‹œì§€ í¬ê¸° ì´ˆê³¼ë¡œ ì˜ë¦¼)`);
        }
        
        // ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ ì €ì¥
        setProgress(displayMessage);
        
        // ë¡œê·¸ ê°ì²´ ì¶”ê°€ (logsëŠ” ë¡œê·¸ ê°ì²´ ë°°ì—´)
              const newLog = {
                id: `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
          message: `PROGRESS: ${displayMessage.substring(0, 100)}${displayMessage.length > 100 ? '...' : ''}`,
                timestamp: Date.now(),
          type: 'info' as const
              };
              setLogs(prevLogs => [...prevLogs, newLog].slice(-100));
              
        // ë¡œê·¸ ë©”ì‹œì§€ ì¶”ê°€ (logMessagesëŠ” ë¬¸ìì—´ ë°°ì—´)
        setLogMessages(prev => {
          const newMessage = `[${new Date().toLocaleTimeString()}] ì§„í–‰ ìƒíƒœ: ${displayMessage.substring(0, 50)}${displayMessage.length > 50 ? '...' : ''}`;
          return [newMessage, ...prev].slice(0, 100); // ìµœëŒ€ 100ê°œë§Œ ìœ ì§€
        });
      }
      else if (topic === AUTOMATION_STATUS_TOPIC) {
        // ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ì˜ ìë™í™” ìƒíƒœ ìˆ˜ì‹ 
        try {
          const automationState = JSON.parse(messageStr);
          
          // ë³¸ì¸ì´ ë°œí–‰í•œ ë©”ì‹œì§€ëŠ” ë¬´ì‹œ
          const clientId = localStorage.getItem('automation-client-id');
          if (automationState.clientId && automationState.clientId === clientId) {
            console.log('ë³¸ì¸ì´ ë°œí–‰í•œ ë©”ì‹œì§€ì´ë¯€ë¡œ ë¬´ì‹œí•©ë‹ˆë‹¤.');
            return;
          }
          
          console.log(`ğŸ“± [ìë™í™” ìƒíƒœ ë™ê¸°í™”] ìˆ˜ì‹ ëœ ìƒíƒœ:`, automationState);
          
          // ë¡œì»¬ì—ì„œ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸ ê²½ìš° ë¬´ì‹œ (ì¶©ëŒ ë°©ì§€)
          if (status === 'running' && currentSequenceIndex >= 0) {
            console.log('ë¡œì»¬ì—ì„œ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë¯€ë¡œ ì›ê²© ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ë¬´ì‹œí•©ë‹ˆë‹¤.');
            return;
          }
          
          // ì›ê²© ë™ê¸°í™” ìˆ˜í–‰
          if (automationState.selectedSequences && Array.isArray(automationState.selectedSequences)) {
            setSelectedSequences(automationState.selectedSequences);
          }
          
          if (automationState.status) {
            setStatus(automationState.status);
          }
          
          if (automationState.currentSequenceIndex !== undefined) {
            setCurrentSequenceIndex(automationState.currentSequenceIndex);
          }
          
          if (automationState.waitingCountdowns) {
            setWaitingCountdowns(automationState.waitingCountdowns);
          }
          
          // ìƒíƒœ ì—…ë°ì´íŠ¸ ë¡œê·¸ (ë¹„êµì  ì¤‘ìš”í•œ ìƒíƒœ ë³€í™”ë§Œ ë¡œê·¸ì— ê¸°ë¡)
          if (automationState.status !== status || 
              automationState.currentSequenceIndex !== currentSequenceIndex) {
            addLog('ìë™í™” ê³µì • ìƒíƒœê°€ ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ì™€ ë™ê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', false);
            console.log('ìë™í™” ê³µì • ìƒíƒœ ë™ê¸°í™” ì™„ë£Œ');
          }
        } catch (error) {
          console.error('ìë™í™” ìƒíƒœ ë™ê¸°í™” ì˜¤ë¥˜:', error);
        }
      }
      
      // MQTT OUTPUT í† í”½ ì²˜ë¦¬ (ê¸°ì¡´ ì½”ë“œ)
      if (topic === EXTRACTION_OUTPUT_TOPIC) {
        // í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ì²˜ë¦¬
        addLog(`ìƒíƒœ ë©”ì‹œì§€ ìˆ˜ì‹ : ${messageStr}`, true);
          
        // ê³µì • ì¢…ë£Œ ë©”ì‹œì§€ ê°ì§€
        const isCompletionMessage = messageStr.toLowerCase().includes('ê³µì • ì¢…ë£Œ') || 
                                  messageStr.toLowerCase().includes('ê³µì •ì¢…ë£Œ') ||
                                  messageStr.includes('ë””ë°”ì´ìŠ¤ ì¬ë¶€íŒ… ì‹œì‘');
        
        if (isCompletionMessage) {
          console.log(`ğŸš¨ ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€! [${messageStr}]`);
          
          // í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ì—ë§Œ ì™„ë£Œ ì²˜ë¦¬ ì ìš©
          if (status === 'running' && currentSequenceIndex >= 0) {
            // í˜„ì¬ ì‹œí€€ìŠ¤ì˜ ìƒíƒœê°€ 'running'ì¸ ê²½ìš°ì—ë§Œ ì™„ë£Œ ì²˜ë¦¬ ìˆ˜í–‰
            const currentSeq = selectedSequences[currentSequenceIndex];
            if (currentSeq && currentSeq.status === 'running') {
              addLog(`ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1} ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€: ${currentSeq.sequence.name}`, true);
              // ì‹œí€€ìŠ¤ ì™„ë£Œ ì²˜ë¦¬
              handleSequenceCompletion(currentSequenceIndex, 'completed', 'ê³µì • ì¢…ë£Œ ë©”ì‹œì§€ ê°ì§€');
            } else {
              // ì´ë¯¸ ì™„ë£Œë˜ì—ˆê±°ë‚˜ ì—ëŸ¬ ìƒíƒœì¸ ê²½ìš° ë¡œê·¸ë§Œ ë‚¨ê¹€
              if (currentSeq) {
                addLog(`ì™„ë£Œ ë©”ì‹œì§€ê°€ ê°ì§€ë˜ì—ˆìœ¼ë‚˜ ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1}ëŠ” ì´ë¯¸ ${currentSeq.status} ìƒíƒœì…ë‹ˆë‹¤.`, true);
              }
            }
          } else {
            addLog(`ì™„ë£Œ ë©”ì‹œì§€ê°€ ê°ì§€ë˜ì—ˆìœ¼ë‚˜ ì‹¤í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.`, false);
          }
          }
        }
        
        // í ìƒíƒœ í† í”½ ì²˜ë¦¬
        if (topic === QUEUE_STATUS_TOPIC) {
          try {
            const queueData = JSON.parse(messageStr);
            // ì´ì „ ìƒíƒœì™€ ë¹„êµí•´ì„œ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸
            setQueueStatus(prev => {
              // ìƒíƒœê°€ ë™ì¼í•˜ë©´ ì´ì „ ìƒíƒœ ê·¸ëŒ€ë¡œ ë°˜í™˜í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
              if (prev && 
                  prev.count === queueData.count && 
                  prev.isProcessing === queueData.isProcessing) {
                return prev;
              }
              console.log(`[í ìƒíƒœ ì—…ë°ì´íŠ¸] í•­ëª© ìˆ˜: ${queueData.count}, ì²˜ë¦¬ ì¤‘: ${queueData.isProcessing}`);
              return queueData;
            });
          } catch (error) {
            console.error('í ìƒíƒœ ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
          }
        }
      } catch (error) {
      console.error('ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
    }
  };
  
  // ì´ì „ ìƒíƒœ ì €ì¥ì„ ìœ„í•œ ref ê°ì²´ ìƒì„±
  const prevStateRef = useRef({
    status: '',
    currentSequenceIndex: -1,
    selectedSequences: [],
    waitingCountdowns: {}
  });
  
  useEffect(() => {
    if (!mqttClient || !status) return;
    
    // ë©”ëª¨ë¦¬ ì°¸ì¡° ë¹„êµë¥¼ ìœ„í•œ ë³€ìˆ˜
    const currentSequencesRef = JSON.stringify(selectedSequences);
    const currentCountdownsRef = JSON.stringify(waitingCountdowns);
    
    // ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ì™€ ìƒíƒœ ê³µìœ ë¥¼ ìœ„í•œ MQTT ë©”ì‹œì§€ ë°œí–‰
    try {
      // ì´ì „ ìƒíƒœì™€ ë¹„êµí•˜ì—¬ ë³€ê²½ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ ë©”ì‹œì§€ ë°œí–‰
      const prevStatus = prevStateRef.current.status;
      const prevIndex = prevStateRef.current.currentSequenceIndex;
      const prevSequencesJSON = JSON.stringify(prevStateRef.current.selectedSequences);
      const prevCountdownsJSON = JSON.stringify(prevStateRef.current.waitingCountdowns);
      
      // í˜„ì¬ ìƒíƒœì™€ ì´ì „ ìƒíƒœê°€ ë™ì¼í•œ ê°ì²´ë¥¼ ì°¸ì¡°í•˜ëŠ”ì§€ í™•ì¸
      if (
        prevStatus === status &&
        prevIndex === currentSequenceIndex &&
        prevSequencesJSON === currentSequencesRef &&
        prevCountdownsJSON === currentCountdownsRef
      ) {
        // ìƒíƒœê°€ ë³€ê²½ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì•„ë¬´ ì‘ì—…ë„ ìˆ˜í–‰í•˜ì§€ ì•ŠìŒ
        return;
      }
      
      // ìƒíƒœì— ë³€ê²½ì´ ìˆì„ ë•Œë§Œ ë©”ì‹œì§€ ë°œí–‰
      const automationState = {
        status,
        currentSequenceIndex,
        selectedSequences,
        waitingCountdowns,
        lastUpdated: Date.now(),
        clientId: localStorage.getItem('automation-client-id') || `client_${Math.random().toString(36).substring(2, 9)}`
      };
      
      // í´ë¼ì´ì–¸íŠ¸ ID ìœ ì§€
      if (!localStorage.getItem('automation-client-id')) {
        localStorage.setItem('automation-client-id', automationState.clientId);
      }
      
      // ìƒíƒœ ê³µìœ  í† í”½ì— ë°œí–‰
      mqttClient.publish(AUTOMATION_STATUS_TOPIC, JSON.stringify(automationState));
      console.log('ìë™í™” ê³µì • ìƒíƒœ ê³µìœ ë¨:', status);
      
      // í˜„ì¬ ìƒíƒœë¥¼ ì´ì „ ìƒíƒœë¡œ ì €ì¥
      prevStateRef.current = {
        status,
        currentSequenceIndex,
        selectedSequences,
        waitingCountdowns
      };
    } catch (error) {
      console.error('ìë™í™” ê³µì • ìƒíƒœ ê³µìœ  ì‹¤íŒ¨:', error);
    }
  }, [mqttClient, status, currentSequenceIndex, selectedSequences, waitingCountdowns]);
  
  // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë³µì› í•¨ìˆ˜ ìµœì í™” (ì•½ 1610ì¤„ ê·¼ì²˜)
  useEffect(() => {
    // ì´ë¯¸ ë¡œë“œëœ ìƒíƒœì´ë©´ ë‹¤ì‹œ ë¡œë“œí•˜ì§€ ì•ŠìŒ
    if (initialStateLoaded.current) return;
    
    // ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ ì„¤ì •
    processingAction.current = true;
    console.log("ìë™í™” ê³µì • ìƒíƒœ ë¡œë“œ ì‹œì‘");
    
    try {
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
      const savedState = localStorage.getItem(AUTOMATION_STATE_KEY);
      const savedSequences = localStorage.getItem(AUTOMATION_SEQUENCES_KEY);
      
      if (savedState && savedSequences) {
        const state = JSON.parse(savedState);
        const sequences = JSON.parse(savedSequences);
        
        // ì‹œí€€ìŠ¤ ë°ì´í„° ìœ íš¨ì„± ê²€ì‚¬
        if (Array.isArray(sequences) && sequences.length > 0) {
          console.log('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì‹œí€€ìŠ¤ ë³µì›:', sequences.length);
          
          // ì‹œí€€ìŠ¤ ìƒíƒœê°€ ì‹¤í–‰ ì¤‘ì´ê±°ë‚˜ ëŒ€ê¸° ì¤‘ì´ë©´ ëª¨ë‘ ëŒ€ê¸° ìƒíƒœë¡œ ì´ˆê¸°í™”
          const resetSequences = sequences.map(seq => ({
            ...seq,
            status: 'waiting' as SequenceStatus,
            startTime: undefined,
            endTime: undefined,
            errorDetails: undefined
          }));
          
          // ì¼ê´„ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ ìƒíƒœë¥¼ í•œ ë²ˆì— ì„¤ì •
          setSelectedSequences(resetSequences);
          
          // ìƒíƒœê°€ ì‹¤í–‰ ì¤‘ì´ê±°ë‚˜ ì¼ì‹œì •ì§€ ìƒíƒœë©´ ëŒ€ê¸° ìƒíƒœë¡œ ì´ˆê¸°í™”
          if (state.status === 'running' || state.status === 'paused') {
            setStatus('waiting');
            setCurrentSequenceIndex(-1);
          } else {
            // ê·¸ ì™¸ ìƒíƒœëŠ” ì €ì¥ëœ ìƒíƒœ ê·¸ëŒ€ë¡œ ë³µì›
            setStatus(state.status || 'waiting');
            setCurrentSequenceIndex(state.currentSequenceIndex !== undefined ? state.currentSequenceIndex : -1);
          }
          
          // ë¡œê·¸ ë³µì› (ìµœëŒ€ 50ê°œ)
          if (Array.isArray(state.logs)) {
            setLogs(state.logs.slice(0, 50));
          }
          
          console.log('ì €ì¥ëœ ìë™í™” ê³µì • ìƒíƒœ ë³µì› ì™„ë£Œ');
        } else {
          console.log('ìœ íš¨í•œ ì‹œí€€ìŠ¤ ë°ì´í„°ê°€ ì—†ì–´ ì´ˆê¸° ìƒíƒœë¡œ ì„¤ì •');
          // ìœ íš¨í•œ ì‹œí€€ìŠ¤ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ì´ˆê¸° ìƒíƒœë¡œ ì„¤ì •
          setStatus('waiting');
          setSelectedSequences([]);
          setCurrentSequenceIndex(-1);
        }
      } else {
        console.log('ì €ì¥ëœ ìƒíƒœ ì—†ìŒ, ì´ˆê¸° ìƒíƒœë¡œ ì„¤ì •');
        setStatus('waiting');
      }
      
      // ì´ˆê¸° ë¡œë“œ í”Œë˜ê·¸ ì„¤ì •
      initialStateLoaded.current = true;
    } catch (error) {
      console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨:', error);
      // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì´ˆê¸° ìƒíƒœë¡œ ì„¤ì •
      setStatus('waiting');
      setSelectedSequences([]);
      setCurrentSequenceIndex(-1);
    } finally {
      // ì²˜ë¦¬ ì™„ë£Œ í”Œë˜ê·¸ í•´ì œ
      processingAction.current = false;
    }
  }, []);
  
  // resetAutomationRestore í•¨ìˆ˜ ê°•í™” (ì•½ 1975ì¤„ ê·¼ì²˜)
          onValueChange={(value) => {
            addSequence(value);
            // ì„ íƒëœ ê°’ì„ ìœ ì§€í•˜ì—¬ ë“œë¡­ë‹¤ìš´ì´ ê³„ì† ì—´ë ¤ìˆë„ë¡ í•¨
          }}
          disabled={false} // í•­ìƒ í™œì„±í™”
        >
          <SelectTrigger className="w-[200px]">
            <SelectValue placeholder="ì‘ì—…(extwork)" />
          </SelectTrigger>
          <SelectContent>
            {availableSequences.length > 0 ? (
              availableSequences.map((name) => (
                <SelectItem key={name} value={name}>
                  {name}
                </SelectItem>
              ))
            ) : (
              <div className="text-xs text-center py-2 text-gray-500">
                ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œí€€ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤
              </div>
            )}
          </SelectContent>
        </Select>
        
        <div className="flex-1"></div>
        
        <Button 
          variant="outline" 
          size="sm"
          onClick={() => setShowSaveDialog(true)}
          disabled={selectedSequences.length === 0} // ì‹œí€€ìŠ¤ê°€ ì—†ìœ¼ë©´ ë¹„í™œì„±í™”
          className="gap-1 bg-blue-50 border-blue-300 hover:bg-blue-100 min-w-[180px] h-10"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-5 w-5 text-blue-600">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
          </svg>
          <span className="font-semibold">Databaseì— ì €ì¥</span>
        </Button>
        
        <Button 
          variant="outline" 
          size="sm"
          onClick={() => setShowLoadDialog(true)}
          disabled={savedProcesses.length === 0} // ì €ì¥ëœ í”„ë¡œì„¸ìŠ¤ê°€ ì—†ìœ¼ë©´ ë¹„í™œì„±í™”
          className="gap-1 bg-green-50 border-green-300 hover:bg-green-100 min-w-[180px] h-10"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-5 w-5 text-green-600">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          <span className="font-semibold">Databaseì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°</span>
        </Button>
        
        <Button 
          variant="default" 
          size="sm"
          onClick={() => {
            if (selectedSequences.length > 0) {
              setStatus('running');
              executeSequence(0);
            }
          }}
          disabled={selectedSequences.length === 0} // ì‹œí€€ìŠ¤ê°€ ì—†ìœ¼ë©´ ë¹„í™œì„±í™”
          className="gap-1 min-w-[120px] h-10 bg-blue-600 hover:bg-blue-700"
        >
          <Play className="h-5 w-5" />
          <span className="font-semibold">ì¼ê´„ ì‹¤í–‰</span>
        </Button>
        
        <Button 
          onClick={enhancedResetAutomation}
          variant="outline"
          className="hidden sm:flex items-center gap-1 text-red-600 border-red-300 hover:text-red-700 hover:bg-red-50"
        >
          <Trash2 className="h-4 w-4" />
          <span>ë¦¬ì…‹</span>
        </Button>
        
        <Button 
          variant="outline" 
          size="sm"
                          onClick={() => setShowTimePopup(null)}
                        >
                          ì·¨ì†Œ
                        </Button>
                        <Button 
                          variant="default" 
                          size="sm"
                          onClick={() => saveTimePopup(index)}
                        >
                          ì €ì¥
                        </Button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>
      )}
      
      {/* ì§„í–‰ ì •ë³´ ì„¹ì…˜ */}
      <div className="p-2 bg-gray-50 rounded text-sm">
        <p className="font-medium mb-1">ì§„í–‰ ì •ë³´:</p>
        <div className="flex flex-col">
          {currentSequenceIndex >= 0 && currentSequenceIndex < selectedSequences.length && (
            <div className="text-xs font-semibold mb-1 text-blue-600">
              í˜„ì¬ ì‹œí€€ìŠ¤: {currentSequenceIndex + 1}/{selectedSequences.length} - {selectedSequences[currentSequenceIndex].sequence.name}
              {selectedSequences[currentSequenceIndex].status === 'running' ? ' (ì‹¤í–‰ì¤‘)' : 
               selectedSequences[currentSequenceIndex].status === 'completed' ? ' (ì™„ë£Œ)' : 
               selectedSequences[currentSequenceIndex].status === 'error' ? ' (ì˜¤ë¥˜)' : ' (ëŒ€ê¸°ì¤‘)'}
               
              {/* ëŒ€ê¸° ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ */}
              {selectedSequences[currentSequenceIndex].status === 'waiting' && 
                waitingCountdowns[currentSequenceIndex] > 0 && (
                <span className="ml-2 px-2 py-0.5 bg-amber-100 text-amber-800 rounded animate-pulse">
                  ëŒ€ê¸°ì¤‘: {waitingCountdowns[currentSequenceIndex]}ì´ˆ
                </span>
              )}
            </div>
          )}
          
          {/* ë‹¤ìŒ ì‹œí€€ìŠ¤ì˜ ëŒ€ê¸° ìƒíƒœ í‘œì‹œ */}
          {currentSequenceIndex >= 0 && 
           currentSequenceIndex + 1 < selectedSequences.length && 
           selectedSequences[currentSequenceIndex].status === 'running' && (
            <div className="text-xs text-gray-600 mb-1">
              ë‹¤ìŒ ì‹œí€€ìŠ¤: {selectedSequences[currentSequenceIndex + 1].sequence.name}
              {selectedSequences[currentSequenceIndex + 1].waitTime > 0 && (
                <span className="ml-2 text-amber-600">
                  (ëŒ€ê¸° ì‹œê°„: {selectedSequences[currentSequenceIndex + 1].waitTime}ì´ˆ)
                </span>
              )}
            </div>
          )}
          
          <div className="text-xs text-gray-500">
            {selectedSequences.filter(seq => seq.status === 'completed').length}ê°œ ì™„ë£Œ / 
            {selectedSequences.filter(seq => seq.status === 'running').length}ê°œ ì‹¤í–‰ì¤‘ / 
            {selectedSequences.filter(seq => seq.status === 'waiting').length}ê°œ ëŒ€ê¸°ì¤‘ /
            {selectedSequences.filter(seq => seq.status === 'error').length}ê°œ ì˜¤ë¥˜
            
            {/* ì „ì²´ ëŒ€ê¸° ì‹œê°„ ì •ë³´ */}
            {Object.keys(waitingCountdowns).length > 0 && (
              <div className="mt-1 text-amber-600">
                {Object.entries(waitingCountdowns).map(([index, countdown]) => (
                  <span key={index} className="mr-2">
                    {selectedSequences[parseInt(index)].sequence.name} ({countdown}ì´ˆ ëŒ€ê¸°ì¤‘)
                  </span>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
      
      {/* PROCESS_PROGRESS_TOPIC ë‚´ìš© ì¶œë ¥ */}
      <div className="p-2 bg-gray-100 rounded border border-gray-300 text-sm">
        <p className="font-medium mb-1 text-sm">ì§„í–‰ ìƒíƒœ (Topic: {PROCESS_PROGRESS_TOPIC}):</p>
        <div className="text-xs bg-white p-2 rounded h-20 overflow-y-auto font-mono">
          {progress ? (
            // ì•ˆì „í•˜ê²Œ ë©”ì‹œì§€ í‘œì‹œ - JSON ê°ì²´ì¸ ê²½ìš° ë¬¸ìì—´ë¡œ ë³€í™˜
            typeof progress === 'object' ? 
              JSON.stringify(progress) : 
              progress
          ) : 'ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ ëŒ€ê¸° ì¤‘...'}
        </div>
      </div>
      
      <div>
        <p className="font-medium mb-1 text-sm">ë¡œê·¸ ë©”ì‹œì§€:</p>
        <div className="p-2 bg-gray-50 rounded text-xs h-28 overflow-y-auto">
          {logMessages.length === 0 ? (
            <p className="text-gray-500">ë¡œê·¸ ì—†ìŒ</p>
          ) : (
            <ul className="space-y-1">
              {logMessages.map((msg, idx) => (
                <li key={idx}>{msg}</li>
              ))}
            </ul>
          )}
        </div>
      </div>
      
      {/* í ì»¨íŠ¸ë¡¤ ì„¹ì…˜ */}
      <Card>
        <CardHeader className="py-3">
          <CardTitle className="flex justify-between items-center">
            <span>Queue Control</span>
            <div className="text-sm font-medium">
              <span>Queue Status: {queueStatus ? `${queueStatus.count} items` : 'Unknown'}</span>
            </div>
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {/* í ì»¨íŠ¸ë¡¤ ë²„íŠ¼ */}
            <div className="flex gap-2 flex-wrap">
              <Button
                variant="outline"
                size="sm"
                onClick={resumeQueueProcessing}
                className="gap-1"
              >
                <Play className="h-4 w-4" />
                Resume
              </Button>
              
              <Button
                variant="outline"
                size="sm"
                onClick={pauseQueueProcessing}
                className="gap-1"
              >
                <Square className="h-4 w-4" />
                Pause
              </Button>

              <Button
                variant="outline"
                size="sm"
                onClick={listQueue}
                className="gap-1"
              >
                List
              </Button>
              
              <Button
                variant="outline"
                size="sm"
                onClick={removeAllQueueItems}
                className="gap-1"
              >
                Remove
              </Button>
              
              <Button
                variant="destructive"
                size="sm"
                onClick={clearQueue}
                className="gap-1 ml-auto"
              >
                <X className="h-4 w-4" />
                Clear Queue
              </Button>
            </div>

            {/* í ìƒíƒœ í…ìŠ¤íŠ¸ ë°•ìŠ¤ */}
            <div className="border rounded-md p-2">
              <div className="text-xs font-mono bg-black text-white p-2 rounded h-[160px] overflow-y-auto whitespace-pre">
                {queueStatus ? 
                  JSON.stringify(queueStatus, null, 2) : 
                  'Waiting for queue status...\n\nTopic: extwork/extraction/queue/status'}
              </div>
            </div>
            
            {/* í í•­ëª© ëª©ë¡ */}
            {queueStatus && queueStatus.items && queueStatus.items.length > 0 ? (
              <div className="border rounded-md">
                <div className="p-2 space-y-2 max-h-[200px] overflow-y-auto">
                  {queueStatus.items.map((item, index) => (
                    <div
                      key={item.id}
                      className="p-2 border rounded-md flex items-center justify-between bg-white"
                    >
                      <div className="flex-1">
                        <div className="flex justify-between items-center">
                          <div className="font-medium">
                            {index + 1}. {item.name}
                          </div>
                          <div className="text-xs text-gray-500">
                            {new Date(item.timestamp).toLocaleString()}
                          </div>
                        </div>
                      </div>
                      
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => removeQueueItem(item.id)}
                        className="h-8 w-8 p-0"
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    </div>
                  ))}
                </div>
              </div>
            ) : (
              <div className="text-center py-4 text-gray-500">
                {queueStatus ? 'No items in queue' : 'Loading queue status...'}
              </div>
            )}
            
            {/* ìˆ˜ë™ ëª…ë ¹ ë°œí–‰ */}
            <div className="border-t pt-3 mt-3">
              <p className="text-xs text-gray-500 mb-2">Manual Command (Topic: {EXTRACTION_INPUT_TOPIC})</p>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={manualCommand}
                  onChange={(e) => setManualCommand(e.target.value)}
                  placeholder="Enter command token"
                  maxLength={25}
                  className="flex-1 h-8 px-2 border rounded text-sm"
                />
                <Button
                  variant="outline"
                  size="sm"
                  onClick={publishManualCommand}
                  className="gap-1"
                >
                  Publish
                </Button>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
      
      {/* ìë™í™” ê³µì • ì €ì¥ ë‹¤ì´ì–¼ë¡œê·¸ */}
      <Dialog open={showSaveDialog} onOpenChange={setShowSaveDialog}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>ìë™í™” ê³µì • KV Databaseì— ì €ì¥</DialogTitle>
            <DialogDescription>
              í˜„ì¬ êµ¬ì„±ëœ ì‹œí€€ìŠ¤ë“¤ì„ ìë™í™” ê³µì •ìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="process-name" className="text-right">
                ê³µì • ì´ë¦„
              </Label>
              <Input
                id="process-name"
                placeholder="ìë™í™” ê³µì • ì´ë¦„ ì…ë ¥"
                value={processName}
                onChange={(e) => setProcessName(e.target.value)}
                className="col-span-3"
              />
            </div>
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="process-description" className="text-right">
                ì„¤ëª… (ì„ íƒ)
              </Label>
              <Input
                id="process-description"
                placeholder="ê³µì •ì— ëŒ€í•œ ì„¤ëª… (ì„ íƒì‚¬í•­)"
                value={processDescription}
                onChange={(e) => setProcessDescription(e.target.value)}
                className="col-span-3"
              />
            </div>
            <div className="px-1 py-2 text-sm">
              <span className="font-medium">í¬í•¨ëœ ì‹œí€€ìŠ¤:</span>
              <div className="mt-1 space-y-1 text-gray-500">
                {selectedSequences.map((seq, index) => (
                  <div key={seq.id}>
                    {index + 1}. {seq.sequence.name} (ë°˜ë³µ: {seq.customRepeats}íšŒ, ëŒ€ê¸°: {formatTime(seq.waitTime)})
                  </div>
                ))}
              </div>
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button type="button" variant="secondary">
                ì·¨ì†Œ
              </Button>
            </DialogClose>
            <Button type="submit" onClick={saveProcess} disabled={isLoading || !processName.trim() || selectedSequences.length === 0} className="bg-blue-600 hover:bg-blue-700">
              {isLoading ? (
                <div className="flex items-center">
                  <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  ì €ì¥ ì¤‘...
                </div>
              ) : (
                'ì €ì¥'
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* ìë™í™” ê³µì • ë¶ˆëŸ¬ì˜¤ê¸° ë‹¤ì´ì–¼ë¡œê·¸ */}
      <Dialog open={showLoadDialog} onOpenChange={setShowLoadDialog}>
        <DialogContent className="sm:max-w-[525px]">
          <DialogHeader>
            <DialogTitle>ìë™í™” ê³µì • KV Databaseì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°</DialogTitle>
            <DialogDescription>
              ì €ì¥ëœ ìë™í™” ê³µì • ëª©ë¡ì—ì„œ ë¶ˆëŸ¬ì˜¬ ê³µì •ì„ ì„ íƒí•˜ì„¸ìš”.
            </DialogDescription>
          </DialogHeader>
          <div className="py-4">
            {savedProcesses.length === 0 ? (
              <div className="text-center py-6 text-gray-500">
                ì €ì¥ëœ ìë™í™” ê³µì •ì´ ì—†ìŠµë‹ˆë‹¤.
              </div>
            ) : (
              <div className="space-y-3 max-h-[300px] overflow-y-auto pr-1">
                {savedProcesses.map((process) => (
                  <div
                    key={process.id}
                    className={`p-3 border rounded-md cursor-pointer ${
                      selectedProcessId === process.id ? 'border-blue-500 bg-blue-50' : 'border-gray-200'
                    }`}
                    onClick={() => setSelectedProcessId(process.id)}
                  >
                    <div className="flex justify-between items-start">
                      <div>
                        <div className="font-medium">{process.name}</div>
                        {process.description && (
                          <div className="text-xs text-gray-500 mt-1">{process.description}</div>
                        )}
                        <div className="text-xs text-gray-400 mt-1">
                          ì‹œí€€ìŠ¤: {process.sequences.length}ê°œ, 
                          ìƒì„±ì¼: {new Date(process.createdAt).toLocaleDateString()}
                        </div>
                      </div>
                      {selectedProcessId === process.id && (
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            setShowDeleteConfirm(true);
                          }}
                          className="h-7 w-7 p-0 text-red-500"
                        >
                          <X className="h-4 w-4" />
                        </Button>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button type="button" variant="secondary">
                ì·¨ì†Œ
              </Button>
            </DialogClose>
            <Button type="submit" onClick={loadProcess} disabled={isLoading || !selectedProcessId} className="bg-green-600 hover:bg-green-700">
              {isLoading ? (
                <div className="flex items-center">
                  <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
                </div>
              ) : (
                'ë¶ˆëŸ¬ì˜¤ê¸°'
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ */}
      <AlertDialog open={showDeleteConfirm} onOpenChange={setShowDeleteConfirm}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>ìë™í™” ê³µì • ì‚­ì œ</AlertDialogTitle>
            <AlertDialogDescription>
              ì •ë§ë¡œ ì´ ìë™í™” ê³µì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?
              ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ì·¨ì†Œ</AlertDialogCancel>
            <AlertDialogAction onClick={deleteProcess} className="bg-red-500 hover:bg-red-600">
              ì‚­ì œ
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
};

export default AutomationProcess; 