import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import MqttClient from '@/lib/mqtt-client';
import { 
  EXTRACTION_INPUT_TOPIC, 
  EXTRACTION_OUTPUT_TOPIC, 
  PROCESS_PROGRESS_TOPIC,
  AUTOMATION_CONTROL_TOPIC,
  AUTOMATION_STATUS_TOPIC,
  ERROR_TOPIC,
  QUEUE_STATUS_TOPIC
} from '@/lib/mqtt-topics';
import { Checkbox } from "@/app/components/ui/checkbox";
import { X, Play, Square, RotateCcw, ArrowUp, ArrowDown, PlusCircle } from 'lucide-react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { PumpSequence } from '../types/index';
import workLogService from '../services/work-log-service';
import { ScrollArea } from "@/app/components/ui/scroll-area";
import { Separator } from "@/app/components/ui/separator";
import { Input } from '@/components/ui/input';
import { v4 as uuidv4 } from 'uuid';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogClose } from "@/app/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { AlertDialog, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogCancel, AlertDialogAction } from "@/app/components/ui/alert-dialog";
import { toast } from "@/app/components/ui/use-toast";

// ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ í‚¤
const AUTOMATION_STATE_KEY = 'automation-process-state';
const AUTOMATION_SEQUENCES_KEY = 'automation-process-sequences';

type AutomationStatus = 'waiting' | 'running' | 'paused' | 'stopped' | 'completed' | 'error';
type SequenceStatus = 'waiting' | 'running' | 'completed' | 'error';

// í ì•„ì´í…œ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
interface QueueItem {
  id: string;
  name: string;
  timestamp: number;
  data: any;
}

// í ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
interface QueueStatus {
  isProcessing: boolean;
  count: number;
  items?: QueueItem[];
}

interface SequenceWithStatus {
  id: string;
  sequence: PumpSequence;
  status: SequenceStatus;
  waitTime: number;
  customRepeats: number;
  startTime?: number;
  endTime?: number;
  errorDetails?: string;
  currentRepeatCount?: number; // í˜„ì¬ ë°˜ë³µ íšŸìˆ˜ ì¹´ìš´íŠ¸ ì¶”ê°€
}

interface SavedProcess {
  id: string;
  name: string;
  description?: string;
  sequences: SequenceWithStatus[];
  createdAt: string;
  updatedAt: string;
}

interface AutomationProcessProps {
  mqttClient: MqttClient | null;
  savedSequences: PumpSequence[];
  onLockChange?: (locked: boolean) => void; // ìë™í™” ê³µì • ì ê¸ˆ ìƒíƒœ ë³€ê²½ ì½œë°±
}

// ì‹œí€€ìŠ¤ JSON í˜•ì‹ í‘œì¤€í™” í•¨ìˆ˜
const standardizeSequenceJson = (sequence: any): any => {
  // operation_mode ë³´ì¡´ í”Œë˜ê·¸: trueë¡œ ì„¤ì •í•˜ë©´ ì‹œí€€ìŠ¤ì˜ ì›ë³¸ operation_modeê°€ ë³´ì¡´ë©ë‹ˆë‹¤
  const preserveOriginalMode = true;
  
  // operation_mode ìœ íš¨ì„± ê²€ì‚¬ ë° í‘œì¤€í™”
  let operationMode = sequence.operation_mode;
  
  console.log(`[í‘œì¤€í™”] ì›ë³¸ ì‹œí€€ìŠ¤ operation_mode: ${operationMode}`);
  
  // ì›ë³¸ ëª¨ë“œë¥¼ ë³´ì¡´í•˜ëŠ” ê²½ìš°
  if (preserveOriginalMode) {
    // ì›ë³¸ ëª¨ë“œ ê°’ ìœ ì§€, í‘œì¤€í™”í•˜ì§€ ì•ŠìŒ
    console.log(`[í‘œì¤€í™”] ì›ë³¸ operation_mode ìœ ì§€: ${operationMode}`);
  } else {
    // ì›ë˜ì˜ í‘œì¤€í™” ë¡œì§
    const firstDigit = Math.floor(operationMode / 10);
    const secondDigit = operationMode % 10;
    
    console.log(`[í‘œì¤€í™”] ë¶„ì„: ì²«ì§¸ ìë¦¬(${firstDigit}), ë‘˜ì§¸ ìë¦¬(${secondDigit})`);
    
    // ì²« ë²ˆì§¸ ìë¦¬ê°€ 1ì¸ ê²½ìš° (ë™ì‹œ ëª¨ë“œ) -> ì›ë˜ëŠ” 12ë¡œ í‘œì¤€í™”í–ˆì§€ë§Œ 11(ë™ì‹œ+ì¶”ì¶œìˆœí™˜)ë„ ë³´ì¡´
    if (firstDigit === 1) {
      if (secondDigit === 1) {
        // 11(ë™ì‹œ+ì¶”ì¶œìˆœí™˜)ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ìœ ì§€
        console.log(`[í‘œì¤€í™”] ë™ì‹œ+ì¶”ì¶œìˆœí™˜(11) ëª¨ë“œ ë³´ì¡´`);
      } else {
        operationMode = 12;
        console.log(`[í‘œì¤€í™”] ë™ì‹œ ëª¨ë“œë¥¼ 12ë¡œ í‘œì¤€í™”`);
      }
    } 
    // ì²« ë²ˆì§¸ ìë¦¬ê°€ 2ì¸ ê²½ìš° (ìˆœì°¨ ëª¨ë“œ) -> 22ë¡œ í‘œì¤€í™”
    else if (firstDigit === 2) {
      operationMode = 22;
      console.log(`[í‘œì¤€í™”] ìˆœì°¨ ëª¨ë“œë¥¼ 22ë¡œ í‘œì¤€í™”`);
    }
    // ì²« ë²ˆì§¸ ìë¦¬ê°€ 3ì¸ ê²½ìš° -> 30ìœ¼ë¡œ í‘œì¤€í™”
    else if (firstDigit === 3) {
      operationMode = 30;
      console.log(`[í‘œì¤€í™”] ì¤‘ì²© ëª¨ë“œë¥¼ 30ìœ¼ë¡œ í‘œì¤€í™”`);
    }
    // ê·¸ ì™¸ì˜ ê²½ìš° ë‹¨ì¼ ìë¦¿ìˆ˜ëŠ” ë³´ì¡´ (íŠ¹íˆ 3ì€ ê·¸ëŒ€ë¡œ ìœ ì§€)
    else {
      // ë‹¨ì¼ ìë¦¿ìˆ˜ ëª¨ë“œëŠ” ë³´ì¡´
      console.log(`[í‘œì¤€í™”] ë‹¨ì¼ ìë¦¿ìˆ˜ ëª¨ë“œ ë³´ì¡´: ${operationMode}`);
    }
  }
  
  // í”„ë¡œì„¸ìŠ¤ ë°°ì—´ í‘œì¤€í™” - ìœ íš¨í•˜ì§€ ì•Šì€ ê°’ë§Œ ì²˜ë¦¬
  let processArray = [...sequence.process];
  
  console.log(`[í‘œì¤€í™”] ì›ë³¸ í”„ë¡œì„¸ìŠ¤ ë°°ì—´: [${processArray.join(', ')}], ê¸¸ì´: ${processArray.length}`);
  
  // í”„ë¡œì„¸ìŠ¤ ë°°ì—´ì— ìœ íš¨í•˜ì§€ ì•Šì€ ê°’(7, 8, 9)ì´ ìˆìœ¼ë©´ ìœ íš¨í•œ ê°’(0, 5, 6, 10)ìœ¼ë¡œ ë³€í™˜
  processArray = processArray.map((value: number) => {
    if (value === 7 || value === 8 || value === 9) {
      return 6; // ìœ íš¨í•œ ê°’ìœ¼ë¡œ ëŒ€ì²´
    }
    return value;
  });
  
  // ì›ë³¸ ëª¨ë“œë¥¼ ë³´ì¡´í•˜ëŠ” ê²½ìš° í”„ë¡œì„¸ìŠ¤ ë°°ì—´ë„ ë³´ì¡´
  if (preserveOriginalMode) {
    // í”„ë¡œì„¸ìŠ¤ ë°°ì—´ ê·¸ëŒ€ë¡œ ìœ ì§€
    console.log(`[í‘œì¤€í™”] ì›ë³¸ í”„ë¡œì„¸ìŠ¤ ë°°ì—´ ìœ ì§€: [${processArray.length > 10 ? processArray.slice(0, 10).join(', ') + '...' : processArray.join(', ')}], ê¸¸ì´: ${processArray.length}`);
  } else {
    // ëª¨ë“œë³„ë¡œ ì ì ˆí•œ process ë°°ì—´ ê¸¸ì´ì™€ íŒ¨í„´ í™•ë³´
    if (operationMode === 11 || operationMode === 12) { // ë™ì‹œ ëª¨ë“œ (11: ë™ì‹œ+ì¶”ì¶œìˆœí™˜, 12: ë™ì‹œ+ì „ì²´ìˆœí™˜)
      // í”„ë¡œì„¸ìŠ¤ ê¸¸ì´ê°€ 6ì˜ ë°°ìˆ˜ê°€ ë˜ë„ë¡ ì¡°ì •
      while (processArray.length % 6 !== 0) {
        processArray.push(0);
      }
      console.log(`[í‘œì¤€í™”] ë™ì‹œ ëª¨ë“œ(${operationMode}) í”„ë¡œì„¸ìŠ¤ ê¸¸ì´ ì¡°ì •: ${processArray.length}`);
    } else if (operationMode === 22) { // ìˆœì°¨ ëª¨ë“œ
      // í”„ë¡œì„¸ìŠ¤ ê¸¸ì´ê°€ 3ì˜ ë°°ìˆ˜ê°€ ë˜ë„ë¡ ì¡°ì •
      while (processArray.length % 3 !== 0) {
        processArray.push(0);
      }
      
      // ê° ê·¸ë£¹ì´ [6, 5, 0] íŒ¨í„´ìœ¼ë¡œ í‘œì¤€í™”
      const standardizedProcess = [];
      for (let i = 0; i < processArray.length; i += 3) {
        standardizedProcess.push(6);
        standardizedProcess.push(5);
        standardizedProcess.push(0);
      }
      processArray = standardizedProcess;
      console.log(`[í‘œì¤€í™”] ìˆœì°¨ ëª¨ë“œ í”„ë¡œì„¸ìŠ¤ í‘œì¤€í™”: [${processArray.length > 10 ? processArray.slice(0, 10).join(', ') + '...' : processArray.join(', ')}], ê¸¸ì´: ${processArray.length}`);
    } else if (operationMode === 30) { // í˜¼í•© ëª¨ë“œ
      // í”„ë¡œì„¸ìŠ¤ ê¸¸ì´ê°€ ì§ìˆ˜ê°€ ë˜ë„ë¡ ì¡°ì •
      if (processArray.length % 2 !== 0) {
        processArray.push(0);
      }
      
      // êµì°¨ íŒ¨í„´(10, 5, ...)ìœ¼ë¡œ í‘œì¤€í™”
      const standardizedProcess = [];
      for (let i = 0; i < processArray.length; i += 2) {
        standardizedProcess.push(10);
        standardizedProcess.push(5);
      }
      processArray = standardizedProcess;
      console.log(`[í‘œì¤€í™”] í˜¼í•© ëª¨ë“œ í”„ë¡œì„¸ìŠ¤ í‘œì¤€í™”: [${processArray.length > 10 ? processArray.slice(0, 10).join(', ') + '...' : processArray.join(', ')}], ê¸¸ì´: ${processArray.length}`);
    }
  }
  
  // í‘œì¤€í™”ëœ ì‹œí€€ìŠ¤ ê°ì²´ ìƒì„±
  const standardizedSeq: any = {
    ...sequence,
    operation_mode: operationMode,
    process: processArray
  };
  
  // wait_timeì€ operation_modeê°€ 22(ìˆœì°¨ ëª¨ë“œ)ê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì¶”ê°€
  if (operationMode === 22) {
    delete standardizedSeq.wait_time;
  }
  
  console.log(`[í‘œì¤€í™”] ìµœì¢… ì‹œí€€ìŠ¤ operation_mode: ${standardizedSeq.operation_mode}, í”„ë¡œì„¸ìŠ¤ ê¸¸ì´: ${standardizedSeq.process.length}`);
  
  return standardizedSeq;
};

// UI ìƒíƒœ ë³€ê²½ ìµœì í™”ë¥¼ ìœ„í•œ ë””ë°”ìš´ìŠ¤ í•¨ìˆ˜ ì •ì˜
const debounce = (func: Function, wait: number) => {
  let timeout: NodeJS.Timeout | null = null;
  return (...args: any[]) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
};

const AutomationProcess: React.FC<AutomationProcessProps> = ({ 
  mqttClient, 
  savedSequences,
  onLockChange 
}) => {
  // ìƒíƒœ ê´€ë¦¬ ìµœì í™”ë¥¼ ìœ„í•œ useRef ì¶”ê°€
  const prevStatus = useRef<AutomationStatus>('waiting');
  const processingAction = useRef<boolean>(false);
  const pendingUpdates = useRef<{type: string, data: any}[]>([]);
  // í˜„ì¬ ìë™í™” ì‹¤í–‰ ìƒíƒœë¥¼ ì¶”ì í•˜ëŠ” ref ì¶”ê°€
  const automationRunningRef = useRef<boolean>(false);
  
  const [status, setStatus] = useState<AutomationStatus>('waiting');
  const [selectedSequences, setSelectedSequences] = useState<SequenceWithStatus[]>([]);
  const [availableSequences, setAvailableSequences] = useState<string[]>([]);
  const [selectedSequenceName, setSelectedSequenceName] = useState<string>('');
  const [currentSequenceIndex, setCurrentSequenceIndex] = useState<number>(-1);
  // ë¡œê·¸ ìƒíƒœ íƒ€ì… ìˆ˜ì •
  type LogEntry = string | { id: string; message: string; timestamp: number; type: "info" };
  const [logs, setLogs] = useState<LogEntry[]>([]);
  const [logMessages, setLogMessages] = useState<string[]>([]);
  const [progress, setProgress] = useState<string>('ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.');
  const [queueItems, setQueueItems] = useState<QueueItem[]>([]);
  const [queueStatus, setQueueStatus] = useState<QueueStatus>({ 
    isProcessing: false, 
    count: 0 
  });
  const [waitingCountdowns, setWaitingCountdowns] = useState<{[key: number]: number}>({});
  const [showTimePopup, setShowTimePopup] = useState<number | null>(null);
  const [tempHours, setTempHours] = useState(0);
  const [tempMinutes, setTempMinutes] = useState(0);
  const [tempSeconds, setTempSeconds] = useState(0);
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [showLoadDialog, setShowLoadDialog] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [processName, setProcessName] = useState('');
  const [processDescription, setProcessDescription] = useState('');
  const [savedProcesses, setSavedProcesses] = useState<SavedProcess[]>([]);
  const [selectedProcessId, setSelectedProcessId] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const [alertOpen, setAlertOpen] = useState(false);
  const [manualCommand, setManualCommand] = useState('');
  const [showManualCommandDialog, setShowManualCommandDialog] = useState(false);
  const [countdownIntervals, setCountdownIntervals] = useState<{[key: string]: NodeJS.Timeout}>({});
  
  // ì¶”ê°€ ë³€ìˆ˜ ì •ì˜
  const [currentSequenceId, setCurrentSequenceId] = useState('');
  const [serverBusy, setServerBusy] = useState(false);
  const processingRef = useRef<boolean>(false);
  const countdownTimersRef = useRef<{[key: string]: NodeJS.Timeout}>({});
  
  // íŒì—… ìœ„ì¹˜ ìƒíƒœ ì¶”ê°€
  const [popupPosition, setPopupPosition] = useState({ x: window.innerWidth / 2 - 150, y: window.innerHeight / 2 - 100 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const popupRef = useRef<HTMLDivElement>(null);
  
  // ìƒíƒœ ë³€ê²½ ìµœì í™” í•¨ìˆ˜
  const safeUpdateState = <T extends unknown>(
    stateSetter: React.Dispatch<React.SetStateAction<T>>,
    value: T | ((prev: T) => T),
    stateType: string
  ) => {
    if (processingAction.current) {
      // ì²˜ë¦¬ ì¤‘ì¼ ë•ŒëŠ” ì—…ë°ì´íŠ¸ë¥¼ ëŒ€ê¸°ì—´ì— ë„£ìŒ
      pendingUpdates.current.push({ type: stateType, data: value });
      return;
    }
    
    stateSetter(value);
  };
  
  // ëŒ€ê¸° ì¤‘ì¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
  const processPendingUpdates = useCallback(() => {
    if (pendingUpdates.current.length === 0) return;
    
    processingAction.current = true;
    
    // ê° ì—…ë°ì´íŠ¸ ìœ í˜•ë³„ë¡œ ë§ˆì§€ë§‰ í•­ëª©ë§Œ ì ìš©
    const uniqueUpdates = pendingUpdates.current.reduce((acc, update) => {
      acc[update.type] = update.data;
      return acc;
    }, {} as Record<string, any>);
    
    // ì—…ë°ì´íŠ¸ ì ìš©
    Object.entries(uniqueUpdates).forEach(([type, data]) => {
      switch (type) {
        case 'status':
          setStatus(typeof data === 'function' ? data(status) : data);
          break;
        case 'selectedSequences':
          setSelectedSequences(typeof data === 'function' ? data(selectedSequences) : data);
          break;
        case 'currentSequenceIndex':
          setCurrentSequenceIndex(typeof data === 'function' ? data(currentSequenceIndex) : data);
          break;
        case 'logs':
          setLogs(typeof data === 'function' ? data(logs) : data);
          break;
        case 'queueItems':
          setQueueItems(typeof data === 'function' ? data(queueItems) : data);
          break;
        case 'queueStatus':
          setQueueStatus(typeof data === 'function' ? data(queueStatus) : data);
          break;
        default:
          break;
      }
    });
    
    pendingUpdates.current = [];
    processingAction.current = false;
  }, [status, selectedSequences, currentSequenceIndex, logs, queueItems, queueStatus]);
  
  // ì£¼ê¸°ì ìœ¼ë¡œ ëŒ€ê¸° ì¤‘ì¸ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
  useEffect(() => {
    const interval = setInterval(() => {
      if (!processingAction.current && pendingUpdates.current.length > 0) {
        processPendingUpdates();
      }
    }, 50); // 50ms ê°„ê²©ìœ¼ë¡œ í™•ì¸
    
    return () => clearInterval(interval);
  }, [processPendingUpdates]);

  // status ìƒíƒœê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ref ì—…ë°ì´íŠ¸
  useEffect(() => {
    // automationRunningRef ì—…ë°ì´íŠ¸
    automationRunningRef.current = status === 'running';

    // ê¸°ì¡´ ì½”ë“œ ìœ ì§€
    if (prevStatus.current !== status) {
      prevStatus.current = status;
      
      // ìƒíƒœ ë³€ê²½ ì‹œ ìë™í™” ê³µì • ì ê¸ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
      if (onLockChange) {
        onLockChange(status === 'running' || status === 'paused');
      }
      
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìƒíƒœ ì €ì¥
      if (typeof window !== 'undefined') {
        try {
          localStorage.setItem(AUTOMATION_STATE_KEY, JSON.stringify({
            status,
            currentSequenceIndex,
            selectedSequences
          }));
        } catch (error) {
          console.error('ìƒíƒœ ì €ì¥ ì¤‘ ì˜¤ë¥˜:', error);
        }
      }
    }
  }, [status, currentSequenceIndex, selectedSequences, onLockChange]);

  // MQTT ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ìµœì í™” - ë””ë°”ìš´ìŠ¤ ì ìš©
  const debouncedHandleMessage = useCallback(
    debounce((topic: string, message: Buffer) => {
      try {
        // ê¸°ì¡´ handleMessage ì½”ë“œ ë‚´ìš© ìœ ì§€
        // ...
      } catch (error) {
        console.error('MQTT ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
      }
    }, 50), // 50ms ë””ë°”ìš´ìŠ¤
    []
  );

  // updateSequenceStatus ìµœì í™”
  const updateSequenceStatus = (index: number, newStatus: SequenceStatus) => {
    if (index < 0 || index >= selectedSequences.length) return;
    
    processingAction.current = true;
    setSelectedSequences(prev => {
      const updated = [...prev];
      updated[index] = {
        ...updated[index],
        status: newStatus,
        ...(newStatus === 'running' && { startTime: Date.now() }),
        ...(newStatus === 'completed' && { endTime: Date.now() })
      };
      return updated;
    });
    processingAction.current = false;
  };

  // addSequence ìµœì í™” ë° ì €ì¥ ë¡œì§ ê°•í™”
  const addSequence = (sequenceName: string) => {
    // ëª¨ë“  ë™ì¼í•œ ì´ë¦„ì˜ ì‹œí€€ìŠ¤ë¥¼ ì°¾ë„ë¡ findì—ì„œ filterë¡œ ë³€ê²½
    const sequences = savedSequences.filter(seq => seq.name === sequenceName);
    if (sequences.length === 0) {
      console.log(`'${sequenceName}' ì´ë¦„ì˜ ì‹œí€€ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
      return;
    }
    
    console.log(`ì‹œí€€ìŠ¤ ì¶”ê°€: ${sequenceName} (${sequences.length}ê°œ ë°œê²¬)`);
    
    processingAction.current = true;
    
    // ê° ì‹œí€€ìŠ¤ë¥¼ ë…ë¦½ì ì¸ í•­ëª©ìœ¼ë¡œ ì¶”ê°€
    const newSequences = sequences.map(sequence => ({
      id: uuidv4(),
      sequence,
      status: 'waiting' as SequenceStatus,
      waitTime: 0,
      customRepeats: sequence.repeats || 1
    }));
    
    // ì‹œí€€ìŠ¤ ë°°ì—´ ì—…ë°ì´íŠ¸
    setSelectedSequences(prev => {
      const updatedSequences = [...prev, ...newSequences];
      
      // ì¦‰ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
      try {
        localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify(updatedSequences));
        console.log(`${sequenceName} ì´ë¦„ì˜ ì‹œí€€ìŠ¤ ${newSequences.length}ê°œ ì¶”ê°€ ë° ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ ì™„ë£Œ`);
      } catch (error) {
        console.error('ì‹œí€€ìŠ¤ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì €ì¥ ì‹¤íŒ¨:', error);
      }
      
      return updatedSequences;
    });
    
    // ë¡œê·¸ì— ì¶”ê°€
    addLog(`ì‹œí€€ìŠ¤ '${sequenceName}' ${newSequences.length}ê°œ ì¶”ê°€ë¨`);
    
    processingAction.current = false;
  };

  // resetAutomation í•¨ìˆ˜ ìˆ˜ì • - automationRunningRef ì—…ë°ì´íŠ¸ ì¶”ê°€
  const resetAutomation = () => {
    // ì‘ì—… ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ ì„¤ì •
    processingAction.current = true;
    console.log('ìë™í™” ê³µì • ë¦¬ì…‹ ì‹œì‘ - ëª¨ë“  ì‹¤í–‰ ì¤‘ì§€ ë° ìƒíƒœ ì´ˆê¸°í™”');
    
    // automationRunningRef ìƒíƒœ ì—…ë°ì´íŠ¸
    automationRunningRef.current = false;
    
    // ì‹¤í–‰ ì¤‘ì¸ ì¹´ìš´íŠ¸ë‹¤ìš´ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ëª¨ë‘ ì •ë¦¬
    Object.values(countdownIntervals).forEach(interval => {
      clearInterval(interval);
    });
    
    // ê°•ì œ ì¤‘ì§€ ë©”ì‹œì§€ ë°œí–‰ - ì‹¤í–‰ ì¤‘ì¸ ê³µì • ì¦‰ì‹œ ì¤‘ì§€
    if (mqttClient) {
      try {
        // ë¨¼ì € ê°•ì œ ì¤‘ì§€ ë©”ì‹œì§€ ë°œí–‰
        mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
          action: 'force_stop',
          message: 'ì‚¬ìš©ìê°€ ë¦¬ì…‹ ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ëª¨ë“  ê³µì •ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.'
        }));
        
        // ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ ì „ì†¡
        mqttClient.publish(PROCESS_PROGRESS_TOPIC, JSON.stringify({
          status: 'stopped',
          message: 'ì‚¬ìš©ìê°€ ë¦¬ì…‹ ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ëª¨ë“  ê³µì •ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.'
        }));
        
        console.log('ê°•ì œ ì¤‘ì§€ ë©”ì‹œì§€ ë°œí–‰ ì™„ë£Œ');
      } catch (error) {
        console.error('MQTT ë©”ì‹œì§€ ë°œí–‰ ì¤‘ ì˜¤ë¥˜:', error);
      }
    }
    
    // ìƒíƒœ ì´ˆê¸°í™” (ì„ íƒí•œ ì‹œí€€ìŠ¤ëŠ” ìœ ì§€)
    setStatus('waiting');
    setCurrentSequenceIndex(-1);
    setWaitingCountdowns({});
    setCountdownIntervals({});
    
    // ëª¨ë“  ì‹œí€€ìŠ¤ì˜ ìƒíƒœë¥¼ 'waiting'ìœ¼ë¡œ ì´ˆê¸°í™”
    setSelectedSequences(prev => prev.map(seq => ({
      ...seq,
      status: 'waiting',
      startTime: undefined,
      endTime: undefined,
      errorDetails: undefined
    })));
    
    // ì•½ê°„ì˜ ì§€ì—° í›„ í ì´ˆê¸°í™” (ì¤‘ì§€ ë©”ì‹œì§€ê°€ ì²˜ë¦¬ë  ì‹œê°„ í™•ë³´)
    setTimeout(() => {
      // í ì´ˆê¸°í™”
      if (mqttClient) {
        try {
          mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
            action: 'clear_all'
          }));
          console.log('í ì´ˆê¸°í™” ë©”ì‹œì§€ ë°œí–‰ ì™„ë£Œ');
        } catch (error) {
          console.error('MQTT ë©”ì‹œì§€ ë°œí–‰ ì¤‘ ì˜¤ë¥˜:', error);
        }
      }
      
      processingAction.current = false;
      
      toast({
        title: "ë¦¬ì…‹ ì™„ë£Œ",
        description: "ê³µì • ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì¼ê´„ ì‹¤í–‰ ë²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
      });
    }, 500); // 0.5ì´ˆ ì§€ì—°
  };

  // ì™„ì „ ì´ˆê¸°í™” í•¨ìˆ˜ ìˆ˜ì • - automationRunningRef ì—…ë°ì´íŠ¸ ì¶”ê°€
  const fullReset = () => {
    console.log('ìë™í™” ê³µì • ì™„ì „ ì´ˆê¸°í™” ì‹œì‘ - ëª¨ë“  ì„¤ì • ì´ˆê¸°í™”');
    
    // ëª¨ë“  êµ¬ë… ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¼ì‹œ ì¤‘ì§€
    if (mqttClient) {
      // ëª¨ë“  ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì¼ì‹œ ì¤‘ì§€ - ë‘ ë²ˆì§¸ íŒŒë¼ë¯¸í„°ë¥¼ ìƒëµí•˜ë©´ ëª¨ë“  í•¸ë“¤ëŸ¬ê°€ ì œê±°ë¨
      mqttClient.off("message", function() {});
    }
    
    // ì™„ì „ ì´ˆê¸°í™”ëŠ” ë‹¤ë¥¸ ëª¨ë“  ì²˜ë¦¬ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ë¯€ë¡œ processingAction í”Œë˜ê·¸ ì„¤ì •
    processingAction.current = true;
    
    // automationRunningRef ìƒíƒœ ì—…ë°ì´íŠ¸
    automationRunningRef.current = false;
    
    // ì‹¤í–‰ ì¤‘ì¸ ì¹´ìš´íŠ¸ë‹¤ìš´ íƒ€ì´ë¨¸ê°€ ìˆìœ¼ë©´ ëª¨ë‘ ì •ë¦¬
    Object.values(countdownIntervals).forEach(interval => {
      if (interval) {
        clearInterval(interval);
        clearTimeout(interval);
      }
    });
    
    // ëª¨ë“  ì¶”ê°€ íƒ€ì´ë¨¸ë„ ì œê±°
    for (let i = 0; i < 100; i++) {
      clearTimeout(i);
      clearInterval(i);
    }
    
    // ê°•ì œ ì¤‘ì§€ ë©”ì‹œì§€ ë°œí–‰ - ëª¨ë“  ì—ëŸ¬ì™€ ë¬´í•œ ë£¨í”„ ìƒíƒœì—ì„œë„ íƒˆì¶œ
    if (mqttClient) {
      try {
        // ë¨¼ì € ê°€ì¥ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ê°•ì œ ì¤‘ì§€ ë©”ì‹œì§€ ë°œí–‰
        mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
          action: 'force_stop',
          priority: 'highest',
          message: 'ì‚¬ìš©ìê°€ ì™„ì „ ì´ˆê¸°í™” ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ëª¨ë“  ê³µì •ì´ ê°•ì œ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.',
          timestamp: Date.now()
        }));
        
        // ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ ì „ì†¡
        mqttClient.publish(PROCESS_PROGRESS_TOPIC, JSON.stringify({
          status: 'reset',
          message: 'ì‚¬ìš©ìê°€ ì™„ì „ ì´ˆê¸°í™” ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ëª¨ë“  ê³µì •ì´ ê°•ì œ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.',
          timestamp: Date.now()
        }));
        
        // ì•½ê°„ì˜ ì§€ì—° í›„ í ì´ˆê¸°í™” ë©”ì‹œì§€ ë°œí–‰
        setTimeout(() => {
          mqttClient.publish(AUTOMATION_CONTROL_TOPIC, JSON.stringify({
            action: 'clear_all',
            priority: 'highest',
            timestamp: Date.now()
          }));
          
          console.log('í ì´ˆê¸°í™” ë©”ì‹œì§€ ë°œí–‰ ì™„ë£Œ');
        }, 300);
        
        console.log('ê°•ì œ ì¤‘ì§€ ë° ì´ˆê¸°í™” ë©”ì‹œì§€ ë°œí–‰ ì™„ë£Œ');
      } catch (error) {
        console.error('MQTT ë©”ì‹œì§€ ë°œí–‰ ì¤‘ ì˜¤ë¥˜:', error);
      }
    }
    
    // ìƒíƒœ ì´ˆê¸°í™”
    setStatus('waiting');
    setSelectedSequences([]);
    setCurrentSequenceIndex(-1);
    setLogs([]);
    setLogMessages([]);
    setWaitingCountdowns({});
    setShowTimePopup(null);
    setTempHours(0);
    setTempMinutes(0);
    setTempSeconds(0);
    setCountdownIntervals({});
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°ì´í„° ì™„ì „ ì œê±°
    if (typeof window !== 'undefined') {
      try {
        // ìë™í™” ê³µì • ê´€ë ¨ ëª¨ë“  í‚¤ ì œê±°
        localStorage.removeItem(AUTOMATION_STATE_KEY);
        localStorage.removeItem(AUTOMATION_SEQUENCES_KEY);
        
        // ì¶”ê°€ì ì¸ ê´€ë ¨ í‚¤ë„ ì‚­ì œ
        localStorage.removeItem('process-running-state');
        localStorage.removeItem('automation-last-state');
        localStorage.removeItem('automation-logs');
        
        console.log('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìë™í™” ê³µì • ë°ì´í„° ì™„ì „ ì œê±° ì™„ë£Œ');
      } catch (error) {
        console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°ì´í„° ì‚­ì œ ì¤‘ ì˜¤ë¥˜:', error);
      }
    }
    
    // ì•½ê°„ì˜ ì§€ì—° í›„ ì´ˆê¸°í™” ì™„ë£Œ ì²˜ë¦¬
    setTimeout(() => {
      // ì›¹ ìŠ¤í† ë¦¬ì§€ ì´ë²¤íŠ¸ ë°œìƒ ì‹œí‚¤ê¸° (ë‹¤ë¥¸ íƒ­ì— ì•Œë¦¼)
      if (typeof window !== 'undefined') {
        try {
          // ì™„ì „ ì´ˆê¸°í™”ë¥¼ ì•Œë¦¬ëŠ” ì´ë²¤íŠ¸ ë°œìƒ
          window.dispatchEvent(new StorageEvent('storage', {
            key: 'automation-force-reset',
            newValue: JSON.stringify({ 
              timestamp: Date.now(),
              action: 'force_reset_complete'
            })
          }));
          
          // ì²˜ë¦¬ ì™„ë£Œ í”Œë˜ê·¸ í•´ì œ
          processingAction.current = false;
          
          // MQTT ì¬ì—°ê²° ë° ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë³µì›
          if (mqttClient) {
            // MQTT êµ¬ë… ë³µì› - êµ¬ë…ì´ ë¨¼ì € í•„ìš”í•¨
            mqttClient.subscribe(EXTRACTION_OUTPUT_TOPIC);
            mqttClient.subscribe(PROCESS_PROGRESS_TOPIC);
          }
          
          // ì´ˆê¸°í™” ì™„ë£Œ í† ìŠ¤íŠ¸ í‘œì‹œ
          toast({
            title: "ì™„ì „ ì´ˆê¸°í™” ì™„ë£Œ",
            description: "ëª¨ë“  ì„¤ì •ê³¼ ê³µì • ìƒíƒœê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹œí€€ìŠ¤ë¥¼ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì„¤ì •í•˜ì„¸ìš”.",
          });
          
          // ìƒˆë¡œê³ ì¹¨ ê¶Œì¥ ì•Œë¦¼ ì¶”ê°€
          toast({
            title: "í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ ê¶Œì¥",
            description: "ì™„ì „í•œ ì´ˆê¸°í™”ë¥¼ ìœ„í•´ í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.",
            variant: "destructive"
          });
          
          console.log('ì™„ì „ ì´ˆê¸°í™” ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë¨');
        } catch (e) {
          console.error('ì™„ì „ ì´ˆê¸°í™” ì™„ë£Œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', e);
          processingAction.current = false;
        }
      }
    }, 1000);
  };
  
  // ì‹œí€€ìŠ¤ ì¶”ê°€/ì‚­ì œ ìµœì í™” - ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì €ì¥ ë””ë°”ìš´ìŠ¤
  const debouncedSaveSequences = useCallback(
    debounce((sequences: SequenceWithStatus[]) => {
      if (typeof window !== 'undefined') {
        try {
          localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify(sequences));
        } catch (error) {
          console.error('ì‹œí€€ìŠ¤ ì €ì¥ ì¤‘ ì˜¤ë¥˜:', error);
        }
      }
    }, 300), // 300ms ë””ë°”ìš´ìŠ¤
    []
  );
  
  // ì„ íƒëœ ì‹œí€€ìŠ¤ ë³€ê²½ ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì—…ë°ì´íŠ¸
  useEffect(() => {
    debouncedSaveSequences(selectedSequences);
  }, [selectedSequences, debouncedSaveSequences]);
  
  useEffect(() => {
    if (!mqttClient) return;
    
    console.log('MQTT í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì„¤ì • ì¤‘...');
    
    // MQTT ë©”ì‹œì§€ ì²˜ë¦¬
    const messageHandler = (topic: string, message: Buffer) => {
      try {
        const messageStr = message.toString();
        
        // í•„ìˆ˜ í† í”½ë§Œ ë¡œê·¸ì— ì¶œë ¥
        if (topic === EXTRACTION_INPUT_TOPIC) {
          console.log(`ğŸ“¤ [INPUT] ${messageStr.substring(0, 100)}...`);
        } 
        else if (topic === EXTRACTION_OUTPUT_TOPIC) {
          console.log(`ğŸ“¥ [OUTPUT] ${messageStr}`);
          // addLog ëŒ€ì‹  ì§ì ‘ ë¡œê·¸ ê°ì²´ ìƒì„±
          const newLog = {
            id: `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
            message: `OUTPUT: ${messageStr}`,
            timestamp: Date.now(),
            type: 'info' as const
          };
          setLogs(prevLogs => [...prevLogs, newLog].slice(-100));
          
          // í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ì²˜ë¦¬
          addLog(`ìƒíƒœ ë©”ì‹œì§€ ìˆ˜ì‹ : ${messageStr}`, true);
            
          // ê³µì • ì¢…ë£Œ ë©”ì‹œì§€ ê°ì§€ - í‚¤ì›Œë“œ í™•ì¥ ë° ë¡œê¹… ê°•í™”
          console.log(`ì¢…ë£Œ ë©”ì‹œì§€ ê°ì§€ ì‹œë„: ${messageStr}`);
          const isCompletionMessage = messageStr.toLowerCase().includes('ê³µì • ì¢…ë£Œ') || 
                                    messageStr.toLowerCase().includes('ê³µì •ì¢…ë£Œ');
          
          // ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€ë˜ë©´ ê°•ì œ ì‹œí€€ìŠ¤ ì „í™˜ ì‹¤í–‰
          if (isCompletionMessage) {
            console.log(`ğŸš¨ ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€: "${messageStr}"`);
            forceProgressToNextSequence();
            return;
          } else if (messageStr.includes("JSON ëª…ë ¹ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤")) {
            // JSON ëª…ë ¹ ì„±ê³µ ë©”ì‹œì§€ - ì‹œí€€ìŠ¤ ì‹œì‘ì„ ì•Œë¦¼
            addLog(`ì‹œí€€ìŠ¤ ëª…ë ¹ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.`, true);
          }
        }
        else if (topic === PROCESS_PROGRESS_TOPIC) {
          console.log(`ğŸ“Š [PROGRESS] ${messageStr}`);
          
          // ë©”ì‹œì§€ í¬ê¸° ì œí•œ ì²˜ë¦¬ (10000ì ì´ìƒì¸ ê²½ìš° ì¶•ì•½)
          let displayMessage = messageStr;
          if (displayMessage && displayMessage.length > 10000) {
            console.warn(`ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤: ${displayMessage.length} ë°”ì´íŠ¸. ì˜ë¼ëƒ…ë‹ˆë‹¤.`);
            displayMessage = displayMessage.substring(0, 10000) + "... (ë©”ì‹œì§€ í¬ê¸° ì´ˆê³¼ë¡œ ì˜ë¦¼)`);
          }
          
          // ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ ì €ì¥
          setProgress(displayMessage);
          
          // ë¡œê·¸ ê°ì²´ ì¶”ê°€ (logsëŠ” ë¡œê·¸ ê°ì²´ ë°°ì—´)
          const newLog = {
            id: `log_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
            message: `PROGRESS: ${displayMessage.substring(0, 100)}${displayMessage.length > 100 ? '...' : ''}`,
            timestamp: Date.now(),
            type: 'info' as const
          };
          setLogs(prevLogs => [...prevLogs, newLog].slice(-100));
          
          // ë¡œê·¸ ë©”ì‹œì§€ ì¶”ê°€ (logMessagesëŠ” ë¬¸ìì—´ ë°°ì—´)
          setLogMessages(prev => {
            const newMessage = `[${new Date().toLocaleTimeString()}] ì§„í–‰ ìƒíƒœ: ${displayMessage.substring(0, 50)}${displayMessage.length > 50 ? '...' : ''}`;
            return [newMessage, ...prev].slice(0, 100); // ìµœëŒ€ 100ê°œë§Œ ìœ ì§€
          });
          
          // JSON ë°ì´í„° ì²˜ë¦¬ (ì‹œí€€ìŠ¤ ì™„ë£Œ ê°ì§€)
          try {
            const data = JSON.parse(messageStr);
            
            // ì§„í–‰ ìƒíƒœ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹œí€€ìŠ¤ ì™„ë£Œ ê°ì§€
            if (data && status === 'running' && currentSequenceIndex >= 0) {
              const currentSeq = selectedSequences[currentSequenceIndex];
              
              // ì™„ë£Œ ìƒíƒœ ê°ì§€
              if (data.process_info && data.process_info.includes("ì™„ë£Œ") && currentSeq && currentSeq.status === 'running') {
                console.log(`í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ ìƒíƒœ ê°ì§€: ${data.process_info}`);
                addLog(`ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1} ì™„ë£Œë¨: ${currentSeq.sequence.name} (${data.process_info})`, true);
                handleSequenceCompletion(currentSequenceIndex, 'completed', 'ì§„í–‰ ìƒíƒœ ì™„ë£Œ');
              }
              // ì˜¤ë¥˜ ìƒíƒœ ê°ì§€
              else if (data.process_info && data.process_info.includes("ì˜¤ë¥˜") && currentSeq && currentSeq.status === 'running') {
                console.log(`í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜ ìƒíƒœ ê°ì§€: ${data.process_info}`);
                addLog(`ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1} ì˜¤ë¥˜ ë°œìƒ: ${currentSeq.sequence.name} (${data.process_info})`, true);
                handleSequenceCompletion(currentSequenceIndex, 'error', `ì§„í–‰ ìƒíƒœ ì˜¤ë¥˜: ${data.process_info}`);
              }
              
              // íŠ¹ë³„í•œ ìƒíƒœ ê°ì§€ - ë‚¨ì€ ì‹œê°„ì´ 0ì´ê³  ì‘ì—…ì´ ì™„ë£Œëœ ê²½ìš°
              if (data.remaining_time !== undefined && data.remaining_time === "0s" && currentSeq && currentSeq.status === 'running') {
                console.log(`ë‚¨ì€ ì‹œê°„ì´ 0ì´ˆì¸ ìƒíƒœ ê°ì§€, ì‘ì—… ì™„ë£Œ ì²˜ë¦¬`);
                addLog(`ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1} ë‚¨ì€ ì‹œê°„ 0ì´ˆ, ì™„ë£Œ ì²˜ë¦¬: ${currentSeq.sequence.name}`, true);
                handleSequenceCompletion(currentSequenceIndex, 'completed', 'ë‚¨ì€ ì‹œê°„ 0ì´ˆ');
              }
            }
          } catch (error) {
            // JSON íŒŒì‹± ì‹¤íŒ¨í•´ë„ ë¬´ì‹œ (í…ìŠ¤íŠ¸ ë©”ì‹œì§€ì¼ ìˆ˜ ìˆìŒ)
            // console.debug('ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ JSON íŒŒì‹± ì‹¤íŒ¨ (í…ìŠ¤íŠ¸ ë©”ì‹œì§€ì¼ ìˆ˜ ìˆìŒ):', error);
          }
        }
        
        // í ìƒíƒœ í† í”½ ì²˜ë¦¬
        if (topic === QUEUE_STATUS_TOPIC) {
          try {
            const queueData = JSON.parse(messageStr);
            // ì´ì „ ìƒíƒœì™€ ë¹„êµí•´ì„œ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸
            setQueueStatus(prev => {
              // ìƒíƒœê°€ ë™ì¼í•˜ë©´ ì´ì „ ìƒíƒœ ê·¸ëŒ€ë¡œ ë°˜í™˜í•˜ì—¬ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
              if (prev && 
                  prev.count === queueData.count && 
                  prev.isProcessing === queueData.isProcessing) {
                return prev;
              }
              console.log(`[í ìƒíƒœ ì—…ë°ì´íŠ¸] í•­ëª© ìˆ˜: ${queueData.count}, ì²˜ë¦¬ ì¤‘: ${queueData.isProcessing}`);
              return queueData;
            });
          } catch (error) {
            console.error('í ìƒíƒœ ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
          }
        }
      } catch (error) {
        console.error('ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
      }
    };
    
    // MQTT êµ¬ë… ì„¤ì •
    mqttClient.on('message', messageHandler);
    
    // í•„ìˆ˜ í† í”½ êµ¬ë…
    mqttClient.subscribe(EXTRACTION_OUTPUT_TOPIC);
    mqttClient.subscribe(PROCESS_PROGRESS_TOPIC);
    mqttClient.subscribe(QUEUE_STATUS_TOPIC);
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì´ˆê¸° ìƒíƒœ ë¡œë“œëŠ” ì—¬ê¸°ì„œ ìˆ˜í–‰í•˜ì§€ ì•ŠìŒ
    // ë³„ë„ì˜ useEffectë¡œ ë¶„ë¦¬ë¨
    
    return () => {
      console.log('MQTT ë©”ì‹œì§€ êµ¬ë… í•´ì œ');
      mqttClient.off("message", messageHandler);
    };
  }, [mqttClient]); // mqttClientë§Œ ì˜ì¡´ì„±ìœ¼ë¡œ ì‚¬ìš©
  
  // ì´ˆê¸° ë§ˆìš´íŠ¸ ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë¡œë“œ (ë¶„ë¦¬ëœ useEffect)
  useEffect(() => {
    console.log('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì´ˆê¸° ìƒíƒœ ë¡œë“œ ì¤‘...');
    try {
      const automationStateJson = localStorage.getItem(AUTOMATION_STATE_KEY);
      const selectedSequencesJson = localStorage.getItem(AUTOMATION_SEQUENCES_KEY);
      
      if (automationStateJson && selectedSequencesJson) {
        const automationState = JSON.parse(automationStateJson);
        const storedSequences = JSON.parse(selectedSequencesJson);
        
        setStatus(automationState.status || 'waiting');
        setCurrentSequenceIndex(automationState.currentSequenceIndex || -1);
        setLogs(automationState.logs || []);
        setSelectedSequences(storedSequences || []);
        
        console.log('ì´ì „ ìƒíƒœë¥¼ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¡œë“œí–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨:', error);
    }
  }, []);
  
  // ì‹œí€€ìŠ¤ ëª©ë¡ ì—…ë°ì´íŠ¸ (ë¶„ë¦¬ëœ useEffect)
  useEffect(() => {
    if (!savedSequences || savedSequences.length === 0) {
      console.warn('ì €ì¥ëœ ì‹œí€€ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    
    console.log('ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œí€€ìŠ¤ ëª©ë¡ ì—…ë°ì´íŠ¸ ì¤‘...');
    // ê³ ìœ í•œ ì‹œí€€ìŠ¤ ì´ë¦„ ëª©ë¡ ì¶”ì¶œ
    const uniqueSequenceNames = savedSequences
      .map(seq => seq.name)
      .filter(name => name && name.trim() !== '') // ë¹ˆ ë¬¸ìì—´ í•„í„°ë§
      .filter((value, index, self) => self.indexOf(value) === index);
    
    setAvailableSequences(uniqueSequenceNames);
    console.log('ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œí€€ìŠ¤ ëª©ë¡ ì„¤ì •:', uniqueSequenceNames);
  }, [savedSequences]);
  
  // ì‹œí€€ìŠ¤ ì œê±°
  const removeSequence = (index: number) => {
    setSelectedSequences(prev => {
      const updated = [...prev];
      updated.splice(index, 1);
      return updated;
    });
  };
  
  // ì‹œí€€ìŠ¤ ìœ„ë¡œ ì´ë™
  const moveSequenceUp = (index: number) => {
    if (index <= 0) return;
    
    setSelectedSequences(prev => {
      const updated = [...prev];
      const temp = updated[index];
      updated[index] = updated[index - 1];
      updated[index - 1] = temp;
      return updated;
    });
  };
  
  // ì‹œí€€ìŠ¤ ì•„ë˜ë¡œ ì´ë™
  const moveSequenceDown = (index: number) => {
    if (index >= selectedSequences.length - 1) return;
    
    setSelectedSequences(prev => {
      const updated = [...prev];
      const temp = updated[index];
      updated[index] = updated[index + 1];
      updated[index + 1] = temp;
      return updated;
    });
  };
  
  // ëŒ€ê¸° ì‹œê°„ ë³€ê²½
  const handleWaitTimeChange = (index: number, waitTime: number) => {
    setSelectedSequences(prev => {
      const updated = [...prev];
      updated[index] = {...updated[index], waitTime};
      return updated;
    });
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìƒíƒœ ì €ì¥
    setTimeout(() => saveStateToLocalStorage(), 100);
  };
  
  // ë°˜ë³µ íšŸìˆ˜ ë³€ê²½
  const handleRepeatsChange = (index: number, repeats: number) => {
    setSelectedSequences(prev => {
      const updated = [...prev];
      updated[index] = {...updated[index], customRepeats: repeats};
      return updated;
    });
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìƒíƒœ ì €ì¥
    setTimeout(() => saveStateToLocalStorage(), 100);
  };
  
  // ì‹œí€€ìŠ¤ ë³µì œ ê¸°ëŠ¥ ì¶”ê°€
  const duplicateSequence = (index: number) => {
    const sequenceToDuplicate = selectedSequences[index];
    setSelectedSequences(prev => [
      ...prev, 
      {
        id: uuidv4(),
        sequence: {...sequenceToDuplicate.sequence},
        status: 'waiting' as SequenceStatus,
        waitTime: sequenceToDuplicate.waitTime,
        customRepeats: sequenceToDuplicate.customRepeats
      }
    ]);
    addLog(`ì‹œí€€ìŠ¤ ë³µì œë¨: ${sequenceToDuplicate.sequence.name}`);
  };
  
  // ì‹œí€€ìŠ¤ ì™„ë£Œ ì²˜ë¦¬ í•¨ìˆ˜
  const handleSequenceCompletion = (index: number, newStatus: SequenceStatus, details?: string) => {
    // ì‹œí€€ìŠ¤ê°€ ìœ íš¨í•œì§€ í™•ì¸
    if (index < 0 || index >= selectedSequences.length) {
      console.error(`ìœ íš¨í•˜ì§€ ì•Šì€ ì‹œí€€ìŠ¤ ì¸ë±ìŠ¤: ${index}`);
      return;
    }
    
    try {
      // ì´ë¯¸ ì™„ë£Œëœ ì‹œí€€ìŠ¤ëŠ” ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
      const currentSeq = selectedSequences[index];
      if (currentSeq.status === 'completed' || currentSeq.status === 'error') {
        console.log(`ì‹œí€€ìŠ¤ ${index}(${currentSeq.sequence.name})ëŠ” ì´ë¯¸ ${currentSeq.status} ìƒíƒœì…ë‹ˆë‹¤.`);
        return;
      }
      
      console.log(`ğŸ”” ì‹œí€€ìŠ¤ ${index + 1} ì™„ë£Œ ì²˜ë¦¬ ì‹œì‘: ${currentSeq.sequence.name}, ìƒíƒœ: ${newStatus}`);
      
      // ì‹œí€€ìŠ¤ ì¢…ë£Œ ì‹œê°„ ì—…ë°ì´íŠ¸
      const endTime = new Date();
      setSelectedSequences(prev => {
        const updated = [...prev];
        updated[index] = {
          ...updated[index], 
          status: newStatus, 
          endTime: endTime.getTime(),
          errorDetails: newStatus === 'error' ? details : undefined
        };
        return updated;
      });
      
      // ë¡œê·¸ ì¶”ê°€
      const statusText = newStatus === 'completed' ? 'ì™„ë£Œ' : newStatus === 'error' ? 'ì˜¤ë¥˜' : 'ìƒíƒœ ë³€ê²½';
      addLog(`ì‹œí€€ìŠ¤ ${index + 1} ${statusText}: ${currentSeq.sequence.name}${details ? ` (${details})` : ''}`, true);
      
      // ì‘ì—… ë¡œê·¸ë¶ì— ìƒíƒœ ì—…ë°ì´íŠ¸
      try {
        const sequenceId = currentSeq.id;
        let logStatus: 'running' | 'completed' | 'error' | 'aborted' | 'warning' = 'completed';
        
        // ìƒíƒœì— ë”°ë¥¸ ì‘ì—… ë¡œê·¸ ìƒíƒœ ì„¤ì •
        if (newStatus === 'error') {
          logStatus = 'error';
        } else if (newStatus === 'completed') {
          logStatus = 'completed';
        }
        
        // ì‹œì‘ ì‹œê°„ì´ ì—†ëŠ” ê²½ìš°ì—ëŠ” í˜„ì¬ ì‹œê°„ ê¸°ì¤€ 30ì´ˆ ì „ìœ¼ë¡œ ì„¤ì • (ê¸°ë³¸ê°’)
        const startTimeMs = currentSeq.startTime || (endTime.getTime() - 30000);
        const durationSeconds = Math.round((endTime.getTime() - startTimeMs) / 1000);
        
        // ì‘ì—… ë¡œê·¸ë¶ì— ì™„ë£Œ ê¸°ë¡
        workLogService.saveWorkLog({
          id: sequenceId, // ì‹œí€€ìŠ¤ IDë¥¼ ì‘ì—… ë¡œê·¸ IDë¡œ ì‚¬ìš©
          sequenceName: `[ìë™í™”] ${currentSeq.sequence.name}`,
          startTime: new Date(startTimeMs).toISOString(),
          endTime: endTime.toISOString(),
          status: logStatus,
          details: JSON.stringify({
            mode: currentSeq.sequence.operation_mode,
            repeats: currentSeq.customRepeats,
            process: currentSeq.sequence.process,
            waitTime: currentSeq.waitTime,
            sequenceIndex: index,
            totalSequences: selectedSequences.length,
            completionDetails: details || 'ì •ìƒ ì™„ë£Œ',
            duration: durationSeconds
          })
        });
        
        console.log(`ì‹œí€€ìŠ¤ ${statusText} ì‘ì—… ë¡œê·¸ë¶ ê¸°ë¡ ì™„ë£Œ: ${currentSeq.sequence.name}, ì†Œìš”ì‹œê°„: ${durationSeconds}ì´ˆ`);
      } catch (logError) {
        console.error('ì‘ì—… ë¡œê·¸ë¶ ê¸°ë¡ ì‹¤íŒ¨:', logError);
      }
      
      // ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰ ì—¬ë¶€ ê²°ì • - ì™„ë£Œëœ ì‹œí€€ìŠ¤ê°€ í˜„ì¬ ì¸ë±ìŠ¤ì™€ ê°™ì€ ê²½ìš°ì—ë§Œ ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰
      if (newStatus === 'completed') {
        // í˜„ì¬ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸ - ì™„ë£Œëœ ì‹œí€€ìŠ¤ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ìŒ ì‹œí€€ìŠ¤ ì¸ë±ìŠ¤ ê³„ì‚°
        const nextIndex = index + 1;
        console.log(`ğŸ”„ ì‹œí€€ìŠ¤ ${index + 1} ì™„ë£Œ í™•ì¸, ë‹¤ìŒ ì‹œí€€ìŠ¤ ì¸ë±ìŠ¤: ${nextIndex}`);
        
        // ë‹¤ìŒ ì‹œí€€ìŠ¤ê°€ ìˆëŠ”ì§€ í™•ì¸
        if (nextIndex < selectedSequences.length) {
          console.log(`ğŸ”„ ë‹¤ìŒ ì‹œí€€ìŠ¤ ${nextIndex + 1} ì‹¤í–‰ ì¤€ë¹„ - ì´ë¦„: ${selectedSequences[nextIndex].sequence.name}`);
          const nextSeq = selectedSequences[nextIndex];
          
          // í˜„ì¬ ì¸ë±ìŠ¤ë¥¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸í•˜ì—¬ UIì— í‘œì‹œ - ì´ì „ ì™„ë£Œëœ ì‹œí€€ìŠ¤ì—ì„œ ë‹¤ìŒìœ¼ë¡œ ì—…ë°ì´íŠ¸
          setCurrentSequenceIndex(nextIndex);
          console.log(`í˜„ì¬ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸: ${index} â†’ ${nextIndex}`);
          
          // ì „ì—­ ì‹¤í–‰ ìƒíƒœ í™•ì¸ ë° ì—…ë°ì´íŠ¸
          if (!automationRunningRef.current) {
            console.log(`âš ï¸ ìë™í™” ì‹¤í–‰ ìƒíƒœê°€ falseì…ë‹ˆë‹¤. trueë¡œ ë³€ê²½í•©ë‹ˆë‹¤.`);
            automationRunningRef.current = true;
            setStatus('running');
          }
          
          // ëŒ€ê¸° ì‹œê°„ì´ ìˆìœ¼ë©´ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
          if (nextSeq.waitTime > 0) {
            addLog(`ë‹¤ìŒ ì‹œí€€ìŠ¤ ${nextSeq.waitTime}ì´ˆ í›„ ì‹œì‘: ${nextSeq.sequence.name}`, true);
            startCountdownWithTimeout(nextIndex, nextSeq.waitTime);
            
            // ì‹œí€€ìŠ¤ ìƒíƒœë¥¼ ëª…ì‹œì ìœ¼ë¡œ 'waiting'ìœ¼ë¡œ ì„¤ì •
            setSelectedSequences(prev => {
              const updated = [...prev];
              updated[nextIndex] = {
                ...updated[nextIndex],
                status: 'waiting'
              };
              return updated;
            });
            
            const timeoutId = setTimeout(() => {
              clearCountdown(nextIndex);
              
              // ìë™í™” ìƒíƒœ í™•ì¸ í›„ ì‹¤í–‰
              if (automationRunningRef.current) {
                console.log(`âœ… ëŒ€ê¸° ì‹œê°„ ì™„ë£Œ, ì‹œí€€ìŠ¤ ${nextIndex + 1} ì‹¤í–‰ ì‹œì‘`);
                executeSequence(nextIndex);
              } else {
                console.log(`âš ï¸ ìë™í™”ê°€ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹ˆë¯€ë¡œ ì‹œí€€ìŠ¤ ${nextIndex + 1} ì‹¤í–‰ì´ ì·¨ì†Œë¨`);
              }
            }, nextSeq.waitTime * 1000);
            
            // íƒ€ì„ì•„ì›ƒ ID ì €ì¥
            setCountdownIntervals(prev => ({
              ...prev,
              [nextIndex]: timeoutId
            }));
          } else {
            // ëŒ€ê¸° ì‹œê°„ì´ ì—†ìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰
            console.log(`âœ… ëŒ€ê¸° ì‹œê°„ ì—†ìŒ, ì‹œí€€ìŠ¤ ${nextIndex + 1} ì§ì ‘ ì‹¤í–‰ ì‹œì‘`);
            // ì¦‰ì‹œ running ìƒíƒœë¡œ ë³€ê²½
            setSelectedSequences(prev => {
              const updated = [...prev];
              if (updated[nextIndex]) {
                updated[nextIndex] = {
                  ...updated[nextIndex],
                  status: 'running',
                  startTime: Date.now()
                };
              }
              return updated;
            });

            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìƒíƒœ ì €ì¥ í›„ ì‹¤í–‰
            saveStateToLocalStorage();
            executeSequence(nextIndex);
          }
        } else {
          // ëª¨ë“  ì‹œí€€ìŠ¤ ì™„ë£Œ
          setStatus('completed');
          setCurrentSequenceIndex(-1);
          automationRunningRef.current = false;
          addLog("ğŸ‰ ëª¨ë“  ì‹œí€€ìŠ¤ ì²˜ë¦¬ ì™„ë£Œ! ìë™í™” ê³µì • ì¢…ë£Œ", true);
          
          // MQTT ìƒíƒœ ë©”ì‹œì§€ ë°œí–‰ - ëª¨ë“  ì‹œí€€ìŠ¤ ì™„ë£Œ
          if (mqttClient) {
            const statusMessage = JSON.stringify({
              status: "all_completed",
              timestamp: new Date().toISOString()
            });
            mqttClient.publish('extwork/automation/status', statusMessage);
          }
          
          // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìµœì¢… ìƒíƒœ ì €ì¥
          saveStateToLocalStorage();
        }
      } else if (newStatus === 'error' && index === currentSequenceIndex) {
        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ìë™í™” ê³µì • ì¤‘ë‹¨ ì—¬ë¶€ ê²°ì • (í˜„ì¬ëŠ” ê³„ì† ì§„í–‰)
        const nextIndex = index + 1;
        
        // ë‹¤ìŒ ì‹œí€€ìŠ¤ê°€ ìˆìœ¼ë©´ ê³„ì† ì§„í–‰
        if (nextIndex < selectedSequences.length) {
          console.log(`ì˜¤ë¥˜ ë°œìƒ í›„ ë‹¤ìŒ ì‹œí€€ìŠ¤ ${nextIndex} ì§ì ‘ ì‹¤í–‰ ì¤€ë¹„`);
          
          // ì˜¤ë¥˜ ì•Œë¦¼
          toast({
            title: "ì‹œí€€ìŠ¤ ì˜¤ë¥˜",
            description: `ì‹œí€€ìŠ¤ ${index + 1}(${currentSeq.sequence.name})ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì‹œí€€ìŠ¤ë¡œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.`,
            variant: "destructive"
          });
          
          // ì‘ì—… ë¡œê·¸ë¶ì— ì˜¤ë¥˜ ë°œìƒ í›„ ê³„ì† ì§„í–‰ ê¸°ë¡
          try {
            workLogService.saveWorkLog({
              id: uuidv4(),
              sequenceName: `[ìë™í™”] ì˜¤ë¥˜ ë°œìƒ í›„ ê³„ì† ì§„í–‰`,
              startTime: new Date().toISOString(),
              endTime: new Date().toISOString(),
              status: 'warning' as 'running' | 'completed' | 'error' | 'aborted' | 'warning',
              details: JSON.stringify({
                errorSequence: currentSeq.sequence.name,
                errorSequenceIndex: index,
                errorDetails: details || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜',
                nextSequence: selectedSequences[nextIndex].sequence.name,
                nextSequenceIndex: nextIndex,
                totalSequences: selectedSequences.length
              })
            });
          } catch (logError) {
            console.error('ì˜¤ë¥˜ í›„ ê³„ì† ì§„í–‰ ë¡œê·¸ ê¸°ë¡ ì‹¤íŒ¨:', logError);
          }
          
          // ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰
          executeSequence(nextIndex);
        } else {
          // ë§ˆì§€ë§‰ ì‹œí€€ìŠ¤ì—ì„œ ì˜¤ë¥˜ ë°œìƒ ì‹œ ìë™í™” ê³µì • ì™„ë£Œ ì²˜ë¦¬
          setStatus('error');
          setCurrentSequenceIndex(-1);
          addLog("ìë™í™” ê³µì • ì˜¤ë¥˜ë¡œ ì¸í•´ ì¤‘ë‹¨ë¨", true);
          
          // ì „ì²´ ìë™í™” ê³µì • ì‹œê°„ ê³„ì‚°
          const automationEndTime = new Date();
          const firstSeq = selectedSequences[0];
          const automationStartTime = firstSeq.startTime ? new Date(firstSeq.startTime) : new Date(automationEndTime.getTime() - 60000);
          const totalDurationSeconds = Math.round((automationEndTime.getTime() - automationStartTime.getTime()) / 1000);
          
          // ì‘ì—… ë¡œê·¸ë¶ì— ì˜¤ë¥˜ë¡œ ì¸í•œ ì¤‘ë‹¨ ê¸°ë¡
          try {
            workLogService.saveWorkLog({
              id: uuidv4(),
              sequenceName: `[ìë™í™”] ì˜¤ë¥˜ë¡œ ì¸í•œ ì¤‘ë‹¨`,
              startTime: automationStartTime.toISOString(),
              endTime: automationEndTime.toISOString(),
              status: 'error' as 'running' | 'completed' | 'error' | 'aborted' | 'warning',
              details: JSON.stringify({
                totalSequences: selectedSequences.length,
                totalDuration: totalDurationSeconds,
                errorSequence: currentSeq.sequence.name,
                errorSequenceIndex: index,
                errorDetails: details || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜',
                sequences: selectedSequences.map(seq => ({
                  name: seq.sequence.name,
                  status: seq.status,
                  duration: seq.startTime && seq.endTime ? Math.round((seq.endTime - seq.startTime) / 1000) : undefined
                }))
              })
            });
          } catch (logError) {
            console.error('ìë™í™” ê³µì • ì˜¤ë¥˜ ì¤‘ë‹¨ ë¡œê·¸ ê¸°ë¡ ì‹¤íŒ¨:', logError);
          }
          
          toast({
            title: "ìë™í™” ê³µì • ì˜¤ë¥˜",
            description: `ì‹œí€€ìŠ¤ ${index + 1}(${currentSeq.sequence.name})ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì—¬ ìë™í™” ê³µì •ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.`,
            variant: "destructive"
          });
        }
      }
    } catch (error) {
      console.error("handleSequenceCompletion í•¨ìˆ˜ ì˜¤ë¥˜:", error);
      addLog(`ì‹œí€€ìŠ¤ ì™„ë£Œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ${error}`);
    }
  };
  
  // ì‹œí€€ìŠ¤ ì‹¤í–‰ í•¨ìˆ˜ ê°œì„ 
  const executeSequence = (index: number): boolean => {
    try {
      // ì‹œí€€ìŠ¤ ìœ íš¨ì„± í™•ì¸
      if (index < 0 || index >= selectedSequences.length) {
        console.error(`ìœ íš¨í•˜ì§€ ì•Šì€ ì‹œí€€ìŠ¤ ì¸ë±ìŠ¤: ${index}`);
        return false;
      }
      
      // ì‹¤í–‰í•  ì‹œí€€ìŠ¤ ê°€ì ¸ì˜¤ê¸°
      const seqToExecute = selectedSequences[index];
      console.log(`[ì‹œí€€ìŠ¤ ì‹¤í–‰] ì‹œí€€ìŠ¤ ì •ë³´:`, {
        ì´ë¦„: seqToExecute.sequence.name,
        operation_mode: seqToExecute.sequence.operation_mode,
        process_ê¸¸ì´: seqToExecute.sequence.process.length,
        ì»¤ìŠ¤í…€ë°˜ë³µ: seqToExecute.customRepeats
      });
      
      // ìë™í™” ìƒíƒœ í™•ì¸ ë° ì—…ë°ì´íŠ¸
      if (!automationRunningRef.current) {
        console.log(`âš ï¸ ìë™í™”ê°€ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹™ë‹ˆë‹¤. ì‹¤í–‰ ìƒíƒœë¡œ ë³€ê²½í•©ë‹ˆë‹¤.`);
        automationRunningRef.current = true;
      }
      
      // UI ìƒíƒœê°€ runningì´ ì•„ë‹ˆë©´ ì—…ë°ì´íŠ¸
      if (status !== 'running') {
        console.log(`âš ï¸ UI ìƒíƒœê°€ 'running'ì´ ì•„ë‹™ë‹ˆë‹¤. í˜„ì¬ ìƒíƒœ: ${status}`);
        setStatus('running');
      }
      
      // í˜„ì¬ ì¸ë±ìŠ¤ í™•ì¸ ë° ì—…ë°ì´íŠ¸
      if (currentSequenceIndex !== index) {
        console.log(`âš ï¸ í˜„ì¬ ì¸ë±ìŠ¤ ë¶ˆì¼ì¹˜: ${currentSequenceIndex} â†’ ${index}`);
        setCurrentSequenceIndex(index);
      }
      
      // ì‹œí€€ìŠ¤ê°€ ì‹¤í–‰ ì¤‘ ìƒíƒœê°€ ì•„ë‹ˆë©´ ì—…ë°ì´íŠ¸
      if (seqToExecute.status !== 'running') {
        console.log(`âš ï¸ ì‹œí€€ìŠ¤ ${index}ì˜ ìƒíƒœê°€ 'running'ì´ ì•„ë‹™ë‹ˆë‹¤. ìƒíƒœ: ${seqToExecute.status}`);
        setSelectedSequences(prev => {
          const updated = [...prev];
          updated[index] = {
            ...updated[index],
            status: 'running',
            startTime: Date.now()
          };
          return updated;
        });
      }
      
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìƒíƒœ ì €ì¥
      saveStateToLocalStorage();
      
      console.log(`â–¶ï¸ ì‹œí€€ìŠ¤ ì‹¤í–‰ ì‹œì‘ (ì¸ë±ìŠ¤ ${index})`);
      
      // ì „ì—­ ìƒíƒœë¥¼ ì‹¤í–‰ ì¤‘ìœ¼ë¡œ ë³€ê²½
      setStatus('running');
      
      // ì‹¤í–‰ ì°¸ì¡°ê°’ ì„¤ì • - ì—¬ëŸ¬ ê³³ì—ì„œ ì‚¬ìš©ë˜ëŠ” ì¤‘ìš”í•œ í”Œë˜ê·¸
      automationRunningRef.current = true;
      
      // í˜„ì¬ ì‹œí€€ìŠ¤ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸
      setCurrentSequenceIndex(index);
      
      // ì‹œí€€ìŠ¤ ê°ì²´ ë³µì‚¬ (ì¤‘ë³µ ì„ ì–¸ ìˆ˜ì •)
      const sequenceToSend = {...selectedSequences[index]};
      
      // ì‹œí€€ìŠ¤ ê³ ìœ  ID ì¶”ì¶œ (íƒ€ì„ì•„ì›ƒ IDìš©)
      const sequenceId = sequenceToSend.id;
      
      // ì‹œì‘ ì‹œê°„ ê¸°ë¡
      const startTime = new Date();
      
      // ìƒíƒœ ì—…ë°ì´íŠ¸ (ì‹œì‘ ì‹œê°„ ì¶”ê°€)
      setSelectedSequences(prev => {
        const updated = [...prev];
        if (updated[index]) {
          updated[index] = {
            ...updated[index],
            status: 'running',
            startTime: startTime.getTime()
          };
        }
        return updated;
      });
      
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ë³€ê²½ ìƒíƒœ ì¦‰ì‹œ ì €ì¥
      saveStateToLocalStorage();
      
      // ë¡œê·¸ ì¶”ê°€ - ì‹œì‘ ì‹œê°„ í¬í•¨í•˜ì—¬ ëª…í™•íˆ
      const startTimeStr = new Date().toLocaleTimeString();
      addLog(`ì‹œí€€ìŠ¤ ${index + 1} ì‹¤í–‰ ì‹œì‘ (${startTimeStr}): ${sequenceToSend.sequence.name}`, true);
      
      // MQTT ìƒíƒœ ë©”ì‹œì§€ ë°œí–‰ - ì‹œí€€ìŠ¤ ì‹œì‘ì„ ì•Œë¦¼
      if (mqttClient) {
        try {
          const statusMessage = JSON.stringify({
            status: "sequence_started",
            sequenceIndex: index,
            sequenceName: sequenceToSend.sequence.name,
            timestamp: new Date().toISOString()
          });
          mqttClient.publish('extwork/automation/status', statusMessage);
          console.log(`âœ… ì‹œí€€ìŠ¤ ì‹œì‘ ìƒíƒœ ë©”ì‹œì§€ ë°œí–‰ ì™„ë£Œ`);
        } catch (mqttError) {
          console.error('MQTT ìƒíƒœ ë©”ì‹œì§€ ë°œí–‰ ì‹¤íŒ¨:', mqttError);
        }
      }
      
      if (!mqttClient) {
        throw new Error("MQTT í´ë¼ì´ì–¸íŠ¸ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
      }
      
      try {
        // ì‹œí€€ìŠ¤ë¥¼ MQTT ë©”ì‹œì§€ë¡œ ë³€í™˜
        const standardizedSequence = standardizeSequenceJson(sequenceToSend.sequence);
        standardizedSequence.repeats = sequenceToSend.customRepeats; // ì‚¬ìš©ì ì§€ì • ë°˜ë³µ íšŸìˆ˜ ì ìš©
        
        console.log(`[ì‹œí€€ìŠ¤ ë³€í™˜] í‘œì¤€í™”ëœ ì‹œí€€ìŠ¤:`, {
          ì´ë¦„: standardizedSequence.name,
          operation_mode: standardizedSequence.operation_mode,
          process_ê¸¸ì´: standardizedSequence.process.length,
          ë°˜ë³µíšŸìˆ˜: standardizedSequence.repeats
        });
        
        // MQTT ë©”ì‹œì§€ ë°œí–‰
        const topic = EXTRACTION_INPUT_TOPIC;
        
        // ì‹œí€€ìŠ¤ê°€ ë³µí•© ì‹œí€€ìŠ¤ì¸ì§€ í™•ì¸ - ê°œì„ ëœ íƒì§€ ë¡œì§
        const isComplexSequence = (
          standardizedSequence.operation_mode === 11 || // ë™ì‹œ+ì¶”ì¶œìˆœí™˜
          standardizedSequence.process && standardizedSequence.process.length > 30 // ë˜ëŠ” í° process ë°°ì—´
        );
        
        // ë™ì‹œ+ì¶”ì¶œìˆœí™˜(11) ëª¨ë“œì˜ ì‹œí€€ìŠ¤ê°€ ì—¬ëŸ¬ ê°œ ìˆëŠ”ì§€ í™•ì¸
        const hasModeElevenSequences = selectedSequences.filter(seq => 
          seq.sequence.operation_mode === 11
        ).length > 1;
        
        console.log(`[ì‹œí€€ìŠ¤ ë¶„ì„] ë³µí•© ì‹œí€€ìŠ¤ ì—¬ë¶€: ${isComplexSequence}, ëª¨ë“œ11 ì‹œí€€ìŠ¤ ì—¬ëŸ¬ê°œ: ${hasModeElevenSequences}`);
        
        // ë©”ì‹œì§€ êµ¬ì„± ë°©ì‹ ìˆ˜ì • - ë³µí•© ì‹œí€€ìŠ¤ ì²˜ë¦¬ ë¡œì§ ê°œì„ 
        let message;
        let sequenceCount = 0;
        
        // ì¤‘ìš”: ìë™í™” í™”ë©´ì—ì„œëŠ” ì„ íƒëœ í˜„ì¬ ì‹œí€€ìŠ¤ë§Œ ì‹¤í–‰í•˜ê³ , ì „ì²´ ì‹œí€€ìŠ¤ë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ì§€ ì•Šë„ë¡ ìˆ˜ì •
        // ë³µí•© ì‹œí€€ìŠ¤ ê°ì§€ ì‹œì—ë„ í˜„ì¬ ì‹œí€€ìŠ¤ë§Œ ì „ì†¡í•˜ë„ë¡ ë³€ê²½
        message = JSON.stringify({
          sequences: [standardizedSequence]
        }, null, 2);
        sequenceCount = 1;
        
        console.log(`[ë‹¨ì¼ ì‹œí€€ìŠ¤] í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì „ì†¡: ${standardizedSequence.name}, ëª¨ë“œ: ${standardizedSequence.operation_mode}`);
        
        // ë©”ì‹œì§€ ë‚´ìš© ìš”ì•½ ë¡œê¹…
        const messageObj = JSON.parse(message);
        console.log(`[MQTT ë©”ì‹œì§€] í† í”½: ${topic}, ì‹œí€€ìŠ¤ ìˆ˜: ${messageObj.sequences.length}ê°œ`);
        console.log(`[MQTT ë©”ì‹œì§€] ì²« ë²ˆì§¸ ì‹œí€€ìŠ¤ ëª¨ë“œ: ${messageObj.sequences[0].operation_mode}`);
        
        // ëª¨ë“  ì‹œí€€ìŠ¤ ëª¨ë“œ ë¡œê¹…
        messageObj.sequences.forEach((seq: any, idx: number) => {
          console.log(`[MQTT ë©”ì‹œì§€] ì‹œí€€ìŠ¤ #${idx+1}: ëª¨ë“œ=${seq.operation_mode}, í”„ë¡œì„¸ìŠ¤ ê¸¸ì´=${seq.process.length}`);
        });
        
        addLog(`${messageObj.sequences.length}ê°œ ì‹œí€€ìŠ¤ë¥¼ í¬í•¨í•œ ëª…ë ¹ì„ MQTTë¡œ ë°œí–‰í•©ë‹ˆë‹¤.`);
        mqttClient.publish(topic, message);
        
        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— í˜„ì¬ ìƒíƒœ ì €ì¥
        saveStateToLocalStorage();
        
        return true;
      } catch (error) {
        console.error("âŒ ì‹œí€€ìŠ¤ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜:", error);
        
        // ì˜¤ë¥˜ ë°œìƒ ì‹œ í•´ë‹¹ ì‹œí€€ìŠ¤ ìƒíƒœ ì—…ë°ì´íŠ¸
        setSelectedSequences(prev => {
          const updated = [...prev];
          if (updated[index]) {
            updated[index] = {
              ...updated[index],
              status: 'error',
              errorDetails: `${error}`
            };
          }
          return updated;
        });
        
        // ì˜¤ë¥˜ ë¡œê·¸ ì¶”ê°€
        addLog(`ì‹œí€€ìŠ¤ ${index + 1} ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error}`, true);
        
        // ë³µêµ¬ë¥¼ ìœ„í•´ ìƒíƒœ ì €ì¥
        saveStateToLocalStorage();
        
        return false;
      }
    } catch (error) {
      console.error("executeSequence í•¨ìˆ˜ ì˜¤ë¥˜:", error);
      toast({
        title: "ì˜¤ë¥˜ ë°œìƒ",
        description: `ì‹œí€€ìŠ¤ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`,
        variant: "destructive"
      });
      return false;
    }
  };
  
  // ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰ í•¨ìˆ˜ ìˆ˜ì •
  const executeNextSequence = (nextIndex: number) => {
    try {
      console.log(`executeNextSequence(${nextIndex}) ì‹¤í–‰, ì´ ì‹œí€€ìŠ¤: ${selectedSequences.length}`);

      if (nextIndex >= selectedSequences.length) {
        // ë” ì´ìƒ ì‹¤í–‰í•  ì‹œí€€ìŠ¤ê°€ ì—†ìœ¼ë©´ ì™„ë£Œ ì²˜ë¦¬
        console.log('ë§ˆì§€ë§‰ ì‹œí€€ìŠ¤ ì™„ë£Œ, ì „ì²´ ì™„ë£Œ ì²˜ë¦¬');
        setStatus('completed');
        setCurrentSequenceIndex(-1);
        automationRunningRef.current = false;
        addLog("ëª¨ë“  ì‹œí€€ìŠ¤ ì²˜ë¦¬ ì™„ë£Œ", true);
        return;
      }
      
      const nextSequence = selectedSequences[nextIndex];
      console.log(`ë‹¤ìŒ ì‹œí€€ìŠ¤: ${nextIndex}, ì´ë¦„: ${nextSequence.sequence.name}, ìƒíƒœ: ${nextSequence.status}`);
      
      // ì´ë¯¸ ì‹¤í–‰ëœ ì‹œí€€ìŠ¤ëŠ” ê±´ë„ˆëœë‹ˆë‹¤
      if (nextSequence.status === 'completed' || nextSequence.status === 'error') {
        console.log(`ì‹œí€€ìŠ¤ ${nextIndex}ëŠ” ì´ë¯¸ ${nextSequence.status} ìƒíƒœì…ë‹ˆë‹¤. ë‹¤ìŒ ì‹œí€€ìŠ¤ë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.`);
        executeNextSequence(nextIndex + 1);
        return;
      }
      
      // ëŒ€ê¸° ì‹œê°„ì´ ìˆìœ¼ë©´ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
      if (nextSequence.waitTime > 0) {
        console.log(`ì‹œí€€ìŠ¤ ${nextIndex}ëŠ” ${nextSequence.waitTime}ì´ˆ ëŒ€ê¸° í›„ ì‹¤í–‰ë©ë‹ˆë‹¤.`);
        
        // í˜„ì¬ ì‹œí€€ìŠ¤ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸ ë° ëŒ€ê¸° ìƒíƒœë¡œ ì„¤ì •
        setCurrentSequenceIndex(nextIndex);
        
        // ëŒ€ê¸° ìƒíƒœë¡œ ëª…ì‹œì ìœ¼ë¡œ ë³€ê²½
        setSelectedSequences(prev => {
          const updated = [...prev];
          updated[nextIndex] = {
            ...updated[nextIndex],
            status: 'waiting'
          };
          return updated;
        });
        
        // ëŒ€ê¸° ì¤‘ ìƒíƒœ ì €ì¥
        saveStateToLocalStorage();
        
        addLog(`ë‹¤ìŒ ì‹œí€€ìŠ¤ ${nextSequence.waitTime}ì´ˆ í›„ ì‹œì‘: ${nextSequence.sequence.name}`, true);
        
        // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
        startCountdownWithTimeout(nextIndex, nextSequence.waitTime);
        
        // ëŒ€ê¸° ì‹œê°„ í›„ ì‹œí€€ìŠ¤ ì‹¤í–‰
        const timeoutId = setTimeout(() => {
          console.log(`ì‹œí€€ìŠ¤ ${nextIndex}ì˜ ëŒ€ê¸° ì‹œê°„ ${nextSequence.waitTime}ì´ˆê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì‹¤í–‰ì„ ì‹œì‘í•©ë‹ˆë‹¤.`);
          
          // ì¹´ìš´íŠ¸ë‹¤ìš´ ì •ë¦¬
          clearCountdown(nextIndex);
          
          // ìƒíƒœ í™•ì¸ í›„ ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰ - automationRunningRef ì‚¬ìš©
          if (automationRunningRef.current) {
            console.log(`ìë™í™” ê³µì •ì´ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. ì‹œí€€ìŠ¤ ${nextIndex} ì‹¤í–‰ ì‹œì‘...`);
            
            // ì‹¤í–‰ ìƒíƒœë¡œ ë³€ê²½
            setSelectedSequences(prev => {
              const updated = [...prev];
              updated[nextIndex] = {
                ...updated[nextIndex],
                status: 'running'
              };
              return updated;
            });
            
            // ì‹œí€€ìŠ¤ ì‹¤í–‰
            executeSequence(nextIndex);
          } else {
            console.log(`ìë™í™” ê³µì •ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹œí€€ìŠ¤ ${nextIndex} ì‹¤í–‰ ì·¨ì†Œ.`);
          }
        }, nextSequence.waitTime * 1000);
        
        // íƒ€ì„ì•„ì›ƒ ID ì €ì¥
        setCountdownIntervals(prev => ({
          ...prev,
          [nextIndex]: timeoutId
        }));
      } else {
        // ëŒ€ê¸° ì‹œê°„ì´ ì—†ìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰
        console.log(`ì‹œí€€ìŠ¤ ${nextIndex}ì˜ ëŒ€ê¸° ì‹œê°„ì´ ì—†ìŠµë‹ˆë‹¤. ë°”ë¡œ ì‹¤í–‰í•©ë‹ˆë‹¤.`);
        executeSequence(nextIndex);
      }
    } catch (error) {
      console.error(`executeNextSequence í•¨ìˆ˜ ì˜¤ë¥˜: ${error}`);
      addLog(`ë‹¤ìŒ ì‹œí€€ìŠ¤ ì‹¤í–‰ ì¤€ë¹„ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error}`, true);
    }
  };
  
  // ìë™í™” ê³µì • ë¦¬ì…‹ í•¨ìˆ˜ ìˆ˜ì •
  
  // ë¡œê·¸ ì¶”ê°€ í•¨ìˆ˜ ìˆ˜ì •
  const addLog = (message: string, includeSequenceInfo: boolean = false) => {
    let logMessage = message;
    
    // ì‹œí€€ìŠ¤ ì •ë³´ í¬í•¨ ì˜µì…˜ì´ ì¼œì ¸ ìˆê³  í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ê°€ ìˆëŠ” ê²½ìš°
    if (includeSequenceInfo && currentSequenceIndex >= 0 && currentSequenceIndex < selectedSequences.length) {
      const currentSeq = selectedSequences[currentSequenceIndex];
      logMessage = `[ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1}/${selectedSequences.length} - ${currentSeq.sequence.name}] ${message}`;
    }
    
    setLogMessages(prev => {
      const newLogs = [logMessage, ...prev].slice(0, 15);
      return newLogs;
    });
    
    // ë¡œê·¸ ì¶”ê°€ í›„ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìë™ ì €ì¥
    if (status === 'running' || status === 'paused') {
      setTimeout(saveStateToLocalStorage, 100);
    }
  };
  
  // ì»´í¬ë„ŒíŠ¸ì— ì„ íƒëœ ì‹œí€€ìŠ¤ ì´ë¦„ ìƒíƒœ ì¶”ê°€ (useState ì„ ì–¸ë¶€ ê·¼ì²˜ì— ì¶”ê°€)
  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ì €ì¥ëœ, ìë™í™” ê³µì • ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
  useEffect(() => {
    const fetchSavedProcesses = async () => {
      try {
        setIsLoading(true);
        
        // ì„œë²„ì—ì„œ ì €ì¥ëœ ìë™í™” ê³µì • ëª©ë¡ ì¡°íšŒ
        const processResponse = await fetch('/api/automation/processes');
        
        if (processResponse.ok) {
          const processData = await processResponse.json();
          console.log('ìë™í™” ê³µì • ë°ì´í„° ì‘ë‹µ:', processData);
          
          // ì‹œí€€ìŠ¤ ë°ì´í„°ë„ í•¨ê»˜ ì¡°íšŒ
          const sequenceResponse = await fetch('/api/sequences');
          let sequenceData = { sequences: [] };
          
          if (sequenceResponse.ok) {
            sequenceData = await sequenceResponse.json();
            console.log('ì‹œí€€ìŠ¤ ë°ì´í„° ì‘ë‹µ:', sequenceData);
          } else {
            console.error('ì‹œí€€ìŠ¤ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', await sequenceResponse.text());
          }
          
          // processesê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©, ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ì‚¬ìš©
          let processesWithIds = [];
          if (processData.processes && Array.isArray(processData.processes)) {
            // ê° í”„ë¡œì„¸ìŠ¤ì˜ ì‹œí€€ìŠ¤ ë°°ì—´ì— IDê°€ ì—†ëŠ” ê²½ìš° ì¶”ê°€
            processesWithIds = processData.processes.map(process => {
              // ì‹œí€€ìŠ¤ì— ID ì¶”ê°€
              if (process.sequences && Array.isArray(process.sequences)) {
                const sequencesWithIds = process.sequences.map(sequence => {
                  return sequence.id ? sequence : { ...sequence, id: uuidv4() };
                });
                return { ...process, sequences: sequencesWithIds };
              }
              return process;
            });
          }
          
          // ì‹œí€€ìŠ¤ ë°ì´í„°ê°€ ìˆê³  í”„ë¡œì„¸ìŠ¤ ë°ì´í„°ê°€ ì—†ëŠ” ê²½ìš° ì‹œí€€ìŠ¤ë¡œ ì„ì‹œ í”„ë¡œì„¸ìŠ¤ ìƒì„±
          if (processesWithIds.length === 0 && sequenceData.sequences && sequenceData.sequences.length > 0) {
            console.log('ì‹œí€€ìŠ¤ ë°ì´í„°ì—ì„œ í”„ë¡œì„¸ìŠ¤ ìƒì„±');
            
            // IDê°€ ì—†ëŠ” ì‹œí€€ìŠ¤ì— ID ì¶”ê°€
            const sequencesWithIds = sequenceData.sequences.map(seq => {
              return seq.id ? seq : { ...seq, id: uuidv4() };
            });
            
            // ì‹œí€€ìŠ¤ë¥¼ SequenceWithStatus í˜•ì‹ìœ¼ë¡œ ë³€í™˜
            const sequencesWithStatus = sequencesWithIds.map(seq => ({
              id: seq.id,
              sequence: seq,
              status: 'waiting' as SequenceStatus,
              waitTime: 0,
              customRepeats: seq.repeats || 1
            }));
            
            // ì„ì‹œ í”„ë¡œì„¸ìŠ¤ ìƒì„±
            processesWithIds = [{
              id: uuidv4(),
              name: "ë¶ˆëŸ¬ì˜¨ ì‘ì—… ëª©ë¡",
              sequences: sequencesWithStatus,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString()
            }];
          }
          
          setSavedProcesses(processesWithIds);
        } else {
          console.error('ìë™í™” ê³µì • ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', await processResponse.text());
        }
      } catch (error) {
        console.error('ìë™í™” ê³µì • ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchSavedProcesses();
  }, []);
  
  // ìë™í™” ê³µì • ì €ì¥ í•¨ìˆ˜ ìˆ˜ì • - ê°™ì€ ì´ë¦„ ì‘ì—…ì€ ë³‘í•© ëŒ€ì‹  ë®ì–´ì“°ê¸°
  const saveProcess = async () => {
    if (!processName.trim()) {
      addLog('ê³µì • ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }
    
    if (selectedSequences.length === 0) {
      addLog('ì €ì¥í•  ì‹œí€€ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.');
      return;
    }
    
    try {
      setIsLoading(true);
      addLog(`ìë™í™” ê³µì • '${processName.trim()}' ì €ì¥ ì‹œì‘...`);
      
      // ì„ íƒëœ ì‹œí€€ìŠ¤ì—ì„œ PumpSequence ê°ì²´ë§Œ ì¶”ì¶œ
      const extractedSequences = selectedSequences.map(seq => seq.sequence);
      
      // ì €ì¥í•  ìë™í™” ê³µì • ë°ì´í„° ìƒì„± - íƒ€ì… ìºìŠ¤íŒ… ìˆ˜ì •
      const processData: Omit<SavedProcess, 'id' | 'createdAt' | 'updatedAt'> = {
        name: processName.trim(),
        description: processDescription.trim() || undefined,
        sequences: selectedSequences.map(seq => ({
          ...seq,
          status: 'waiting' as SequenceStatus,
          startTime: undefined,
          endTime: undefined,
          errorDetails: undefined
        }))
      };
      
      // ì‹œí€€ìŠ¤ ë°ì´í„°ë„ ë³„ë„ë¡œ ì €ì¥ (sequence API ì‚¬ìš©)
      try {
        console.log('ì‹œí€€ìŠ¤ ë°ì´í„° ì €ì¥ ì‹œì‘');
        const sequenceResponse = await fetch('/api/sequences', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ sequences: extractedSequences })
        });
        
        if (sequenceResponse.ok) {
          const sequenceData = await sequenceResponse.json();
          console.log('ì‹œí€€ìŠ¤ ì €ì¥ ì„±ê³µ:', sequenceData);
        } else {
          console.error('ì‹œí€€ìŠ¤ ì €ì¥ ì‹¤íŒ¨:', await sequenceResponse.text());
          addLog('ì‹œí€€ìŠ¤ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨');
        }
      } catch (seqError) {
        console.error('ì‹œí€€ìŠ¤ ì €ì¥ ì¤‘ ì˜¤ë¥˜:', seqError);
        addLog(`ì‹œí€€ìŠ¤ ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${seqError.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
      }

      // ê¸°ì¡´ ì €ì¥ëœ í”„ë¡œì„¸ìŠ¤ ë¶ˆëŸ¬ì˜¤ê¸°
      const processesResponse = await fetch('/api/automation/processes');
      let existingProcesses = [];
      
      if (processesResponse.ok) {
        const data = await processesResponse.json();
        if (data.processes && Array.isArray(data.processes)) {
          existingProcesses = data.processes;
        }
      }
      
      // ê°™ì€ ì´ë¦„ì˜ ê¸°ì¡´ í”„ë¡œì„¸ìŠ¤ ID í™•ì¸ (ë®ì–´ì“°ê¸° ìœ„í•¨)
      const existingProcess = existingProcesses.find(p => p.name === processName.trim());
      const processId = existingProcess?.id || uuidv4();
      
      // ì €ì¥í•  ìµœì¢… í”„ë¡œì„¸ìŠ¤ ë°ì´í„°
      const finalProcessData = {
        ...processData,
        id: processId,
        updatedAt: new Date().toISOString(),
        createdAt: existingProcess?.createdAt || new Date().toISOString()
      };
      
      // ê°™ì€ ì´ë¦„ì˜ í”„ë¡œì„¸ìŠ¤ëŠ” ë®ì–´ì“°ê¸° ìœ„í•´ ë‚˜ë¨¸ì§€ í”„ë¡œì„¸ìŠ¤ë§Œ í•„í„°ë§
      const filteredProcesses = existingProcesses.filter(p => p.name !== processName.trim());
      
      // ìƒˆ ë°ì´í„° ì¶”ê°€í•˜ì—¬ ì €ì¥
      const dataToSave = {
        processes: [...filteredProcesses, finalProcessData]
      };
      
      console.log('ìë™í™” ê³µì • ì €ì¥ ì¤‘ - ë®ì–´ì“°ê¸° ëª¨ë“œ:', finalProcessData);
      
      // Redisì— ì €ì¥ ìš”ì²­
      const response = await fetch('/api/automation/processes', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(dataToSave)
      });
      
      if (response.ok) {
        const responseData = await response.json();
        console.log('ì €ì¥ ì„±ê³µ:', responseData);
        
        // ìƒˆë¡œìš´ ë°ì´í„°ë¡œ ì „ì²´ ëª©ë¡ ê°±ì‹ 
        setSavedProcesses(responseData.processes || []);
        addLog(`ìë™í™” ê³µì • '${processData.name}'ì´(ê°€) ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        
        // ì €ì¥ ì„±ê³µ UI ì—…ë°ì´íŠ¸
        setShowSaveDialog(false);
        setProcessName('');
        setProcessDescription('');
        
        // ì„±ê³µ ì•Œë¦¼
        toast({
          title: "ì €ì¥ ì„±ê³µ",
          description: `ìë™í™” ê³µì • '${processData.name}'ì´(ê°€) ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`,
        });
      } else {
        throw new Error(await response.text() || 'ì„œë²„ì— ìë™í™” ê³µì •ì„ ì €ì¥í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('ìë™í™” ê³µì • ì €ì¥ ì˜¤ë¥˜:', error);
      addLog(`ìë™í™” ê³µì • ì €ì¥ ì˜¤ë¥˜: ${error.message || error}`);
      
      // ì˜¤ë¥˜ ì•Œë¦¼ í‘œì‹œ
      toast({
        variant: "destructive",
        title: "ì €ì¥ ì‹¤íŒ¨",
        description: `ìë™í™” ê³µì •ì„ ì €ì¥í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ${error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`,
      });
    } finally {
      setIsLoading(false);
    }
  };

  // ìë™í™” ê³µì • ë¶ˆëŸ¬ì˜¤ê¸° í•¨ìˆ˜
  const loadProcess = async () => {
    if (!selectedProcessId) {
      addLog('ë¶ˆëŸ¬ì˜¬ ê³µì •ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
      return;
    }
    
    try {
      setIsLoading(true);
      
      // í˜„ì¬ ì„ íƒëœ ê³µì • ì°¾ê¸°
      const process = savedProcesses.find(p => p.id === selectedProcessId);
      if (!process) {
        throw new Error('ì„ íƒí•œ ê³µì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }
      
      console.log(`[ë¶ˆëŸ¬ì˜¤ê¸°] ì„ íƒëœ ê³µì •: "${process.name}", ì‹œí€€ìŠ¤ ìˆ˜: ${process.sequences.length}ê°œ`);
      
      // í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ê³µì •ì´ ìˆë‹¤ë©´ í™•ì¸
      if (status === 'running') {
        addLog('ì‹¤í–‰ ì¤‘ì¸ ê³µì •ì´ ìˆìŠµë‹ˆë‹¤. ë¨¼ì € ë¦¬ì…‹í•´ì£¼ì„¸ìš”.');
        setShowLoadDialog(false);
        return;
      }
      
      // í˜„ì¬ ìƒíƒœ ì´ˆê¸°í™” í›„ ê³µì • ë¶ˆëŸ¬ì˜¤ê¸°
      fullReset();
      
      // IDê°€ ì—†ëŠ” ì‹œí€€ìŠ¤ì— ID ì¶”ê°€
      const processedSequences = process.sequences.map(seq => ({
        ...seq,
        id: seq.id || uuidv4(),
        status: 'waiting' as SequenceStatus,
        startTime: undefined,
        endTime: undefined,
        errorDetails: undefined
      }));
      
      // ë””ë²„ê¹…: ì‹œí€€ìŠ¤ ì •ë³´ ìƒì„¸ ë¡œê¹…
      processedSequences.forEach((seq, idx) => {
        console.log(`[ë¶ˆëŸ¬ì˜¤ê¸°] ì‹œí€€ìŠ¤ #${idx+1}: ì´ë¦„="${seq.sequence.name}", ëª¨ë“œ=${seq.sequence.operation_mode}, í”„ë¡œì„¸ìŠ¤ ê¸¸ì´=${seq.sequence.process.length}`);
      });
      
      // ëª¨ë“œë³„ ì‹œí€€ìŠ¤ ìˆ˜ ì§‘ê³„
      const modeCount = {};
      processedSequences.forEach(seq => {
        const mode = seq.sequence.operation_mode;
        modeCount[mode] = (modeCount[mode] || 0) + 1;
      });
      
      console.log('[ë¶ˆëŸ¬ì˜¤ê¸°] ëª¨ë“œë³„ ì‹œí€€ìŠ¤ ìˆ˜:', modeCount);
      
      // ëª¨ë“œ 11(ë™ì‹œ+ì¶”ì¶œìˆœí™˜) ì‹œí€€ìŠ¤ ìˆ˜ í™•ì¸
      const mode11Count = modeCount[11] || 0;
      if (mode11Count > 0) {
        console.log(`[ë¶ˆëŸ¬ì˜¤ê¸°] ë™ì‹œ+ì¶”ì¶œìˆœí™˜(11) ëª¨ë“œ ì‹œí€€ìŠ¤: ${mode11Count}ê°œ`);
      }
      
      setSelectedSequences(processedSequences);
      setShowLoadDialog(false);
      
      // ëª¨ë“œë³„ ì„¤ëª… ìƒì„±
      const modeDescriptions = Object.entries(modeCount).map(([mode, count]) => {
        const modeNum = parseInt(mode);
        const firstDigit = Math.floor(modeNum / 10);
        const secondDigit = modeNum % 10;
        
        let modeDesc = '';
        if (firstDigit === 1) modeDesc = 'ë™ì‹œ';
        else if (firstDigit === 2) modeDesc = 'ìˆœì°¨';
        else if (firstDigit === 3) modeDesc = 'ì¤‘ì²©';
        else modeDesc = `ëª¨ë“œ${firstDigit}`;
        
        let cycleDesc = '';
        if (secondDigit === 1) cycleDesc = 'ì¶”ì¶œìˆœí™˜';
        else if (secondDigit === 2) cycleDesc = 'ì „ì²´ìˆœí™˜';
        else if (secondDigit === 3) cycleDesc = 'ë³¸íƒ±í¬ìˆ˜ì§‘';
        else cycleDesc = `ìˆœí™˜${secondDigit}`;
        
        return `ëª¨ë“œ: ${modeNum}(${modeDesc}+${cycleDesc})ì‹œí€€ìŠ¤ ${count}ê°œ`;
      }).join(', ');
      
      addLog(`ìë™í™” ê³µì • '${process.name}'ì„(ë¥¼) ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤. ì´ ${processedSequences.length}ê°œ ì‹œí€€ìŠ¤. ${modeDescriptions}`);
    } catch (error) {
      console.error('ìë™í™” ê³µì • ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜:', error);
      addLog(`ìë™í™” ê³µì • ë¶ˆëŸ¬ì˜¤ê¸° ì˜¤ë¥˜: ${error}`);
    } finally {
      setIsLoading(false);
    }
  };

  // ìë™í™” ê³µì • ì‚­ì œ í•¨ìˆ˜ ìˆ˜ì •
  const deleteProcess = async () => {
    if (!selectedProcessId) {
      toast({
        variant: "destructive",
        title: "ì‚­ì œ ì‹¤íŒ¨",
        description: "ì‚­ì œí•  í”„ë¡œì„¸ìŠ¤ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."
      });
      return;
    }
    
    try {
      setIsLoading(true);
      
      // ëª¨ë“  ì €ì¥ëœ í”„ë¡œì„¸ìŠ¤ ë¶ˆëŸ¬ì˜¤ê¸°
      const processesResponse = await fetch('/api/automation/processes');
      let existingProcesses = [];
      
      if (processesResponse.ok) {
        const data = await processesResponse.json();
        if (data.processes && Array.isArray(data.processes)) {
          existingProcesses = data.processes;
        }
      }
      
      // ì‚­ì œí•  í”„ë¡œì„¸ìŠ¤ í™•ì¸
      const processToDelete = existingProcesses.find(p => p.id === selectedProcessId);
      
      if (!processToDelete) {
        toast({
          variant: "destructive",
          title: "ì‚­ì œ ì‹¤íŒ¨",
          description: "ì„ íƒí•œ í”„ë¡œì„¸ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        });
        return;
      }
      
      console.log(`[ìë™í™” ê³µì • ì‚­ì œ] ì‹œë„ ì¤‘, í”„ë¡œì„¸ìŠ¤ ID: ${selectedProcessId}, ì´ë¦„: ${processToDelete.name}`);
      
      // í”„ë¡œì„¸ìŠ¤ ì‚­ì œ ìš”ì²­ URL
      const url = `/api/automation/processes?id=${selectedProcessId}`;
      
      // ì‚­ì œ ìš”ì²­
      const response = await fetch(url, {
        method: 'DELETE'
      });
      
      if (response.ok) {
        const responseData = await response.json();
        
        if (responseData.success) {
          console.log('[ìë™í™” ê³µì • ì‚­ì œ] ì„±ê³µ ì‘ë‹µ:', responseData);
          
          // ëª©ë¡ì—ì„œ ì‚­ì œëœ í”„ë¡œì„¸ìŠ¤ ì œê±°
          setSavedProcesses(prev => prev.filter(p => p.id !== selectedProcessId));
          setSelectedProcessId('');
          setShowDeleteConfirm(false);
          
          // ì„±ê³µ ì•Œë¦¼
          toast({
            title: "ì‚­ì œ ì„±ê³µ",
            description: `ìë™í™” ê³µì • '${processToDelete.name}'ì´(ê°€) ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`
          });
          
          // ë‹¤ì‹œ ê³µì • ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° (í•­ìƒ ìµœì‹  ëª©ë¡ ìœ ì§€)
          try {
            const refreshResponse = await fetch('/api/automation/processes');
            if (refreshResponse.ok) {
              const refreshData = await refreshResponse.json();
              if (refreshData.processes) {
                setSavedProcesses(refreshData.processes);
              }
            }
          } catch (refreshError) {
            console.error('[ìë™í™” ê³µì • ì‚­ì œ] ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨:', refreshError);
          }
        } else {
          throw new Error(responseData.error || 'ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
      } else {
        // ì˜¤ë¥˜ ì‘ë‹µ í™•ì¸
        let errorMsg = '';
        try {
          const errorData = await response.json();
          errorMsg = errorData.error || response.statusText;
        } catch (e) {
          errorMsg = await response.text() || `HTTP ì˜¤ë¥˜: ${response.status}`;
        }
        
        throw new Error(errorMsg);
      }
    } catch (error) {
      console.error('[ìë™í™” ê³µì • ì‚­ì œ] ì˜¤ë¥˜:', error);
      
      toast({
        variant: "destructive", 
        title: "ì‚­ì œ ì‹¤íŒ¨",
        description: `ìë™í™” ê³µì • ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`
      });
    } finally {
      setIsLoading(false);
      setShowDeleteConfirm(false);
    }
  };
  
  // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìë™í™” ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸°
  const loadStateFromLocalStorage = useCallback(() => {
    try {
      const automationStateJson = localStorage.getItem(AUTOMATION_STATE_KEY);
      const selectedSequencesJson = localStorage.getItem(AUTOMATION_SEQUENCES_KEY);
      
      if (automationStateJson && selectedSequencesJson) {
        const automationState = JSON.parse(automationStateJson);
        const storedSequences = JSON.parse(selectedSequencesJson);
        
        // ì™„ë£Œ ë˜ëŠ” ì˜¤ë¥˜ ìƒíƒœì¸ ê²½ìš° waiting ìƒíƒœë¡œ ë³€ê²½í•˜ì—¬ UI í™œì„±í™”
        if (automationState.status === 'completed' || automationState.status === 'error') {
          setStatus('waiting');
          addLog('ì´ì „ ìë™í™” ê³µì • ìƒíƒœê°€ ìˆìŠµë‹ˆë‹¤. ì‹œí€€ìŠ¤ë¥¼ í¸ì§‘í•˜ê±°ë‚˜ ë‹¤ì‹œ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
        } else {
          // ì‹œê°„ ì œí•œ ì—†ì´ ì´ì „ ìƒíƒœ ë³µì› (ëª¨ë“  ìƒíƒœ ìœ ì§€)
          setStatus(automationState.status);
          
          // ìƒíƒœì— ë”°ë¥¸ ë¡œê·¸ ì¶”ê°€
          if (automationState.status === 'running') {
            addLog('ìë™í™” ê³µì •ì´ ê³„ì† ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ì„¤ì •ëœ ì‹œí€€ìŠ¤ì— ë”°ë¼ ì§„í–‰ë©ë‹ˆë‹¤.');
          } else if (automationState.status === 'paused') {
            addLog('ìë™í™” ê³µì •ì´ ì¼ì‹œ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ê³„ì† ì§„í–‰í•˜ë ¤ë©´ ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.');
          }
        }
        
        setCurrentSequenceIndex(automationState.currentSequenceIndex || -1);
        setLogs(automationState.logs || []);
        setSelectedSequences(storedSequences || []);
        
        // ì‹¤í–‰ ì¤‘ì¸ ìƒíƒœì—ì„œë„ í˜ì´ì§€ ì´ë™ ê°€ëŠ¥í•˜ë„ë¡ ì ê¸ˆ ë¹„í™œì„±í™”
        // if (automationState.status === 'running' && onLockChange) {
        //   onLockChange(true);
        // }
        
        return true;
      }
    } catch (error) {
      console.error('ìë™í™” ê³µì • ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', error);
    }
    
    return false;
  }, [onLockChange]);
  
  // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìë™í™” ìƒíƒœ ì €ì¥
  const saveStateToLocalStorage = useCallback(() => {
    try {
      const automationState = {
        status,
        currentSequenceIndex,
        logs,
        lastUpdated: Date.now()
      };
      
      localStorage.setItem(AUTOMATION_STATE_KEY, JSON.stringify(automationState));
      localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify(selectedSequences));
      
      console.log('ìë™í™” ê³µì • ìƒíƒœ ì €ì¥ë¨', automationState);
    } catch (error) {
      console.error('ìë™í™” ê³µì • ìƒíƒœ ì €ì¥ ì‹¤íŒ¨:', error);
    }
  }, [status, currentSequenceIndex, logs, selectedSequences]);
  
  // ìƒíƒœ ë³€ê²½ ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
  useEffect(() => {
    // ìƒíƒœê°€ ë³€ê²½ë  ë•Œë§Œ ì €ì¥ (ë¬´í•œ ë£¨í”„ ë°©ì§€)
    const saveState = () => {
      if (status === 'running' || status === 'paused') {
        const automationState = {
          status,
          currentSequenceIndex,
          logs: logs.slice(0, 50) // ë¡œê·¸ í¬ê¸° ì œí•œ
        };

        localStorage.setItem(AUTOMATION_STATE_KEY, JSON.stringify(automationState));
        localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify(selectedSequences));
      }
    };

    saveState();
  }, [status, currentSequenceIndex, selectedSequences, logs]);
  
  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë¶ˆëŸ¬ì˜¤ê¸° (í•œ ë²ˆë§Œ ì‹¤í–‰)
  useEffect(() => {
    console.log('ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ - ì´ˆê¸° ìƒíƒœ ë¡œë“œë¥¼ ì‹œë„í•©ë‹ˆë‹¤');
    
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë¡œë“œ (ì´ˆê¸° ë§ˆìš´íŠ¸ ì‹œì—ë§Œ)
    try {
      const automationStateJson = localStorage.getItem(AUTOMATION_STATE_KEY);
      const selectedSequencesJson = localStorage.getItem(AUTOMATION_SEQUENCES_KEY);
      
      if (automationStateJson && selectedSequencesJson) {
        const automationState = JSON.parse(automationStateJson);
        let storedSequences = [];
        
        try {
          storedSequences = JSON.parse(selectedSequencesJson);
          console.log('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ì‹œí€€ìŠ¤ ë¡œë“œ:', storedSequences);
        } catch (parseError) {
          console.error('ì‹œí€€ìŠ¤ íŒŒì‹± ì˜¤ë¥˜:', parseError);
          // íŒŒì‹± ì˜¤ë¥˜ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ì²˜ë¦¬
          storedSequences = [];
        }
        
        // ë°°ì—´ì´ ì•„ë‹ˆê±°ë‚˜ ë¹„ì–´ ìˆìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì´ˆê¸°í™”
        if (!Array.isArray(storedSequences) || storedSequences.length === 0) {
          console.log('ìœ íš¨í•œ ì‹œí€€ìŠ¤ ë°ì´í„°ê°€ ì—†ì–´ ë¹ˆ ë°°ì—´ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.');
          storedSequences = [];
        }
        
        setStatus(automationState.status || 'waiting');
        setCurrentSequenceIndex(automationState.currentSequenceIndex || -1);
        setLogs(automationState.logs || []);
        setSelectedSequences(storedSequences);
        
        console.log('ì´ì „ ìƒíƒœë¥¼ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ë¡œë“œí–ˆìŠµë‹ˆë‹¤.');
      } else {
        console.log('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥ëœ ìƒíƒœê°€ ì—†ìŠµë‹ˆë‹¤.');
        
        // ì €ì¥ëœ ì‹œí€€ìŠ¤ê°€ ì—†ëŠ” ê²½ìš°, savedSequencesì—ì„œ ê¸°ë³¸ ì‹œí€€ìŠ¤ ìƒì„±
        if (savedSequences && savedSequences.length > 0) {
          console.log('ê¸°ë³¸ ì‹œí€€ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤:', savedSequences[0].name);
          
          // ì²« ë²ˆì§¸ ì €ì¥ëœ ì‹œí€€ìŠ¤ë¥¼ ê¸°ë³¸ ì‹œí€€ìŠ¤ë¡œ ì¶”ê°€
          const defaultSequence = {
            id: uuidv4(),
            sequence: savedSequences[0],
            status: 'waiting' as SequenceStatus,
            waitTime: 0,
            customRepeats: savedSequences[0].repeats || 1
          };
          
          setSelectedSequences([defaultSequence]);
          
          // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
          localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify([defaultSequence]));
          console.log('ê¸°ë³¸ ì‹œí€€ìŠ¤ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }
      }
    } catch (error) {
      console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨:', error);
    }
  }, [savedSequences]);
  
  // savedSequencesê°€ ë³€ê²½ë  ë•Œ availableSequences ì—…ë°ì´íŠ¸ (ë³„ë„ useEffectë¡œ ë¶„ë¦¬)
  useEffect(() => {
    // ì‹œí€€ìŠ¤ ëª©ë¡ì„ ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œí€€ìŠ¤ë¡œ ì„¤ì •
    if (savedSequences && savedSequences.length > 0) {
      // ê³ ìœ í•œ ì‹œí€€ìŠ¤ ì´ë¦„ ëª©ë¡ ì¶”ì¶œ (íƒ€ì… ë¬¸ì œ í•´ê²°)
      const uniqueSequenceNames = savedSequences
        .map(seq => seq.name)
        .filter(name => name && name.trim() !== '') // ë¹ˆ ë¬¸ìì—´ í•„í„°ë§
        .filter((value, index, self) => self.indexOf(value) === index);
      
      setAvailableSequences(uniqueSequenceNames);
      console.log('ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œí€€ìŠ¤ ëª©ë¡ ì„¤ì •:', uniqueSequenceNames);
    } else {
      console.warn('ì €ì¥ëœ ì‹œí€€ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.');
    }
  }, [savedSequences]);
  
  // ì‹œí€€ìŠ¤ ì˜ˆìƒ ì‹¤í–‰ ì‹œê°„ ê³„ì‚° í•¨ìˆ˜ ì¶”ê°€
  const calculateExpectedDuration = (sequence: PumpSequence): number => {
    const baseTime = 10; // ê¸°ë³¸ ì‹œê°„ (ì´ˆ)
    const modeMultiplier = Math.floor(sequence.operation_mode / 10) === 1 ? 2 : 
                          Math.floor(sequence.operation_mode / 10) === 2 ? 3 : 4;
    const repeatMultiplier = sequence.repeats || 1;
    
    // ìµœì†Œ 30ì´ˆ, ìµœëŒ€ 5ë¶„ìœ¼ë¡œ ì œí•œ
    return Math.min(300, Math.max(30, baseTime * modeMultiplier * repeatMultiplier));
  };
  
  // ìƒíƒœì— ë”°ë¥¸ ë°°ê²½ìƒ‰ ë°˜í™˜
  const getStatusBgColor = () => {
    switch (status) {
      case 'waiting': return 'bg-gray-100';
      case 'running': return 'bg-blue-100';
      case 'completed': return 'bg-green-100';
      case 'stopped': return 'bg-red-100';
      default: return 'bg-gray-100';
    }
  };
  
  // ìƒíƒœì— ë”°ë¥¸ í…ìŠ¤íŠ¸ ë°˜í™˜
  const getStatusText = () => {
    switch (status) {
      case 'waiting': return 'ëŒ€ê¸°ì¤‘';
      case 'running': return 'ì‹¤í–‰ì¤‘';
      case 'completed': return 'ì™„ë£Œ';
      case 'stopped': return 'ë©ˆì¶¤';
      default: return 'ì•Œ ìˆ˜ ì—†ìŒ';
    }
  };
  
  // ì‹œí€€ìŠ¤ ìƒíƒœ ë°°ì§€ ì»´í¬ë„ŒíŠ¸
  const StatusBadge = ({ status }: { status: SequenceStatus }) => {
    switch (status) {
      case 'waiting':
        return <Badge variant="outline" className="bg-gray-100 text-gray-800 border-gray-300 px-3">ëŒ€ê¸°</Badge>;
      case 'running':
        return <Badge variant="outline" className="bg-blue-100 text-blue-800 border-blue-300 px-3 animate-pulse">ì‹¤í–‰ì¤‘</Badge>;
      case 'completed':
        return <Badge variant="outline" className="bg-green-100 text-green-800 border-green-300 px-3">ì™„ë£Œ</Badge>;
      case 'error':
        return <Badge variant="outline" className="bg-red-100 text-red-800 border-red-300 px-3">ì˜¤ë¥˜</Badge>;
      default:
        return <Badge variant="outline">ì•Œ ìˆ˜ ì—†ìŒ</Badge>;
    }
  };
  
  // ì‹œê°„ í˜•ì‹ ë³€í™˜ í•¨ìˆ˜
  const formatTime = (seconds: number): string => {
    if (seconds === 0) return '0ì´ˆ';
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    
    let result = '';
    if (hours > 0) result += `${hours}ì‹œê°„ `;
    if (minutes > 0) result += `${minutes}ë¶„ `;
    if (secs > 0 || (hours === 0 && minutes === 0)) result += `${secs}ì´ˆ`;
    
    return result.trim();
  };
  
  // ëŒ€ê¸° ì‹œê°„ íŒì—… ì—´ê¸°
  const openTimePopup = (index: number, currentTime: number) => {
    // í˜„ì¬ ì„¤ì •ëœ ì‹œê°„ì„ ì‹œ/ë¶„/ì´ˆë¡œ ë³€í™˜
    const hours = Math.floor(currentTime / 3600);
    const minutes = Math.floor((currentTime % 3600) / 60);
    const seconds = currentTime % 60;
    
    setTempHours(hours);
    setTempMinutes(minutes);
    setTempSeconds(seconds);
    setShowTimePopup(index);
    
    // íŒì—… ìœ„ì¹˜ ê¸°ë³¸ê°’ ì„¤ì • (í™”ë©´ ì¤‘ì•™)
    setPopupPosition({ 
      x: window.innerWidth / 2 - 150, 
      y: window.innerHeight / 2 - 100 
    });
  };
  
  // ëŒ€ê¸° ì‹œê°„ íŒì—… ì €ì¥
  const saveTimePopup = (index: number) => {
    const totalSeconds = (tempHours * 3600) + (tempMinutes * 60) + tempSeconds;
    handleWaitTimeChange(index, totalSeconds);
    setShowTimePopup(null);
  };
  
  // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ í•¨ìˆ˜ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤
  // ì¹´ìš´íŠ¸ë‹¤ìš´ ì œê±° í•¨ìˆ˜ë„ ìˆ˜ì •í•©ë‹ˆë‹¤
  const clearCountdown = (index: number) => {
    const intervalId = countdownIntervals[`interval_${index}`];
    if (intervalId) {
      clearInterval(intervalId);
    }
    
    // ì¹´ìš´íŠ¸ë‹¤ìš´ ìƒíƒœì—ì„œ ì œê±°
    setWaitingCountdowns(prev => {
      const updated = { ...prev };
      delete updated[index];
      return updated;
    });
    
    // ì¸í„°ë²Œ ID ëª©ë¡ì—ì„œ ì œê±°
    setCountdownIntervals(prev => {
      const updated = { ...prev };
      delete updated[`interval_${index}`];
      return updated;
    });
  };
  
  // í ë¹„ìš°ê¸° ëª…ë ¹
  const clearQueue = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "clear_q");
      addLog('Queue clear command sent');
    } catch (e) {
      addLog(`Queue clear command error: ${e}`);
    }
  };
  
  // íì—ì„œ í•­ëª© ì œê±°
  const removeQueueItem = (itemId: string) => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "remove_q");
      addLog(`Queue item remove command sent: ${itemId}`);
    } catch (e) {
      addLog(`Queue item remove command error: ${e}`);
    }
  };
  
  // í ì²˜ë¦¬ ì¼ì‹œì •ì§€
  const pauseQueueProcessing = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "pause");
      addLog(`Queue processing pause command sent`);
    } catch (e) {
      addLog(`Queue pause command error: ${e}`);
    }
  };

  // í ì²˜ë¦¬ ì¬ê°œ
  const resumeQueueProcessing = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "resume");
      addLog(`Queue processing resume command sent`);
    } catch (e) {
      addLog(`Queue resume command error: ${e}`);
    }
  };

  // í ëª©ë¡ ì¡°íšŒ
  const listQueue = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "list_q");
      addLog(`Queue list command sent`);
    } catch (e) {
      addLog(`Queue list command error: ${e}`);
    }
  };
  
  // ìˆ˜ë™ ì…ë ¥ ëª…ë ¹ ë°œí–‰
  const publishManualCommand = () => {
    if (!mqttClient || !manualCommand.trim()) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, manualCommand);
      addLog(`Manual command sent: ${manualCommand}`);
      setManualCommand(""); // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
    } catch (e) {
      addLog(`Manual command error: ${e}`);
    }
  };
  
  // í í•­ëª© ì „ì²´ ì œê±° ëª…ë ¹
  const removeAllQueueItems = () => {
    if (!mqttClient) return;
    
    try {
      mqttClient.publish(EXTRACTION_INPUT_TOPIC, "remove_q");
      addLog(`Remove all queue items command sent`);
    } catch (e) {
      addLog(`Remove queue command error: ${e}`);
    }
  };
  
  // í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  const getCurrentSequenceInfo = () => {
    if (currentSequenceIndex >= 0 && currentSequenceIndex < selectedSequences.length) {
      const seq = selectedSequences[currentSequenceIndex];
      return `${currentSequenceIndex + 1}/${selectedSequences.length}: ${seq.sequence.name}`;
    }
    return '';
  };
  
  // ìƒˆë¡œê³ ì¹¨ ê°ì§€ ë° ìë™ ì´ˆê¸°í™” ì²˜ë¦¬
  useEffect(() => {
    // í˜ì´ì§€ ë¡œë“œ ì‹œ íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë¡
    const pageLoadTime = Date.now();
    
    // ë§ˆì§€ë§‰ í™œì„± ì‹œê°„ ê°€ì ¸ì˜¤ê¸°
    const lastActiveTime = parseInt(localStorage.getItem('automation-last-active-time') || '0');
    
    // í˜„ì¬ ì‹œê°„ ì €ì¥
    localStorage.setItem('automation-last-active-time', pageLoadTime.toString());
    
    // ìƒˆë¡œê³ ì¹¨ ê°ì§€ (3ì´ˆ ì´ë‚´ì˜ ê°„ê²©ì€ ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ê°„ì£¼)
    const isRefresh = pageLoadTime - lastActiveTime < 3000;
    
    // ìƒˆë¡œê³ ì¹¨ì´ê³  ìƒíƒœê°€ ì™„ë£Œë‚˜ ì˜¤ë¥˜ë©´ ì´ˆê¸°í™”
    if (isRefresh) {
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ í˜„ì¬ ìƒíƒœ í™•ì¸
      try {
        const automationStateJson = localStorage.getItem(AUTOMATION_STATE_KEY);
        if (automationStateJson) {
          const automationState = JSON.parse(automationStateJson);
          
          // ì™„ë£Œ ë˜ëŠ” ì˜¤ë¥˜ ìƒíƒœë©´ waiting ìƒíƒœë¡œ ë³€ê²½
          if (automationState.status === 'completed' || automationState.status === 'error') {
            setStatus('waiting');
            addLog('ìƒˆë¡œê³ ì¹¨ ê°ì§€: ìë™í™” ê³µì • ìƒíƒœë¥¼ ì´ˆê¸°í™”í–ˆìŠµë‹ˆë‹¤. ì‹œí€€ìŠ¤ë¥¼ í¸ì§‘í•˜ê±°ë‚˜ ë‹¤ì‹œ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
          }
        }
      } catch (error) {
        console.error('ìë™í™” ê³µì • ìƒíƒœ í™•ì¸ ì‹¤íŒ¨:', error);
      }
    }
    
    // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ í˜„ì¬ ì‹œê°„ ì €ì¥
    const handleBeforeUnload = () => {
      localStorage.setItem('automation-last-active-time', Date.now().toString());
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, []);
  
  // ìë™í™” ê³µì • ì‹œì‘ í•¨ìˆ˜ - Run ë²„íŠ¼ í´ë¦­ ì‹œ í˜¸ì¶œ
  const startAutomation = async () => {
    if (selectedSequences.length === 0) {
      toast({
        title: "ì‹œí€€ìŠ¤ ì—†ìŒ",
        description: "ì‹¤í–‰í•  ì‹œí€€ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ì‹œí€€ìŠ¤ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.",
        variant: "destructive"
      });
      return;
    }
    
    try {
      console.log('ìë™í™” ê³µì • ì‹œì‘ ì‹œë„...');
      
      if (processingAction.current) {
        console.log('ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì¸ ì‘ì—…ì´ ìˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.');
        return;
      }
      
      // ì´ˆê¸°í™” - í•­ìƒ ì²« ë²ˆì§¸ ì‹œí€€ìŠ¤ ì‹¤í–‰ë¶€í„° ì‹œì‘
      let startingIndex = 0;
      
      // ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸ ê²½ìš°, í˜„ì¬ ì¸ë±ìŠ¤ë¶€í„° ì‹œì‘
      if (status === 'paused') {
        startingIndex = currentSequenceIndex >= 0 ? currentSequenceIndex : 0;
        console.log(`ì¼ì‹œ ì¤‘ì§€ ìƒíƒœì—ì„œ ì¬ì‹œì‘. ì¸ë±ìŠ¤: ${startingIndex}`);
      }
      // ì´ì „ì— ì¼ë¶€ ì‹œí€€ìŠ¤ê°€ ì™„ë£Œëœ ê²½ìš°, ì²« ë²ˆì§¸ ëŒ€ê¸° ì‹œí€€ìŠ¤ë¶€í„° ì‹œì‘
      else {
        const firstWaitingIndex = selectedSequences.findIndex(seq => seq.status === 'waiting');
        if (firstWaitingIndex >= 0) {
          startingIndex = firstWaitingIndex;
          console.log(`ì²«ë²ˆì§¸ ëŒ€ê¸° ì¤‘ì¸ ì‹œí€€ìŠ¤ ë°œê²¬. ì¸ë±ìŠ¤: ${startingIndex}`);
        }
      }
      
      // ëª¨ë“  ì‹œí€€ìŠ¤ê°€ ì™„ë£Œë˜ì—ˆìœ¼ë©´ ìƒíƒœ ì¬ì„¤ì •
      const allCompleted = selectedSequences.every(seq => 
        seq.status === 'completed' || seq.status === 'error'
      );
      
      if (allCompleted) {
        console.log('ëª¨ë“  ì‹œí€€ìŠ¤ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ìƒíƒœë¥¼ ì¬ì„¤ì •í•©ë‹ˆë‹¤.');
        // ëª¨ë“  ì‹œí€€ìŠ¤ ìƒíƒœë¥¼ 'waiting'ìœ¼ë¡œ ì¬ì„¤ì •
        setSelectedSequences(prev => prev.map(seq => ({
          ...seq,
          status: 'waiting',
          startTime: undefined,
          endTime: undefined,
          errorDetails: undefined
        })));
        startingIndex = 0;
      }
      
      // ì „ì—­ ì‹¤í–‰ ìƒíƒœë¥¼ trueë¡œ ì„¤ì • (ë¨¼ì € ì„¤ì •)
      automationRunningRef.current = true;
      
      // ìƒíƒœë¥¼ 'running'ìœ¼ë¡œ ë¨¼ì € ë³€ê²½
      setStatus('running');
      
      // í˜„ì¬ ì‹œí€€ìŠ¤ ì¸ë±ìŠ¤ ì„¤ì •
      setCurrentSequenceIndex(startingIndex);
      
      // íŠ¹íˆ ì²« ì‹œì‘ì¼ ë•Œ ìƒíƒœë¥¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸í•˜ë„ë¡ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
      const automationState = {
        status: 'running',
        currentSequenceIndex: startingIndex,
        logs: logs,
        lastUpdated: Date.now()
      };
      localStorage.setItem(AUTOMATION_STATE_KEY, JSON.stringify(automationState));
      
      console.log(`ì‹œí€€ìŠ¤ ${startingIndex + 1} ì‹¤í–‰ ì‹œì‘: ${selectedSequences[startingIndex].sequence.name}`);
      
      // ì‹œí€€ìŠ¤ ìƒíƒœë¥¼ 'ì‹¤í–‰ ì¤‘'ìœ¼ë¡œ ë³€ê²½
      setSelectedSequences(prev => {
        const updated = [...prev];
        updated[startingIndex] = {
          ...updated[startingIndex],
          status: 'running',
          startTime: Date.now()
        };
        return updated;
      });
      
      // ìƒíƒœ ì €ì¥ í›„ ì‹œí€€ìŠ¤ ì‹¤í–‰
      await new Promise(resolve => setTimeout(resolve, 100)); // ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì§§ì€ ì§€ì—°
      
      // ì‹œí€€ìŠ¤ ì‹¤í–‰
      executeSequence(startingIndex);
      
      // ì‹¤í–‰ ìƒíƒœ ë¡œê·¸ ì¶”ê°€
      addLog(`ìë™í™” ê³µì • ì‹œì‘: ì‹œí€€ìŠ¤ ${startingIndex + 1} - ${selectedSequences[startingIndex].sequence.name}`);
      
      // UI ì ê¸ˆ ì„¤ì • (ì˜µì…˜)
      if (onLockChange) {
        onLockChange(true);
      }
    } catch (error) {
      console.error('ìë™í™” ê³µì • ì‹œì‘ ì˜¤ë¥˜:', error);
      addLog(`ìë™í™” ê³µì • ì‹œì‘ ì˜¤ë¥˜: ${error}`);
      
      // ì˜¤ë¥˜ ë°œìƒ ì‹œ ìƒíƒœ ë³µì›
      setStatus('waiting');
      automationRunningRef.current = false;
      
      toast({
        title: "ì‹œì‘ ì‹¤íŒ¨",
        description: `ìë™í™” ê³µì •ì„ ì‹œì‘í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ${error}`,
        variant: "destructive"
      });
    }
  };
  
  // ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™” ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì´ˆê¸°í™” ë¡œì§ ê°•í™”
  // useEffectë¥¼ ì¶”ê°€í•˜ì—¬ ì»´í¬ë„ŒíŠ¸ê°€ ë§ˆìš´íŠ¸ë  ë•Œ ê¸°ë³¸ ë¹ˆ ì‹œí€€ìŠ¤ ë°°ì—´ ì €ì¥
  useEffect(() => {
    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì‹œí€€ìŠ¤ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ë¡œ ì´ˆê¸°í™”
    if (typeof window !== 'undefined') {
      try {
        const storedSequences = localStorage.getItem(AUTOMATION_SEQUENCES_KEY);
        if (!storedSequences) {
          console.log('ì‹œí€€ìŠ¤ ë°ì´í„° ì´ˆê¸°í™”: ë¹ˆ ë°°ì—´ ì €ì¥');
          localStorage.setItem(AUTOMATION_SEQUENCES_KEY, JSON.stringify([]));
        }
      } catch (error) {
        console.error('ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
      }
    }
  }, []);
  
  // ìë™í™” ì§„í–‰ ìƒíƒœ ì²´í¬ ë° ê°•ì œ ì „í™˜ í•¨ìˆ˜ ìˆ˜ì •
  const forceProgressToNextSequence = () => {
    try {
      console.log('forceProgressToNextSequence í•¨ìˆ˜ í˜¸ì¶œë¨ - ê³µì • ì¢…ë£Œ ë©”ì‹œì§€ ê°ì§€ì— ì˜í•´ ì‹œí€€ìŠ¤ ì§„í–‰');

      // í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ê°€ ì—†ëŠ” ê²½ìš° ë¬´ì‹œ
      if (currentSequenceIndex < 0 || currentSequenceIndex >= selectedSequences.length) {
        console.log('ì‹¤í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ê°€ ì—†ê±°ë‚˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤. í˜„ì¬ ì¸ë±ìŠ¤:', currentSequenceIndex);
        return;
      }

      // í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ì‹œí€€ìŠ¤ ìƒíƒœ í™•ì¸
      const currentSeq = selectedSequences[currentSequenceIndex];
      
      if (!currentSeq || currentSeq.status !== 'running') {
        console.log(`í˜„ì¬ ì‹œí€€ìŠ¤(${currentSequenceIndex})ê°€ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹ˆê±°ë‚˜ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìƒíƒœ:`, currentSeq?.status);
        return;
      }

      console.log(`âœ… í˜„ì¬ ì‹œí€€ìŠ¤(${currentSequenceIndex}) ì™„ë£Œ ë©”ì‹œì§€ ì²˜ë¦¬ ì‹œì‘`);
      console.log(`ì‹œí€€ìŠ¤ ì •ë³´: ${currentSeq.sequence.name}, ë°˜ë³µ íšŸìˆ˜: ${currentSeq.customRepeats || 1}`);

      // í˜„ì¬ ì‹œí€€ìŠ¤ì˜ ë°˜ë³µ íšŸìˆ˜ í™•ì¸
      const repeatsNeeded = currentSeq.customRepeats || 1;
      
      // ì‹œí€€ìŠ¤ ê°ì²´ì— í˜„ì¬ ë°˜ë³µ íšŸìˆ˜ ì¹´ìš´íŠ¸ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
      // ì²˜ìŒì´ë©´ undefinedì´ë¯€ë¡œ 1ë¡œ ì„¤ì •, ì•„ë‹ˆë©´ í˜„ì¬ ê°’ + 1
      const currentRepeatCount = currentSeq.currentRepeatCount !== undefined ? 
                               currentSeq.currentRepeatCount + 1 : 1;
      
      console.log(`í˜„ì¬ ë°˜ë³µ íšŸìˆ˜: ${currentRepeatCount}/${repeatsNeeded}`);

      // ì‹œí€€ìŠ¤ì˜ currentRepeatCount ì—…ë°ì´íŠ¸ (ìƒíƒœëŠ” ì•„ì§ ë³€ê²½í•˜ì§€ ì•ŠìŒ)
      setSelectedSequences(prev => {
        const updated = [...prev];
        updated[currentSequenceIndex] = {
          ...updated[currentSequenceIndex],
          currentRepeatCount: currentRepeatCount
        };
        return updated;
      });

      // ì¦‰ì‹œ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ìƒíƒœ ì €ì¥
      saveStateToLocalStorage();

      // ë°˜ë³µ íšŸìˆ˜ê°€ ì¶©ì¡±ë˜ì—ˆëŠ”ì§€ í™•ì¸
      if (currentRepeatCount >= repeatsNeeded) {
        console.log(`âœ… ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1}(${currentSeq.sequence.name}) ëª¨ë“  ë°˜ë³µ ì™„ë£Œ: ${currentRepeatCount}/${repeatsNeeded}`);
        
        // ëª¨ë“  ë°˜ë³µì´ ì™„ë£Œë˜ì—ˆìœ¼ë¯€ë¡œ ì‹œí€€ìŠ¤ë¥¼ ì™„ë£Œ ìƒíƒœë¡œ ë³€ê²½
        handleSequenceCompletion(currentSequenceIndex, 'completed', `ì „ì²´ ë°˜ë³µ ì™„ë£Œ (${currentRepeatCount}/${repeatsNeeded})`);
        
        // ë‹¤ìŒ ì‹œí€€ìŠ¤ë¡œ ì§„í–‰í•˜ê¸° ì „ì— ìƒíƒœê°€ ì—…ë°ì´íŠ¸ë  ìˆ˜ ìˆë„ë¡ ì ì‹œ ëŒ€ê¸°
        // (handleSequenceCompletion í•¨ìˆ˜ê°€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ë‹¤ìŒ ì‹œí€€ìŠ¤ë¥¼ ì²˜ë¦¬í•˜ë¯€ë¡œ ì¶”ê°€ ë™ì‘ í•„ìš” ì—†ìŒ)
      } else {
        console.log(`â³ ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1}(${currentSeq.sequence.name}) ë°˜ë³µ ì§„í–‰ ì¤‘: ${currentRepeatCount}/${repeatsNeeded}`);
        
        // ì•„ì§ í•„ìš”í•œ ë°˜ë³µ íšŸìˆ˜ë¥¼ ì±„ìš°ì§€ ëª»í–ˆìœ¼ë¯€ë¡œ, ë™ì¼í•œ ì‹œí€€ìŠ¤ë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•´ì•¼ í•¨
        addLog(`ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1} ë°˜ë³µ ì‹¤í–‰ ì¤‘: ${currentRepeatCount}/${repeatsNeeded} - ${currentSeq.sequence.name}`, true);
        
        // ëŒ€ê¸° ì‹œê°„ ì„¤ì •
        const waitTime = currentSeq.waitTime || 3; // ê¸°ë³¸ 3ì´ˆ ëŒ€ê¸°
        
        if (waitTime > 0) {
          // ëŒ€ê¸° ì‹œê°„ì„ ì„¤ì •í•˜ê³  ì¹´ìš´íŠ¸ë‹¤ìš´
          console.log(`â³ ë‹¤ìŒ ë°˜ë³µì„ ìœ„í•´ ${waitTime}ì´ˆ ëŒ€ê¸° í›„ ë™ì¼ ì‹œí€€ìŠ¤ ì¬ì‹¤í–‰`);
          
          // ì‹œí€€ìŠ¤ ìƒíƒœë¥¼ 'waiting'ìœ¼ë¡œ ì„¤ì •
          setSelectedSequences(prev => {
            const updated = [...prev];
            updated[currentSequenceIndex] = {
              ...updated[currentSequenceIndex],
              status: 'waiting'
            };
            return updated;
          });
          
          // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
          startCountdownWithTimeout(currentSequenceIndex, waitTime);
          
          // ëŒ€ê¸° ì‹œê°„ í›„ ë™ì¼ ì‹œí€€ìŠ¤ ì¬ì‹¤í–‰
          const timeoutId = setTimeout(() => {
            console.log(`âœ“ ëŒ€ê¸° ì‹œê°„(${waitTime}ì´ˆ) ì™„ë£Œ. ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1} ë°˜ë³µ ì‹¤í–‰`);
            
            // ì¹´ìš´íŠ¸ë‹¤ìš´ ì •ë¦¬
            clearCountdown(currentSequenceIndex);
            
            // ìƒíƒœ í™•ì¸ í›„ ì‹œí€€ìŠ¤ ì‹¤í–‰
            if (automationRunningRef.current) {
              console.log(`ìë™í™” ê³µì •ì´ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. ì‹œí€€ìŠ¤ ${currentSequenceIndex} ë°˜ë³µ ì‹¤í–‰ ì‹œì‘...`);
              
              // ìƒíƒœë¥¼ 'running'ìœ¼ë¡œ ë³€ê²½
              setSelectedSequences(prev => {
                const updated = [...prev];
                updated[currentSequenceIndex] = {
                  ...updated[currentSequenceIndex],
                  status: 'running'
                };
                return updated;
              });
              
              // ë™ì¼ ì‹œí€€ìŠ¤ ì¬ì‹¤í–‰
              executeSequence(currentSequenceIndex);
            } else {
              console.log(`ìë™í™” ê³µì •ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹œí€€ìŠ¤ ${currentSequenceIndex} ë°˜ë³µ ì‹¤í–‰ ì·¨ì†Œ.`);
            }
          }, waitTime * 1000);
          
          // íƒ€ì„ì•„ì›ƒ ID ì €ì¥
          setCountdownIntervals(prev => ({
            ...prev,
            [`repeat_${currentSequenceIndex}`]: timeoutId
          }));
        } else {
          // ëŒ€ê¸° ì‹œê°„ì´ ì—†ìœ¼ë©´ ë°”ë¡œ ì¬ì‹¤í–‰
          console.log(`âœ“ ëŒ€ê¸° ì‹œê°„ ì—†ìŒ. ì‹œí€€ìŠ¤ ${currentSequenceIndex + 1} ì¦‰ì‹œ ë°˜ë³µ ì‹¤í–‰`);
          
          // ìƒíƒœë¥¼ 'running'ìœ¼ë¡œ ë‹¤ì‹œ ì„¤ì •
          setSelectedSequences(prev => {
            const updated = [...prev];
            updated[currentSequenceIndex] = {
              ...updated[currentSequenceIndex],
              status: 'running'
            };
            return updated;
          });
          
          // ë™ì¼ ì‹œí€€ìŠ¤ ì¦‰ì‹œ ì¬ì‹¤í–‰
          executeSequence(currentSequenceIndex);
        }
      }
    } catch (error) {
      console.error('forceProgressToNextSequence í•¨ìˆ˜ ì˜¤ë¥˜:', error);
      addLog(`ì‹œí€€ìŠ¤ ì§„í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error}`, true);
    }
  };
  
  // íƒ€ì„ì•„ì›ƒì´ ìˆëŠ” ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ í•¨ìˆ˜ - startCountdown í•¨ìˆ˜ ê°œì„  ë²„ì „
  const startCountdownWithTimeout = (index: number, seconds: number) => {
    if (seconds <= 0) return;
    
    // ì´ë¯¸ ì¹´ìš´íŠ¸ë‹¤ìš´ì´ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
    if (countdownIntervals[`interval_${index}`]) {
      console.log(`ì‹œí€€ìŠ¤ ${index + 1}ì˜ ì¹´ìš´íŠ¸ë‹¤ìš´ì´ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.`);
      return;
    }
    
    console.log(`ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (ê°œì„ ëœ ë²„ì „) - ì‹œí€€ìŠ¤ ${index + 1}, ${seconds}ì´ˆ`);
    
    // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ ì‹œê°„
    const startTime = Date.now();
    const endTime = startTime + (seconds * 1000);
    
    // MQTTë¡œ ëŒ€ê¸° ì‹œê°„ ì •ë³´ ë°œí–‰
    if (mqttClient) {
      try {
        const waitingMessage = JSON.stringify({
          waiting: true,
          sequenceIndex: index,
          waitTime: seconds,
          startTime: startTime,
          endTime: endTime,
          sequenceName: selectedSequences[index]?.sequence?.name || `ì‹œí€€ìŠ¤ ${index + 1}`
        });
        
        // ìë™í™” ìƒíƒœ í† í”½ìœ¼ë¡œ ëŒ€ê¸° ì‹œê°„ ì •ë³´ ë°œí–‰
        mqttClient.publish('extwork/automation/status', waitingMessage);
        console.log(`ëŒ€ê¸° ì‹œê°„ ì •ë³´ ë°œí–‰: ${waitingMessage}`);
      } catch (err) {
        console.error('ëŒ€ê¸° ì‹œê°„ ì •ë³´ ë°œí–‰ ì‹¤íŒ¨:', err);
      }
    }
    
    // ì´ˆê¸° ì¹´ìš´íŠ¸ë‹¤ìš´ ê°’ ì„¤ì •
    setWaitingCountdowns(prev => ({
      ...prev,
      [index]: seconds
    }));
    
    // ì‹œí€€ìŠ¤ ìƒíƒœë¥¼ ëª…ì‹œì ìœ¼ë¡œ 'waiting'ìœ¼ë¡œ ì„¤ì •
    setSelectedSequences(prev => {
      const updated = [...prev];
      updated[index] = {
        ...updated[index],
        status: 'waiting'
      };
      return updated;
    });
    
    // 1ì´ˆë§ˆë‹¤ ì¹´ìš´íŠ¸ë‹¤ìš´ ê°ì†Œ
    const intervalId = setInterval(() => {
      setWaitingCountdowns(prev => {
        const currentCount = prev[index];
        
        if (!currentCount || currentCount <= 1) {
          // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¢…ë£Œ
          clearInterval(intervalId);
          clearCountdown(index);
          console.log(`ì‹œí€€ìŠ¤ ${index}ì˜ ì¹´ìš´íŠ¸ë‹¤ìš´ ì™„ë£Œ`);
          
          // MQTTë¡œ ëŒ€ê¸° ì™„ë£Œ ì •ë³´ ë°œí–‰
          if (mqttClient) {
            try {
              const completeMessage = JSON.stringify({
                waiting: false,
                sequenceIndex: index,
                sequenceName: selectedSequences[index]?.sequence?.name || `ì‹œí€€ìŠ¤ ${index + 1}`,
                status: 'ready'
              });
              
              // ìë™í™” ìƒíƒœ í† í”½ìœ¼ë¡œ ëŒ€ê¸° ì™„ë£Œ ì •ë³´ ë°œí–‰
              mqttClient.publish('extwork/automation/status', completeMessage);
              console.log(`ëŒ€ê¸° ì™„ë£Œ ì •ë³´ ë°œí–‰: ${completeMessage}`);
            } catch (err) {
              console.error('ëŒ€ê¸° ì™„ë£Œ ì •ë³´ ë°œí–‰ ì‹¤íŒ¨:', err);
            }
          }
          
          // ìë™í™” ìƒíƒœ í™•ì¸ í›„ ì‹¤í–‰
          if (automationRunningRef.current) {
            console.log(`âœ… ëŒ€ê¸° ì‹œê°„ ì™„ë£Œ, ì‹œí€€ìŠ¤ ${index + 1} ì‹¤í–‰ ì‹œì‘`);
            executeSequence(index);
          } else {
            console.log(`âš ï¸ ìë™í™”ê°€ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹ˆë¯€ë¡œ ì‹œí€€ìŠ¤ ${index + 1} ì‹¤í–‰ì´ ì·¨ì†Œë¨`);
          }
          
          return {
            ...prev,
            [index]: 0
          };
        }
        
        console.log(`ì‹œí€€ìŠ¤ ${index}ì˜ ì¹´ìš´íŠ¸ë‹¤ìš´: ${currentCount - 1}ì´ˆ ë‚¨ìŒ`);
        
        return {
          ...prev,
          [index]: currentCount - 1
        };
      });
    }, 1000);
    
    // ì¸í„°ë²Œ ID ì €ì¥
    setCountdownIntervals(prev => ({
      ...prev,
      [`interval_${index}`]: intervalId
    }));
    
    // ëŒ€ê¸° ì‹œê°„ ì¢…ë£Œ í›„ ì‹¤í–‰í•  íƒ€ì„ì•„ì›ƒ ì„¤ì • (ì¤‘ë³µìœ¼ë¡œ ì„¤ì •)
    const timeoutId = setTimeout(() => {
      clearInterval(intervalId);
      clearCountdown(index);
      
      // ìë™í™” ìƒíƒœ í™•ì¸ í›„ ì‹¤í–‰
      if (automationRunningRef.current) {
        console.log(`âœ… ëŒ€ê¸° ì‹œê°„ ì™„ë£Œ (íƒ€ì„ì•„ì›ƒ), ì‹œí€€ìŠ¤ ${index + 1} ì‹¤í–‰ ì‹œì‘`);
        executeSequence(index);
      } else {
        console.log(`âš ï¸ ìë™í™”ê°€ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹ˆë¯€ë¡œ ì‹œí€€ìŠ¤ ${index + 1} ì‹¤í–‰ì´ ì·¨ì†Œë¨ (íƒ€ì„ì•„ì›ƒ)`);
      }
    }, seconds * 1000 + 500); // 0.5ì´ˆ ì—¬ìœ  ì¶”ê°€
    
    // íƒ€ì„ì•„ì›ƒ IDë„ ì €ì¥
    setCountdownIntervals(prev => ({
      ...prev,
      [`timeout_${index}`]: timeoutId
    }));
  };
  
  // MQTT ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ì—ì„œ ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€ ë¡œì§ ìˆ˜ì •
  useEffect(() => {
    if (!mqttClient) return;
    
    console.log('MQTT í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ì„¤ì • ì¤‘...');
    
    // MQTT ë©”ì‹œì§€ ì²˜ë¦¬
    const messageHandler = (topic: string, message: Buffer) => {
      try {
        const messageStr = message.toString();
        
        // ì¶œë ¥ í† í”½ ì²˜ë¦¬ - ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€ ê°•í™”
        if (topic === EXTRACTION_OUTPUT_TOPIC) {
          console.log(`ğŸ“¥ [OUTPUT] ${messageStr}`);
          addLog(`ìƒíƒœ ë©”ì‹œì§€ ìˆ˜ì‹ : ${messageStr}`, true);
          
          // ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€
          const isCompletionMessage = messageStr.toLowerCase().includes('ê³µì • ì¢…ë£Œ') || 
                                    messageStr.toLowerCase().includes('ê³µì •ì¢…ë£Œ');
          
          // ì™„ë£Œ ë©”ì‹œì§€ê°€ ê°ì§€ë˜ë©´ ê°•ì œ ì‹œí€€ìŠ¤ ì „í™˜ ì‹¤í–‰
          if (isCompletionMessage) {
            console.log(`ğŸš¨ ì™„ë£Œ ë©”ì‹œì§€ ê°ì§€: "${messageStr}"`);
            forceProgressToNextSequence();
            return;
          } else if (messageStr.includes("JSON ëª…ë ¹ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤")) {
            // JSON ëª…ë ¹ ì„±ê³µ ë©”ì‹œì§€ - ì‹œí€€ìŠ¤ ì‹œì‘ì„ ì•Œë¦¼
            addLog(`ì‹œí€€ìŠ¤ ëª…ë ¹ì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤.`, true);
          }
        }
      } catch (error) {
        console.error('MQTT ë©”ì‹œì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', error);
      }
    };
    
    // MQTT êµ¬ë… ì„¤ì •
    mqttClient.on('message', messageHandler);
    
    return () => {
      mqttClient.off("message", messageHandler);
    };
  }, [mqttClient, selectedSequences]);
  
  // ë“œë˜ê·¸ ì‹œì‘ í•¨ìˆ˜
  const startDrag = (e: React.MouseEvent) => {
    if (popupRef.current) {
      e.preventDefault();
      e.stopPropagation(); // ì´ë²¤íŠ¸ ë²„ë¸”ë§ ì¤‘ì§€
      setIsDragging(true);
      const rect = popupRef.current.getBoundingClientRect();
      setDragOffset({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      });
    }
  };

  // ë§ˆìš°ìŠ¤ ì´ë™ í•¸ë“¤ëŸ¬ - ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•˜ê³  íŒì—… ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤
  const handleMouseMove = (e: MouseEvent) => {
    if (isDragging && popupRef.current) {
      e.preventDefault(); // ê¸°ë³¸ ë™ì‘ ë°©ì§€
      e.stopPropagation(); // ì´ë²¤íŠ¸ ë²„ë¸”ë§ ì¤‘ì§€
      
      const newX = e.clientX - dragOffset.x;
      const newY = e.clientY - dragOffset.y;
      
      // ì œì•½ ì¡°ê±´ì„ ì¶”ê°€í•˜ì—¬ ì°½ ì•ˆì—ì„œë§Œ ì´ë™í•˜ë„ë¡ ì œí•œ
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const popupWidth = popupRef.current.offsetWidth;
      const popupHeight = popupRef.current.offsetHeight;
      
      // í™”ë©´ ë‚´ì—ì„œë§Œ ì´ë™í•˜ë„ë¡ ì œí•œ
      const constrainedX = Math.max(0, Math.min(newX, windowWidth - popupWidth));
      const constrainedY = Math.max(0, Math.min(newY, windowHeight - popupHeight));
      
      setPopupPosition({
        x: constrainedX,
        y: constrainedY
      });
    }
  };

  // ë§ˆìš°ìŠ¤ ì—… í•¸ë“¤ëŸ¬ - ë“œë˜ê·¸ ìƒíƒœë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤
  const handleMouseUp = () => {
    setIsDragging(false);
  };

  // íŒì—… ë‚´ë¶€ í´ë¦­ ì²˜ë¦¬
  const handlePopupClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    e.preventDefault();
  };

  // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
  useEffect(() => {
    // ì „ì—­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    // ì „ì—­ í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ - íŒì—… ì™¸ë¶€ í´ë¦­ ë°©ì§€ (ìº¡ì²˜ ë‹¨ê³„ì—ì„œ)
    const handleGlobalClick = (e: MouseEvent) => {
      if (showTimePopup !== null && popupRef.current && !popupRef.current.contains(e.target as Node)) {
        // íŒì—… ì™¸ë¶€ í´ë¦­ ì‹œì—ë§Œ ì´ë²¤íŠ¸ ì¤‘ë‹¨ (íŒì—… ë‹«í˜ ë°©ì§€)
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    };
    
    // ì „ì—­ í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ - íŒì—… ì™¸ë¶€ í´ë¦­ ë°©ì§€ (ìº¡ì²˜ ë‹¨ê³„ì—ì„œ)
    document.addEventListener('click', handleGlobalClick, { capture: true });
    document.addEventListener('mousedown', handleGlobalClick, { capture: true });
    document.addEventListener('mouseup', handleGlobalClick, { capture: true });
    document.addEventListener('pointerdown', handleGlobalClick, { capture: true });
    document.addEventListener('pointerup', handleGlobalClick, { capture: true });

    // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.removeEventListener('click', handleGlobalClick, { capture: true });
      document.removeEventListener('mousedown', handleGlobalClick, { capture: true });
      document.removeEventListener('mouseup', handleGlobalClick, { capture: true });
      document.removeEventListener('pointerdown', handleGlobalClick, { capture: true });
      document.removeEventListener('pointerup', handleGlobalClick, { capture: true });
    };
  }, [isDragging, dragOffset, showTimePopup]);
  
  // íŒì—… ë“œë˜ê·¸ ì‹œì‘ í•¸ë“¤ëŸ¬
  const handleMouseDown = (e: React.MouseEvent) => {
    if (popupRef.current) {
      e.preventDefault();
      e.stopPropagation(); // ì´ë²¤íŠ¸ ë²„ë¸”ë§ ì¤‘ì§€
      setIsDragging(true);
      const rect = popupRef.current.getBoundingClientRect();
      setDragOffset({
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      });
    }
  };
  
  return (
    <div className="space-y-4">
      {/* í˜ì´ì§€ ì´ë™ ë° ë¦¬ì…‹ ê°€ëŠ¥ ì•ˆë‚´ ë©”ì‹œì§€ */}
      {status === 'running' && (
        <div className="bg-yellow-50 border border-yellow-200 rounded-md p-2 text-sm flex items-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-yellow-500">
            <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
            <line x1="12" y1="9" x2="12" y2="13"></line>
            <line x1="12" y1="17" x2="12.01" y2="17"></line>
          </svg>
          <span>
            <strong>ì•ˆë‚´:</strong> ìë™í™” ê³µì •ì´ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. ë‹¤ë¥¸ í˜ì´ì§€ë¡œ ì´ë™í•˜ê±°ë‚˜ í•„ìš”ì‹œ ì–¸ì œë“ ì§€ <strong>ë¦¬ì…‹ ë²„íŠ¼</strong>ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
          </span>
        </div>
      )}
      
      {/* UI ë¹„í™œì„±í™” í•´ê²° ì•ˆë‚´ ë©”ì‹œì§€ */}
      {(status === 'completed' || status === 'error') && (
        <div className="bg-blue-50 border border-blue-200 rounded-md p-2 text-sm flex items-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-blue-500">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="8" x2="12" y2="12"></line>
            <line x1="12" y1="16" x2="12.01" y2="16"></line>
          </svg>
          <span>
            <strong>ì•ˆë‚´:</strong> ìë™í™” ê³µì •ì´ {status === 'completed' ? 'ì™„ë£Œ' : 'ì˜¤ë¥˜'} ìƒíƒœì…ë‹ˆë‹¤. 
            UI ìš”ì†Œê°€ ë¹„í™œì„±í™”ëœ ê²½ìš° <strong>ë¦¬ì…‹</strong> ë˜ëŠ” <strong>ì™„ì „ ì´ˆê¸°í™”</strong> ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            ìƒˆë¡œ ê³ ì¹¨ í›„ì—ë„ ë¬¸ì œê°€ ì§€ì†ë˜ë©´ ì™„ì „ ì´ˆê¸°í™”ë¥¼ ìˆ˜í–‰í•˜ì„¸ìš”.
          </span>
        </div>
      )}
      
      <Card className={getStatusBgColor()}>
        <CardHeader className="py-3">
          <CardTitle className="flex justify-between items-center">
            <span>ìë™í™” ê³µì • ìƒíƒœ</span>
            <div className="text-sm font-medium">
              <span>ìƒíƒœ: {getStatusText()}</span>
              {currentSequenceIndex >= 0 && (
                <span className="ml-2">
                  ({currentSequenceIndex + 1}/{selectedSequences.length})
                </span>
              )}
            </div>
          </CardTitle>
        </CardHeader>
      </Card>
      
      <div className="flex gap-2">
        <Select
          value={selectedSequenceName}
          onValueChange={(value) => {
            addSequence(value);
            // ì„ íƒëœ ê°’ì„ ìœ ì§€í•˜ì—¬ ë“œë¡­ë‹¤ìš´ì´ ê³„ì† ì—´ë ¤ìˆë„ë¡ í•¨
          }}
          disabled={false} // í•­ìƒ í™œì„±í™”
        >
          <SelectTrigger className="w-[200px]">
            <SelectValue placeholder="ì‘ì—…(extwork)" />
          </SelectTrigger>
          <SelectContent>
            {availableSequences.length > 0 ? (
              availableSequences.map((name) => (
                <SelectItem key={name} value={name}>
                  {name}
                </SelectItem>
              ))
            ) : (
              <div className="text-xs text-center py-2 text-gray-500">
                ì‚¬ìš© ê°€ëŠ¥í•œ ì‹œí€€ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤
              </div>
            )}
          </SelectContent>
        </Select>
        
        <div className="flex-1"></div>
        
        <Button 
          variant="outline" 
          size="sm"
          onClick={() => setShowSaveDialog(true)}
          disabled={selectedSequences.length === 0} // ì‹œí€€ìŠ¤ê°€ ì—†ìœ¼ë©´ ë¹„í™œì„±í™”
          className="gap-1 bg-blue-50 border-blue-300 hover:bg-blue-100 min-w-[180px] h-10"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-5 w-5 text-blue-600">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
          </svg>
          <span className="font-semibold">Databaseì— ì €ì¥</span>
        </Button>
        
        <Button 
          variant="outline" 
          size="sm"
          onClick={() => setShowLoadDialog(true)}
          disabled={savedProcesses.length === 0} // ì €ì¥ëœ í”„ë¡œì„¸ìŠ¤ê°€ ì—†ìœ¼ë©´ ë¹„í™œì„±í™”
          className="gap-1 bg-green-50 border-green-300 hover:bg-green-100 min-w-[180px] h-10"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-5 w-5 text-green-600">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          <span className="font-semibold">Databaseì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°</span>
        </Button>
        
        <Button 
          variant="default" 
          size="sm"
          onClick={() => {
            if (selectedSequences.length > 0) {
              setStatus('running');
              automationRunningRef.current = true;
              
              // ì²« ë²ˆì§¸ ì‹œí€€ìŠ¤ë„ ëŒ€ê¸° ì‹œê°„ì„ ì ìš©í•˜ê³  ì‹¤í–‰
              const firstSequence = selectedSequences[0];
              if (firstSequence.waitTime > 0) {
                // ëŒ€ê¸° ì‹œê°„ì´ ìˆìœ¼ë©´ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                addLog(`ì²« ë²ˆì§¸ ì‹œí€€ìŠ¤ ${firstSequence.waitTime}ì´ˆ í›„ ì‹œì‘: ${firstSequence.sequence.name}`, true);
                
                // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘
                startCountdownWithTimeout(0, firstSequence.waitTime);
                
                // ëŒ€ê¸° ì‹œê°„ í›„ ì‹œí€€ìŠ¤ ì‹¤í–‰
                const timeoutId = setTimeout(() => {
                  // ì¹´ìš´íŠ¸ë‹¤ìš´ ì •ë¦¬
                  clearCountdown(0);
                  // ì²« ë²ˆì§¸ ì‹œí€€ìŠ¤ ì‹¤í–‰
                  executeSequence(0);
                }, firstSequence.waitTime * 1000);
                
                // íƒ€ì„ì•„ì›ƒ ID ì €ì¥
                setCountdownIntervals(prev => ({
                  ...prev,
                  [0]: timeoutId
                }));
              } else {
                // ëŒ€ê¸° ì‹œê°„ì´ ì—†ìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰
                executeSequence(0);
              }
            }
          }}
          disabled={selectedSequences.length === 0 || status === 'running'} // ì‹œí€€ìŠ¤ê°€ ì—†ê±°ë‚˜ ì‹¤í–‰ ì¤‘ì´ë©´ ë¹„í™œì„±í™”
          className="gap-1 min-w-[120px] h-10 bg-blue-600 hover:bg-blue-700"
        >
          <Play className="h-5 w-5" />
          <span className="font-semibold">ì¼ê´„ ì‹¤í–‰</span>
        </Button>
        
        <Button 
          variant="destructive" 
          size="sm"
          onClick={resetAutomation}
          disabled={false}
          className="gap-1 font-bold px-6 h-10"
        >
          <RotateCcw className="h-5 w-5 mr-1" />
          ë¦¬ì…‹
        </Button>
        
        <Button 
          variant="outline" 
          size="sm"
          onClick={fullReset}
          className="gap-1 border-red-300 text-red-600 hover:bg-red-50 h-10"
        >
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-5 w-5 mr-1">
            <path d="M3 3h18v18H3zM12 12h.01"/>
            <path d="M8 12h.01M16 12h.01M12 16h.01M12 8h.01"/>
            <path d="M4 4l16 16"/>
          </svg>
          ì™„ì „ ì´ˆê¸°í™”
        </Button>
      </div>

      {selectedSequences.length > 0 && (
        <div className="border rounded-md">
          <div className="p-2 space-y-2 max-h-[400px] overflow-y-auto">
            {selectedSequences.map((item, index) => (
              <div
                key={`${item.id}`}
                className={`p-2 border rounded-md flex items-center justify-between ${
                  currentSequenceIndex === index && status === 'running' && item.status === 'running'
                    ? 'bg-blue-50 border-blue-300'
                    : item.status === 'completed' 
                      ? 'bg-green-50 border-green-200'
                      : item.status === 'error'
                        ? 'bg-red-50 border-red-200' 
                        : 'bg-white'
                }`}
              >
                <div className="flex-1">
                  <div className="flex justify-between items-center">
                    <div className="font-medium">
                      {index + 1}. {item.sequence.name}
                    </div>
                    <div className="flex items-center gap-2">
                      {/* ëŒ€ê¸° ì¤‘ì¸ ì‹œí€€ìŠ¤ì— ëŒ€í•œ ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ - ëª¨ë“  ëŒ€ê¸° ì¤‘ì¸ ì‹œí€€ìŠ¤ì— í‘œì‹œ */}
                      {item.status === 'waiting' && status === 'running' && waitingCountdowns[index] > 0 && (
                        <div className="text-xs text-blue-600 animate-pulse bg-blue-50 px-2 py-0.5 rounded-md border border-blue-200">
                          {waitingCountdowns[index]}ì´ˆ í›„ ì‹œì‘
                        </div>
                      )}
                      <StatusBadge status={item.status} />
                    </div>
                  </div>
                  <div className="text-xs text-gray-500 mt-1 flex items-center gap-3">
                    <span>
                      ëª¨ë“œ: {item.sequence.operation_mode} 
                      ({Math.floor(item.sequence.operation_mode / 10) === 1 ? 'ë™ì‹œ' : 
                        Math.floor(item.sequence.operation_mode / 10) === 2 ? 'ìˆœì°¨' : 'ì¤‘ì²©'}  
                       {item.sequence.operation_mode % 10 === 1 ? 'ì¶”ì¶œìˆœí™˜' : 
                         item.sequence.operation_mode % 10 === 2 ? 'ì „ì²´ìˆœí™˜' : 'ë³¸íƒ±í¬ìˆ˜ì§‘'}) 
                      <span className="ml-1 bg-blue-100 text-blue-700 px-1 rounded-sm"> 
                        ì‹œí€€ìŠ¤ {Math.ceil(item.sequence.process.length / (Math.floor(item.sequence.operation_mode / 10) === 1 ? 6 : Math.floor(item.sequence.operation_mode / 10) === 2 ? 18 : 12))}ê°œ 
                      </span> 
                    </span>
                    {item.status === 'completed' && item.startTime && item.endTime && (
                      <span className="text-green-600">
                        ì†Œìš”ì‹œê°„: {Math.round((item.endTime - item.startTime) / 1000)}ì´ˆ
                      </span>
                    )}
                  </div>
                </div>
                
                <div className="flex items-center gap-2">
                  {/* ë°˜ë³µ íšŸìˆ˜ ì„¤ì • */}
                  <div className="flex items-center">
                    <span className="text-xs mr-1">ë°˜ë³µ:</span>
                    <input 
                      type="number" 
                      min="1" 
                      max="100"
                      value={item.customRepeats} 
                      onChange={(e) => handleRepeatsChange(index, parseInt(e.target.value) || 1)}
                      disabled={false} // í•­ìƒ í™œì„±í™”
                      className="w-[50px] h-8 px-2 border rounded text-sm"
                    />
                  </div>

                  {/* ëŒ€ê¸° ì‹œê°„ ì„¤ì • */}
                  <div className="flex items-center">
                    <span className="text-xs mr-1">ëŒ€ê¸°:</span>
                    <button
                      onClick={() => openTimePopup(index, item.waitTime)}
                      disabled={false} // í•­ìƒ í™œì„±í™”
                      className="w-[160px] h-8 px-2 border rounded text-sm flex items-center justify-between bg-white overflow-hidden"
                    >
                      <span className="truncate mr-1">{formatTime(item.waitTime)}</span>
                      <span className="text-xs text-gray-500 flex-shrink-0">â–¼</span>
                    </button>
                  </div>
                  
                  {/* ì‹œí€€ìŠ¤ ë³µì œ ë²„íŠ¼ ì¶”ê°€ */}
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => duplicateSequence(index)}
                    disabled={false} // í•­ìƒ í™œì„±í™”
                    title="ì‹œí€€ìŠ¤ ë³µì œ"
                    className="px-2"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="h-4 w-4">
                      <rect x="8" y="8" width="12" height="12" rx="2" ry="2"></rect>
                      <path d="M16 8V6a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h2"></path>
                    </svg>
                  </Button>
                  
                  {/* ì‹œí€€ìŠ¤ ìˆœì„œ ì´ë™ ë²„íŠ¼ */}
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => moveSequenceUp(index)}
                    disabled={index === 0} // ì²« ë²ˆì§¸ í•­ëª©ì´ë©´ ë¹„í™œì„±í™”
                    title="ìœ„ë¡œ ì´ë™"
                    className="px-2"
                  >
                    <ArrowUp className="h-4 w-4" />
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => moveSequenceDown(index)}
                    disabled={index === selectedSequences.length - 1} // ë§ˆì§€ë§‰ í•­ëª©ì´ë©´ ë¹„í™œì„±í™”
                    title="ì•„ë˜ë¡œ ì´ë™"
                    className="px-2"
                  >
                    <ArrowDown className="h-4 w-4" />
                  </Button>
                  
                  {/* ì‹œí€€ìŠ¤ ì‚­ì œ ë²„íŠ¼ */}
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => removeSequence(index)}
                    disabled={false} // í•­ìƒ í™œì„±í™”
                    title="ì‹œí€€ìŠ¤ ì œê±°"
                    className="text-red-500 hover:text-red-700 px-2"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
                
                {/* ëŒ€ê¸° ì‹œê°„ íŒì—… */}
                {showTimePopup === index && (
                  <>
                    {/* ë°°ê²½ ì˜¤ë²„ë ˆì´ ì¶”ê°€ */}
                    <div 
                      className="fixed inset-0 bg-black bg-opacity-30 z-[1000]"
                      onClick={() => setShowTimePopup(null)}
                    />
                    <div 
                      ref={popupRef}
                      className="fixed z-[1001] bg-white border shadow-lg rounded-md p-3" 
                      style={{ 
                        left: popupPosition.x,
                        top: popupPosition.y,
                        maxWidth: '90vw',
                        boxShadow: '0 10px 25px rgba(0, 0, 0, 0.2)'
                      }}
                      onClick={(e) => {
                        // íŒì—… ë‚´ë¶€ í´ë¦­ ì´ë²¤íŠ¸ê°€ ìƒìœ„ë¡œ ì „íŒŒë˜ì§€ ì•Šë„ë¡ ë°©ì§€
                        e.stopPropagation();
                      }}
                    >
                      <div className="space-y-3">
                        <h3 
                          className="font-medium text-sm border-b pb-2 mb-1 cursor-move"
                          onMouseDown={handleMouseDown}
                        >
                          ëŒ€ê¸° ì‹œê°„ ì„¤ì •
                        </h3>
                        
                        <div className="flex gap-2 items-center">
                          <div>
                            <span className="text-xs block mb-1">ì‹œê°„</span>
                            <div className="relative w-20">
                              <button
                                type="button"
                                className="w-full h-10 border rounded text-center flex items-center justify-between px-2 bg-white"
                                onClick={() => document.getElementById(`hours-select-${index}`)?.focus()}
                              >
                                <span className="flex-1 text-center">{tempHours}</span>
                                <span className="text-xs text-gray-500">â–¼</span>
                              </button>
                              <select
                                id={`hours-select-${index}`}
                                className="absolute inset-0 opacity-0 cursor-pointer"
                                value={tempHours}
                                onChange={(e) => {
                                  e.stopPropagation();
                                  setTempHours(Number(e.target.value));
                                }}
                              >
                                {Array.from({ length: 24 }, (_, i) => (
                                  <option key={i} value={i}>{i}</option>
                                ))}
                              </select>
                            </div>
                          </div>
                          <div>
                            <span className="text-xs block mb-1">ë¶„</span>
                            <div className="relative w-20">
                              <button
                                type="button"
                                className="w-full h-10 border rounded text-center flex items-center justify-between px-2 bg-white"
                                onClick={() => document.getElementById(`minutes-select-${index}`)?.focus()}
                              >
                                <span className="flex-1 text-center">{tempMinutes}</span>
                                <span className="text-xs text-gray-500">â–¼</span>
                              </button>
                              <select
                                id={`minutes-select-${index}`}
                                className="absolute inset-0 opacity-0 cursor-pointer"
                                value={tempMinutes}
                                onChange={(e) => {
                                  e.stopPropagation();
                                  setTempMinutes(Number(e.target.value));
                                }}
                              >
                                {Array.from({ length: 60 }, (_, i) => (
                                  <option key={i} value={i}>{i}</option>
                                ))}
                              </select>
                            </div>
                          </div>
                          <div>
                            <span className="text-xs block mb-1">ì´ˆ</span>
                            <div className="relative w-20">
                              <button
                                type="button"
                                className="w-full h-10 border rounded text-center flex items-center justify-between px-2 bg-white"
                                onClick={() => document.getElementById(`seconds-select-${index}`)?.focus()}
                              >
                                <span className="flex-1 text-center">{tempSeconds}</span>
                                <span className="text-xs text-gray-500">â–¼</span>
                              </button>
                              <select
                                id={`seconds-select-${index}`}
                                className="absolute inset-0 opacity-0 cursor-pointer"
                                value={tempSeconds}
                                onChange={(e) => {
                                  e.stopPropagation();
                                  setTempSeconds(Number(e.target.value));
                                }}
                              >
                                {Array.from({ length: 60 }, (_, i) => (
                                  <option key={i} value={i}>{i}</option>
                                ))}
                              </select>
                            </div>
                          </div>
                        </div>
                        
                        <div className="flex gap-2 justify-end mt-2">
                          <Button 
                            variant="outline" 
                            size="sm" 
                            onClick={() => setShowTimePopup(null)}
                          >
                            ì·¨ì†Œ
                          </Button>
                          <Button 
                            variant="default" 
                            size="sm"
                            onClick={() => saveTimePopup(index)}
                          >
                            ì €ì¥
                          </Button>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-2">
                          <Button 
                            variant="outline" 
                            size="sm" 
                            onClick={() => {
                              setTempHours(0);
                              setTempMinutes(1);
                              setTempSeconds(0);
                              setTimeout(() => saveTimePopup(index), 10);
                            }}
                          >
                            1ë¶„ 0ì´ˆ
                          </Button>
                          <Button 
                            variant="outline" 
                            size="sm" 
                            onClick={() => {
                              setTempHours(0);
                              setTempMinutes(10);
                              setTempSeconds(0);
                              setTimeout(() => saveTimePopup(index), 10);
                            }}
                          >
                            10ë¶„ 0ì´ˆ
                          </Button>
                        </div>
                      </div>
                    </div>
                  </>
                )}
              </div>
            ))}
          </div>
        </div>
      )}
      
      {/* ì§„í–‰ ì •ë³´ ì„¹ì…˜ */}
      <div className="p-2 bg-gray-50 rounded text-sm">
        <p className="font-medium mb-1">ì§„í–‰ ì •ë³´:</p>
        <div className="flex flex-col">
          {currentSequenceIndex >= 0 && currentSequenceIndex < selectedSequences.length && (
            <div className="text-xs font-semibold mb-1 text-blue-600">
              í˜„ì¬ ì‹œí€€ìŠ¤: {currentSequenceIndex + 1}/{selectedSequences.length} - {selectedSequences[currentSequenceIndex].sequence.name}
              {selectedSequences[currentSequenceIndex].status === 'running' ? ' (ì‹¤í–‰ì¤‘)' : 
               selectedSequences[currentSequenceIndex].status === 'completed' ? ' (ì™„ë£Œ)' : 
               selectedSequences[currentSequenceIndex].status === 'error' ? ' (ì˜¤ë¥˜)' : ' (ëŒ€ê¸°ì¤‘)'}
               
              {/* ëŒ€ê¸° ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ */}
              {selectedSequences[currentSequenceIndex].status === 'waiting' && 
                waitingCountdowns[currentSequenceIndex] > 0 && (
                <span className="ml-2 px-2 py-0.5 bg-amber-100 text-amber-800 rounded animate-pulse">
                  ëŒ€ê¸°ì¤‘: {waitingCountdowns[currentSequenceIndex]}ì´ˆ
                </span>
              )}
            </div>
          )}
          
          {/* ë‹¤ìŒ ì‹œí€€ìŠ¤ì˜ ëŒ€ê¸° ìƒíƒœ í‘œì‹œ */}
          {currentSequenceIndex >= 0 && 
           currentSequenceIndex + 1 < selectedSequences.length && 
           selectedSequences[currentSequenceIndex].status === 'running' && (
            <div className="text-xs text-gray-600 mb-1">
              ë‹¤ìŒ ì‹œí€€ìŠ¤: {selectedSequences[currentSequenceIndex + 1].sequence.name}
              {selectedSequences[currentSequenceIndex + 1].waitTime > 0 && (
                <span className="ml-2 text-amber-600">
                  (ëŒ€ê¸° ì‹œê°„: {selectedSequences[currentSequenceIndex + 1].waitTime}ì´ˆ)
                </span>
              )}
            </div>
          )}
          
          {/* ì‹œí€€ìŠ¤ ìƒíƒœ ìš”ì•½ ì •ë³´ ì¶”ê°€ */}
          <div className="text-xs text-gray-500">
            {selectedSequences.filter(seq => seq.status === 'completed').length}ê°œ ì™„ë£Œ / 
            {selectedSequences.filter(seq => seq.status === 'running').length}ê°œ ì‹¤í–‰ì¤‘ / 
            {selectedSequences.filter(seq => seq.status === 'waiting').length}ê°œ ëŒ€ê¸°ì¤‘ /
            {selectedSequences.filter(seq => seq.status === 'error').length}ê°œ ì˜¤ë¥˜
            
            {/* ì „ì²´ ëŒ€ê¸° ì‹œê°„ ì •ë³´ */}
            {Object.keys(waitingCountdowns).length > 0 && (
              <div className="mt-1 text-amber-600">
                {Object.entries(waitingCountdowns).map(([index, countdown]) => (
                  <span key={index} className="mr-2">
                    {selectedSequences[parseInt(index)].sequence.name} ({countdown}ì´ˆ ëŒ€ê¸°ì¤‘)
                  </span>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
      
      {/* PROCESS_PROGRESS_TOPIC ë‚´ìš© ì¶œë ¥ */}
      <div className="p-2 bg-gray-100 rounded border border-gray-300 text-sm">
        <p className="font-medium mb-1 text-sm">ì§„í–‰ ìƒíƒœ (Topic: {PROCESS_PROGRESS_TOPIC}):</p>
        <div className="text-xs bg-white p-2 rounded h-20 overflow-y-auto font-mono">
          {progress ? (
            // ì•ˆì „í•˜ê²Œ ë©”ì‹œì§€ í‘œì‹œ - JSON ê°ì²´ì¸ ê²½ìš° ë¬¸ìì—´ë¡œ ë³€í™˜
            typeof progress === 'object' ? 
              JSON.stringify(progress) : 
              progress
          ) : 'ì§„í–‰ ìƒíƒœ ë©”ì‹œì§€ ëŒ€ê¸° ì¤‘...'}
        </div>
      </div>
      
      <div>
        <p className="font-medium mb-1 text-sm">ë¡œê·¸ ë©”ì‹œì§€:</p>
        <div className="p-2 bg-gray-50 rounded text-xs h-28 overflow-y-auto">
          {logMessages.length === 0 ? (
            <p className="text-gray-500">ë¡œê·¸ ì—†ìŒ</p>
          ) : (
            <ul className="space-y-1">
              {logMessages.map((msg, idx) => (
                <li key={idx}>{msg}</li>
              ))}
            </ul>
          )}
        </div>
      </div>
      
      {/* í ì»¨íŠ¸ë¡¤ ì„¹ì…˜ */}
      <Card>
        <CardHeader className="py-3">
          <CardTitle className="flex justify-between items-center">
            <span>Queue Control</span>
            <div className="text-sm font-medium">
              <span>Queue Status: {queueStatus ? `${queueStatus.count} items` : 'Unknown'}</span>
            </div>
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {/* í ì»¨íŠ¸ë¡¤ ë²„íŠ¼ */}
            <div className="flex gap-2 flex-wrap">
              <Button
                variant="outline"
                size="sm"
                onClick={resumeQueueProcessing}
                className="gap-1"
              >
                <Play className="h-4 w-4" />
                Resume
              </Button>
              
              <Button
                variant="outline"
                size="sm"
                onClick={pauseQueueProcessing}
                className="gap-1"
              >
                <Square className="h-4 w-4" />
                Pause
              </Button>

              <Button
                variant="outline"
                size="sm"
                onClick={listQueue}
                className="gap-1"
              >
                List
              </Button>
              
              <Button
                variant="outline"
                size="sm"
                onClick={removeAllQueueItems}
                className="gap-1"
              >
                Remove
              </Button>
              
              <Button
                variant="destructive"
                size="sm"
                onClick={clearQueue}
                className="gap-1 ml-auto"
              >
                <X className="h-4 w-4" />
                Clear Queue
              </Button>
            </div>

            {/* í ìƒíƒœ í…ìŠ¤íŠ¸ ë°•ìŠ¤ */}
            <div className="border rounded-md p-2">
              <div className="text-xs font-mono bg-black text-white p-2 rounded h-[160px] overflow-y-auto whitespace-pre">
                {queueStatus ? 
                  JSON.stringify(queueStatus, null, 2) : 
                  'Waiting for queue status...\n\nTopic: extwork/extraction/queue/status'}
              </div>
            </div>
            
            {/* í í•­ëª© ëª©ë¡ */}
            {queueStatus && queueStatus.items && queueStatus.items.length > 0 ? (
              <div className="border rounded-md">
                <div className="p-2 space-y-2 max-h-[200px] overflow-y-auto">
                  {queueStatus.items.map((item, index) => (
                    <div
                      key={item.id}
                      className="p-2 border rounded-md flex items-center justify-between bg-white"
                    >
                      <div className="flex-1">
                        <div className="flex justify-between items-center">
                          <div className="font-medium">
                            {index + 1}. {item.name}
                          </div>
                          <div className="text-xs text-gray-500">
                            {new Date(item.timestamp).toLocaleString()}
                          </div>
                        </div>
                      </div>
                      
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={() => removeQueueItem(item.id)}
                        className="h-8 w-8 p-0"
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    </div>
                  ))}
                </div>
              </div>
            ) : (
              <div className="text-center py-4 text-gray-500">
                {queueStatus ? 'No items in queue' : 'Loading queue status...'}
              </div>
            )}
            
            {/* ìˆ˜ë™ ëª…ë ¹ ë°œí–‰ */}
            <div className="border-t pt-3 mt-3">
              <p className="text-xs text-gray-500 mb-2">Manual Command (Topic: {EXTRACTION_INPUT_TOPIC})</p>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={manualCommand}
                  onChange={(e) => setManualCommand(e.target.value)}
                  placeholder="Enter command token"
                  maxLength={25}
                  className="flex-1 h-8 px-2 border rounded text-sm"
                />
                <Button
                  variant="outline"
                  size="sm"
                  onClick={publishManualCommand}
                  className="gap-1"
                >
                  Publish
                </Button>
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
      
      {/* ìë™í™” ê³µì • ì €ì¥ ë‹¤ì´ì–¼ë¡œê·¸ */}
      <Dialog open={showSaveDialog} onOpenChange={setShowSaveDialog}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>ìë™í™” ê³µì • KV Databaseì— ì €ì¥</DialogTitle>
            <DialogDescription>
              í˜„ì¬ êµ¬ì„±ëœ ì‹œí€€ìŠ¤ë“¤ì„ ìë™í™” ê³µì •ìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤.
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="process-name" className="text-right">
                ê³µì • ì´ë¦„
              </Label>
              <Input
                id="process-name"
                placeholder="ìë™í™” ê³µì • ì´ë¦„ ì…ë ¥"
                value={processName}
                onChange={(e) => setProcessName(e.target.value)}
                className="col-span-3"
              />
            </div>
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="process-description" className="text-right">
                ì„¤ëª… (ì„ íƒ)
              </Label>
              <Input
                id="process-description"
                placeholder="ê³µì •ì— ëŒ€í•œ ì„¤ëª… (ì„ íƒì‚¬í•­)"
                value={processDescription}
                onChange={(e) => setProcessDescription(e.target.value)}
                className="col-span-3"
              />
            </div>
            <div className="px-1 py-2 text-sm">
              <span className="font-medium">í¬í•¨ëœ ì‹œí€€ìŠ¤:</span>
              <div className="mt-1 space-y-1 text-gray-500">
                {selectedSequences.map((seq, index) => (
                  <div key={seq.id}>
                    {index + 1}. {seq.sequence.name} (ë°˜ë³µ: {seq.customRepeats}íšŒ, ëŒ€ê¸°: {formatTime(seq.waitTime)})
                  </div>
                ))}
              </div>
            </div>
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button type="button" variant="secondary">
                ì·¨ì†Œ
              </Button>
            </DialogClose>
            <Button type="submit" onClick={saveProcess} disabled={isLoading || !processName.trim() || selectedSequences.length === 0} className="bg-blue-600 hover:bg-blue-700">
              {isLoading ? (
                <div className="flex items-center">
                  <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  ì €ì¥ ì¤‘...
                </div>
              ) : (
                'ì €ì¥'
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* ìë™í™” ê³µì • ë¶ˆëŸ¬ì˜¤ê¸° ë‹¤ì´ì–¼ë¡œê·¸ */}
      <Dialog open={showLoadDialog} onOpenChange={setShowLoadDialog}>
        <DialogContent className="sm:max-w-[525px]">
          <DialogHeader>
            <DialogTitle>ìë™í™” ê³µì • KV Databaseì—ì„œ ë¶ˆëŸ¬ì˜¤ê¸°</DialogTitle>
            <DialogDescription>
              ì €ì¥ëœ ìë™í™” ê³µì • ëª©ë¡ì—ì„œ ë¶ˆëŸ¬ì˜¬ ê³µì •ì„ ì„ íƒí•˜ì„¸ìš”.
            </DialogDescription>
          </DialogHeader>
          <div className="py-4">
            {savedProcesses.length === 0 ? (
              <div className="text-center py-6 text-gray-500">
                ì €ì¥ëœ ìë™í™” ê³µì •ì´ ì—†ìŠµë‹ˆë‹¤.
              </div>
            ) : (
              <div className="space-y-3 max-h-[300px] overflow-y-auto pr-1">
                {savedProcesses.map((process) => (
                  <div
                    key={process.id}
                    className={`p-3 border rounded-md cursor-pointer ${
                      selectedProcessId === process.id ? 'border-blue-500 bg-blue-50' : 'border-gray-200'
                    }`}
                    onClick={() => setSelectedProcessId(process.id)}
                  >
                    <div className="flex justify-between items-start">
                      <div>
                        <div className="font-medium">{process.name}</div>
                        {process.description && (
                          <div className="text-xs text-gray-500 mt-1">{process.description}</div>
                        )}
                        <div className="text-xs text-gray-400 mt-1">
                          ì‹œí€€ìŠ¤: {process.sequences.length}ê°œ, 
                          ìƒì„±ì¼: {new Date(process.createdAt).toLocaleDateString()}
                        </div>
                      </div>
                      {selectedProcessId === process.id && (
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation();
                            setShowDeleteConfirm(true);
                          }}
                          className="h-7 w-7 p-0 text-red-500"
                        >
                          <X className="h-4 w-4" />
                        </Button>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
          <DialogFooter>
            <DialogClose asChild>
              <Button type="button" variant="secondary">
                ì·¨ì†Œ
              </Button>
            </DialogClose>
            <Button type="submit" onClick={loadProcess} disabled={isLoading || !selectedProcessId} className="bg-green-600 hover:bg-green-700">
              {isLoading ? (
                <div className="flex items-center">
                  <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
                </div>
              ) : (
                'ë¶ˆëŸ¬ì˜¤ê¸°'
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* ì‚­ì œ í™•ì¸ ë‹¤ì´ì–¼ë¡œê·¸ */}
      <AlertDialog open={showDeleteConfirm} onOpenChange={setShowDeleteConfirm}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>ìë™í™” ê³µì • ì‚­ì œ</AlertDialogTitle>
            <AlertDialogDescription>
              ì •ë§ë¡œ ì´ ìë™í™” ê³µì •ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?
              ì´ ì‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>ì·¨ì†Œ</AlertDialogCancel>
            <AlertDialogAction onClick={deleteProcess} className="bg-red-500 hover:bg-red-600">
              ì‚­ì œ
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
      
      {/* íŒì—…ì°½ì´ ì¤‘ë³µìœ¼ë¡œ í‘œì‹œë˜ëŠ” ë¬¸ì œ í•´ê²° - ë¦¬ìŠ¤íŠ¸ ë‚´ë¶€ì˜ íŒì—…ì€ ì œê±°í•˜ê³  ì—¬ê¸°ì„œë§Œ í‘œì‹œ */}
      {showTimePopup !== null && (
        <div 
          className="fixed inset-0 z-[9999] bg-black bg-opacity-50 flex items-center justify-center"
          onClick={(e) => {
            // ë°±ê·¸ë¼ìš´ë“œ í´ë¦­ì‹œ íŒì—… ë‹«ê¸°
            setShowTimePopup(null);
            e.stopPropagation();
          }}
        >
          <div 
            ref={popupRef}
            className="bg-white rounded-lg p-6 shadow-2xl relative"
            style={{
              width: '380px',
              zIndex: 10000,
              position: 'absolute',
              left: popupPosition.x,
              top: popupPosition.y,
              cursor: isDragging ? 'grabbing' : 'auto'
            }}
            onClick={(e) => {
              // íŒì—… ë‚´ë¶€ í´ë¦­ ì´ë²¤íŠ¸ê°€ ìƒìœ„ë¡œ ì „íŒŒë˜ì§€ ì•Šë„ë¡ ë°©ì§€
              e.stopPropagation();
            }}
          >
            <div 
              className="flex justify-between items-center mb-4 bg-gray-50 p-2 rounded cursor-grab border-b"
              onMouseDown={handleMouseDown}
            >
              <h3 className="text-lg font-medium">ëŒ€ê¸° ì‹œê°„ ì„¤ì •</h3>
              <button 
                onClick={(e) => {
                  e.stopPropagation();
                  setShowTimePopup(null);
                }}
                className="text-gray-500 hover:text-gray-700"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
              </button>
            </div>
            <div className="flex space-x-4 mt-4 justify-center">
              <div className="flex flex-col items-center">
                <label className="font-medium mb-2">ì‹œê°„</label>
                <select
                  value={tempHours}
                  onChange={(e) => {
                    e.stopPropagation();
                    setTempHours(Number(e.target.value));
                  }}
                  className="w-24 h-12 border-2 rounded-md text-center text-lg"
                  onClick={(e) => e.stopPropagation()}
                  onMouseDown={(e) => e.stopPropagation()}
                >
                  {Array.from({length: 24}, (_, i) => (
                    <option key={`h-${i}`} value={i}>{i}</option>
                  ))}
                </select>
              </div>
              <div className="flex flex-col items-center">
                <label className="font-medium mb-2">ë¶„</label>
                <select
                  value={tempMinutes}
                  onChange={(e) => {
                    e.stopPropagation();
                    setTempMinutes(Number(e.target.value));
                  }}
                  className="w-24 h-12 border-2 rounded-md text-center text-lg"
                  onClick={(e) => e.stopPropagation()}
                  onMouseDown={(e) => e.stopPropagation()}
                >
                  {Array.from({length: 60}, (_, i) => (
                    <option key={`m-${i}`} value={i}>{i}</option>
                  ))}
                </select>
              </div>
              <div className="flex flex-col items-center">
                <label className="font-medium mb-2">ì´ˆ</label>
                <select
                  value={tempSeconds}
                  onChange={(e) => {
                    e.stopPropagation();
                    setTempSeconds(Number(e.target.value));
                  }}
                  className="w-24 h-12 border-2 rounded-md text-center text-lg"
                  onClick={(e) => e.stopPropagation()}
                  onMouseDown={(e) => e.stopPropagation()}
                >
                  {Array.from({length: 60}, (_, i) => (
                    <option key={`s-${i}`} value={i}>{i}</option>
                  ))}
                </select>
              </div>
            </div>
            <div className="flex justify-end mt-6 space-x-3">
              <button 
                className="px-5 py-2 bg-gray-200 hover:bg-gray-300 rounded-md font-medium"
                onClick={(e) => {
                  e.stopPropagation();
                  setShowTimePopup(null);
                }}
              >
                ì·¨ì†Œ
              </button>
              <button 
                className="px-5 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-md font-medium"
                onClick={(e) => {
                  e.stopPropagation();
                  saveTimePopup(showTimePopup!);
                }}
              >
                ì €ì¥
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default AutomationProcess; 